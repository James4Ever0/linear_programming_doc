{
    "2800": {
        "file_id": 310,
        "content": "    else:\n        other_sets = get_other_sets(supertype)\n        wire_other_sets = set([e for k, v in wire_types.items() for e in v])\n    if typename not in other_sets:\n        if typename not in wire_other_sets:\n            mtypes[supertype].add(typename)\n        else:\n            raise Exception(\n                f\"{'Wire ' if is_wire else ''}Type {typename} in category {supertype} appeared to be duplicated with wire types.\"\n            )\n    else:\n        raise Exception(\n            f\"{'Wire ' if is_wire else ''}Type {typename} in category {supertype} appeared to be duplicated with device types.\"\n        )\ndef Connectable(wire_name):\n    return f\"可连接{wire_name}\"\ndef Unconnectable(wire_name):\n    return f\"不可连接{wire_name}\"\nfor io, wire_name, supertype in triplets_with_supertype(io_to_wire, length=2):\n    start = IO(io)\n    end = Connectable(wire_name)\n    created = Unconnectable(wire_name)\n    add_to_types(supertype, start)\n    add_to_types(supertype, end, is_wire=True)\n    add_to_types(supertype, created, is_wire=True)",
        "type": "code",
        "location": "/microgrid_base/type_system.py:142-173"
    },
    "2801": {
        "file_id": 310,
        "content": "This code is checking for duplicate types in different categories and raising exceptions if found. It also creates Connectable, Unconnectable, and other type instances based on input parameters. The code seems to be part of a larger program that handles wire and device types within different supertype categories.",
        "type": "comment"
    },
    "2802": {
        "file_id": 310,
        "content": "    types_connectivity_matrix.update({frozenset([start, end]): created})\n# a = [(e, True) for e in triplets_with_supertype(io_coax_triplets)]\n# logger_print(a)\n# breakpoint()\ndef transform_triplets(triplets, is_io, forward, backward):\n    return [(e, is_io, forward, backward) for e in triplets_with_supertype(triplets)]\nfrom functools import reduce\ntriplets_config = [  # triplets, is_io, forward, backward\n    (source_coax_triplets, False, False, True),\n    (load_coax_triplets, False, True, False),\n    (source_and_load_coax_triplets, False, True, True),\n    #############################################\n    (io_storage_coax_triplets, True, True, False),\n]\nfor (i, o, wire_name, supertype), is_io, forward, backward in reduce(\n    lambda x, y: x + y,\n    [transform_triplets(*c) for c in triplets_config],\n):\n    if is_io:\n        start = IO(i)\n        end = IO(o)\n    else:\n        start = Input(i)\n        end = Output(o)\n    # logger_print(i,o, start, end,wire_name)\n    # breakpoint()\n    connectable_wire_name, unconnectable_wire_name = (",
        "type": "code",
        "location": "/microgrid_base/type_system.py:175-208"
    },
    "2803": {
        "file_id": 310,
        "content": "This code defines a function called `transform_triplets` that takes in four parameters: triplets, is_io, forward, and backward. It returns a new list of tuples where each tuple contains the original triplet along with boolean values for is_io, forward, and backward.\n\nThe variable `triplets_config` contains a list of configurations for different types of triplets. Each configuration consists of four elements: a list of triplets, a boolean value for is_io, two boolean values for forward and backward direction.\n\nA loop iterates over each configuration in `triplets_config`, applies the transformations using `transform_triplets` function, and assigns the start and end nodes based on the boolean value of is_io. The rest of the code is missing due to the truncation.",
        "type": "comment"
    },
    "2804": {
        "file_id": 310,
        "content": "        Connectable(wire_name),\n        Unconnectable(wire_name),\n    )\n    # if types.get(supertype, None) is None:\n    #     types[supertype] = set()\n    # other_sets = set([e for k in types.keys() if k!=supertype for e in types[k]])\n    # if \"储能端\" in start:\n    #     breakpoint()\n    add_to_types(supertype, start)\n    add_to_types(supertype, end)\n    add_to_types(supertype, connectable_wire_name, is_wire=True)\n    add_to_types(supertype, unconnectable_wire_name, is_wire=True)\n    types_connectivity_matrix.update({frozenset([start, end]): connectable_wire_name})\n    if forward:  # original\n        types_connectivity_matrix.update(\n            {frozenset([start, connectable_wire_name]): unconnectable_wire_name}\n        )\n    if backward:\n        types_connectivity_matrix.update(\n            {frozenset([end, connectable_wire_name]): unconnectable_wire_name}\n        )\n# logger_print(types)\n# {\n#     '母线输入',\n#     '不可连接母线',\n#     '可连接储能端母线',\n#     '不可连接供电端母线',\n#     '母线输出',\n#     '供电端输出',\n#     '不可连接储能端母线',\n#     '双向变流器输入输出',",
        "type": "code",
        "location": "/microgrid_base/type_system.py:209-245"
    },
    "2805": {
        "file_id": 310,
        "content": "This code is defining and updating types in a type system for a microgrid. It adds elements related to connectable and unconnectable wires, and updates the types_connectivity_matrix accordingly. The logger_print function logs the updated types dictionary.",
        "type": "comment"
    },
    "2806": {
        "file_id": 310,
        "content": "#     '可连接供电端母线',\n#     '储能端输入输出',\n#     '可连接母线',\n#     '变流器输入'\n# }\nimport json\n# keys = []\n# with open(\"microgrid_device_params_intermediate.json\",'r') as f:\n#     data = json.load(f)\n#     for k,v in data.items():\n#         for k0, v0 in v.items():\n#             keys.append(k0)\n# logger_print(keys)\ncsv_path = \"设备接口-离网型微电网.csv\"\nfrom csv_utils import fix_csv_and_return_dataframe\nport_df = fix_csv_and_return_dataframe(csv_path)\n# lines = []\n# line_sep_count_list = []\n# with open(csv_path, \"r\") as f:\n#     for line in f.readlines():\n#         line_sep_count = line.count(\",\")\n#         if line_sep_count == 0:\n#             continue\n#         lines.append(line)\n#         line_sep_count_list.append(line_sep_count)\n# line_sep_count_max = max(line_sep_count_list)\n# for index, line_sep_count in enumerate(line_sep_count_list):\n#     lines[index] = lines[index].strip() + \",\" * (line_sep_count_max - line_sep_count)\n# with open(csv_path, \"w+\") as f:\n#     for line in lines:\n#         f.write(line + \"\\n\")\n# port_df = pandas.read_csv(csv_path, header=None, on_bad_lines=\"warn\")",
        "type": "code",
        "location": "/microgrid_base/type_system.py:246-285"
    },
    "2807": {
        "file_id": 310,
        "content": "This code reads a CSV file, \"设备接口-离网型微电网.csv\", and updates it to ensure each line contains the same number of columns. The file is then rewritten with the corrected lines. The resulting DataFrame, port_df, will likely be used further in the program's execution.",
        "type": "comment"
    },
    "2808": {
        "file_id": 310,
        "content": "# logger_print(port_df)\nimport numpy\nmycat = None\ndevice_port_dict = {}\nmydevice = None\ncontent_split = True\n# 能源端\noutput_device_with_single_port_to_port_type = revert_dict(\n    {\n        \"柴油\": [\"柴油\"],\n        \"供电端\": [\"光伏发电\", \"风力发电\", \"柴油发电-电接口\"],\n        \"电母线\": [\"变流器-电输出\", \"传输线-电输出\"],\n        \"变压器\": [\"变压器-电输出\"],\n    }\n)\n# 负荷端\ninput_device_with_single_port_to_port_type = revert_dict(\n    {\n        \"负荷电\": [\"电负荷\"],\n        \"柴油\": [\"柴油发电-燃料接口\"],\n        \"电母线\": [\"变压器-电输入\", \"传输线-电输入\"],\n        \"变流器\": [\"变流器-电输入\"],\n    }\n)\n# 储能端\nio_device_with_single_port_to_port_type = revert_dict(\n    {\"电储能端\": [\"锂电池\"], \"双向变流器储能端\": [\"双向变流器-储能端\"], \"双向变流器线路端\": [\"双向变流器-线路端\"]}\n)\ndevice_with_single_port_to_port_type = {\n    k: Input(v) for k, v in input_device_with_single_port_to_port_type.items()\n}\ndevice_with_single_port_to_port_type.update(\n    {k: Output(v) for k, v in output_device_with_single_port_to_port_type.items()}\n)\ndevice_with_single_port_to_port_type.update(\n    {k: IO(v) for k, v in io_device_with_single_port_to_port_type.items()}\n)\nmapped_types = set()",
        "type": "code",
        "location": "/microgrid_base/type_system.py:287-334"
    },
    "2809": {
        "file_id": 310,
        "content": "This code defines mappings for device types and ports, including energy devices, load devices, storage devices, and their input/output types. It creates dictionaries for each type of device, converts the values to Input, Output or IO based on the key, and combines them into a single dictionary 'device_with_single_port_to_port_type'. The set 'mapped_types' will be used later.",
        "type": "comment"
    },
    "2810": {
        "file_id": 310,
        "content": "type_to_device_LUT = {}\nlogger_print(device_with_single_port_to_port_type)\nfor index, row in port_df.iterrows():\n    # logger_print(row.tolist())\n    # logger_print(row.tolist())\n    cat, content = row.tolist()[:2]\n    logger_print([cat, content])\n    if not (cat is numpy.nan or cat is None):\n        mycat = cat\n        device_port_dict[mycat] = {}  # init\n    if mycat:\n        if content is numpy.nan or content is None:\n            content_split = True\n        elif content_split:\n            content_split = False\n            mydevice = content.replace(\"（\", \"(\").split(\"(\")[0]\n            device_port_dict[mycat][mydevice] = {}\n        else:\n            # append port?\n            port_type = device_with_single_port_to_port_type.get(mydevice, None)\n            if port_type:\n                device_with_single_port_to_port_type[mydevice] = None\n            else:\n                port_id = f\"{mydevice}-{content}\"\n                port_type = device_with_single_port_to_port_type.get(port_id, None)\n                if port_type:",
        "type": "code",
        "location": "/microgrid_base/type_system.py:335-362"
    },
    "2811": {
        "file_id": 310,
        "content": "This code populates a dictionary called `device_port_dict` based on the rows of `port_df`. It checks if the category (cat) and content columns are not NaN or None. If they aren't, it assigns `mycat`, initializes a nested dictionary for each unique `mycat`, and handles cases where the content column is NaN or None by setting `content_split` accordingly. Finally, it retrieves the port type from `device_with_single_port_to_port_type` and updates the corresponding dictionary entries in `device_port_dict`.",
        "type": "comment"
    },
    "2812": {
        "file_id": 310,
        "content": "                    device_with_single_port_to_port_type[port_id] = None\n            if port_type is not None:\n                device_port_dict[mycat][mydevice][content] = port_type\n                mapped_types.add(port_type)\n                type_to_device_LUT[port_type] = type_to_device_LUT.get(\n                    port_type, []\n                ) + [f\"{mydevice}-{content}\"]\n            else:\n                # logger_print(device_port_dict)\n                # breakpoint()\n                raise Exception(\n                    \"No port type definition for:\", (mycat, mydevice, content)\n                )\ndef print_with_banner(content, hyphen_saved_name, prefix):\n    banner = hyphen_saved_name.strip().replace(\"_\", \" \").upper().strip()\n    logger_print(f\"=========[{banner}]=========\")\n    logger_print(content)\n    filepath = f\"{prefix}_{hyphen_saved_name.strip()}.json\"\n    logger_print(\"SAVING TO:\", filepath)\n    with open(filepath, \"w+\") as f:\n        str_content = json.dumps(content, indent=4, ensure_ascii=False)",
        "type": "code",
        "location": "/microgrid_base/type_system.py:363-386"
    },
    "2813": {
        "file_id": 310,
        "content": "The code maps device ports to their types and updates a LUT. If no port type is defined, it raises an exception with the relevant details. It also defines a function for printing content with a banner and saves it to a JSON file.",
        "type": "comment"
    },
    "2814": {
        "file_id": 310,
        "content": "        f.write(str_content)\n# logger_print(\"=========[DEVICE PORT TYPE MAPPING]=========\")\nprint_with_banner(device_port_dict, \"device_port_type_mapping\", \"microgrid\")\n# logger_print(\"=========[CONNECTIVITY MATRIX]=========\")\ntypes_connectivity_matrix_for_json = {\n    \"{}_{}\".format(*list(k)): v for k, v in types_connectivity_matrix.items()\n}\nprint_with_banner(\n    types_connectivity_matrix_for_json, \"connectivity_matrix\", \"microgrid\"\n)  # must convert this one.\n# logger_print(\"=========[DEVICE PORT TYPES]=========\")\n# print_with_banner(types,'device_port_types',\"microgrid\")\n# logger_print(\"=========[ALL TYPES STRUCTURED]=========\")\nall_types_structured = {\n    \"设备\": {k: list(v) for k, v in types.items()},\n    \"连接线\": {k: list(v) for k, v in wire_types.items()},\n}\nprint_with_banner(all_types_structured, \"all_types_structured\", \"microgrid\")\nmtypes = set([e for k, v in types.items() for e in v])\ndiff_1 = mapped_types.difference(mtypes)\ndiff_2 = mtypes.difference(mapped_types)\nif not (diff_1 == set() and diff_2 == set()):",
        "type": "code",
        "location": "/microgrid_base/type_system.py:387-413"
    },
    "2815": {
        "file_id": 310,
        "content": "This code writes device port type mapping, connectivity matrix, and structured data to a file, then compares the mapped types with the original types. It ensures no differences exist between the two sets before proceeding.",
        "type": "comment"
    },
    "2816": {
        "file_id": 310,
        "content": "    logger_print(\"MAPPED TYPES UNIQ:\", diff_1)\n    logger_print(\"DEVICE TYPES UNIQ:\", diff_2)\n    raise Exception(\"Mapped types does not equal to existing device types\")\n# now the final: validity check!\n# reachable?\nimport networkx\nG = networkx.Graph()\nall_types = mtypes.union(set([e for k, v in wire_types.items() for e in v]))\n# for node_name in all_types:\n#     G.add_node(node_name)\nimport copy\ndef alter_type_name(type_name):\n    logger_print(\"ALTER TYPE NAME:\", type_name)\n    if type_name.startswith(\"不可连接\"):\n        if type_name.endswith(\"]\"):\n            type_name = type_name[:-4]\n        result = copy.copy(type_name) + f\"[{get_uniq_hash()}]\"\n        # breakpoint()\n    else:\n        result = type_name\n    # logger_print(\"RESULT?\", result)\n    # breakpoint()\n    return result\nfor fzset, wire_name in types_connectivity_matrix.items():\n    # logger_print(fzset, wire_name)\n    start, end = list(fzset)\n    start = alter_type_name(start)\n    end = alter_type_name(end)\n    wire_name = alter_type_name(wire_name)\n    G.add_edge(start, wire_name)",
        "type": "code",
        "location": "/microgrid_base/type_system.py:414-454"
    },
    "2817": {
        "file_id": 310,
        "content": "The code is checking the equality between mapped types and existing device types. It creates a graph and modifies some type names to add unique identifiers before adding them to the graph as nodes and edges. The purpose seems to ensure distinct identities for the types within the network. If the mapped types do not match with existing device types, an exception is raised.",
        "type": "comment"
    },
    "2818": {
        "file_id": 310,
        "content": "    G.add_edge(wire_name, end)\n# logger_print(G.nodes)\nfor node_name in G.nodes:\n    neighbors = G.neighbors(node_name)\n    logger_print(\"NODE:\", node_name)\n    logger_print(\"    NEIGHBOR:\", [n for n in neighbors])\n# import matplotlib.font_manager as fm\n# font_path = \"/Volumes/CaseSensitive/pyjom/tests/render_and_recognize_long_text_to_filter_unwanted_characters/get_and_merge_fonts/GoNotoCurrent.ttf\"\n# font_path = \"/Users/jamesbrown/Desktop/works/jubilant-adventure/GoNotoCurrent.ttf\"\n# WRYH = fm.FontProperties(fname = '/Users/liuhuanshuo/Desktop/可视化图鉴/font/WeiRuanYaHei-1.ttf')\nimport matplotlib\nmatplotlib.rcParams[\"font.sans-serif\"] = [\"Songti SC\"]\nimport matplotlib.pyplot as plt\ndef plot_graph(G, figure_path: str, width=10, height=20, plot_only=False):\n    plt.figure(figsize=(width, height))\n    draw_options = {\n        \"node_color\": \"yellow\",\n        \"node_size\": 0,\n        \"font_color\": \"red\",\n        \"edge_color\": \"blue\",\n        # \"fontproperties\":WRYH\n    }\n    networkx.draw_kamada_kawai(G, with_labels=True, font_weight=\"bold\", **draw_options)",
        "type": "code",
        "location": "/microgrid_base/type_system.py:455-488"
    },
    "2819": {
        "file_id": 310,
        "content": "This code is defining a function `plot_graph` that takes a graph (G) as input and creates a visual representation of the graph using Matplotlib. The graph nodes will be colored yellow, edges blue, and font color red. The font will use the \"Songti SC\" font. The size of the figure is adjustable by setting the `width` and `height` parameters. The function also saves the plot as a figure in the specified file path (`figure_path`) if `plot_only=False`, otherwise it only plots the graph without saving it.",
        "type": "comment"
    },
    "2820": {
        "file_id": 310,
        "content": "    logger_print(\"Saving graph figure to:\", figure_path)\n    plt.savefig(figure_path)\n    if not plot_only:\n        plt.show()\nfigure_path = \"type_system.png\"\nplot_graph(G, figure_path, plot_only=PLOT_ONLY)\nG1 = networkx.Graph()\ndef lookup_type_to_device(type_name):\n    result = [e.split(\"-\") for e in type_to_device_LUT.get(type_name, [])]\n    if result == []:\n        return [(None, type_name)]\n    return result\nfor fzset, wire_name in types_connectivity_matrix.items():\n    # logger_print(fzset, wire_name)\n    start, end = list(fzset)\n    for ds, ds_port in lookup_type_to_device(start):\n        for de, de_port in lookup_type_to_device(end):\n            if ds:\n                mstart = ds\n            else:\n                mstart = ds_port\n            if de:\n                mend = de\n            else:\n                mend = de_port\n            mstart = alter_type_name(mstart)\n            mend = alter_type_name(mend)\n            wire_name = alter_type_name(wire_name)\n            G1.add_edge(mstart, wire_name)\n            G1.add_edge(mend, wire_name)",
        "type": "code",
        "location": "/microgrid_base/type_system.py:490-529"
    },
    "2821": {
        "file_id": 310,
        "content": "This code saves a graph figure and then creates a networkx Graph object. It defines a function to lookup device types based on type names, iterates over connectivity matrix, looks up device types for start and end nodes, adds edges to the graph G1 with altered type names, and finally adds an edge between modified start and end nodes and the wire name.",
        "type": "comment"
    },
    "2822": {
        "file_id": 310,
        "content": "figure_path = \"device_connectivity_matrix.png\"\nplot_graph(G1, figure_path, plot_only=PLOT_ONLY)",
        "type": "code",
        "location": "/microgrid_base/type_system.py:531-532"
    },
    "2823": {
        "file_id": 310,
        "content": "This code generates a device connectivity matrix graph and saves it as \"device_connectivity_matrix.png\" using the plot_graph function, with optional plotting restrictions specified by PLOT_ONLY parameter.",
        "type": "comment"
    },
    "2824": {
        "file_id": 311,
        "content": "/microgrid_base/type_system_v2.py",
        "type": "filepath"
    },
    "2825": {
        "file_id": 311,
        "content": "The code creates a microgrid system, handles configurations and special cases, updates connectivity matrices, manages device parameters, generates and visualizes a device-connectivity graph.",
        "type": "summary"
    },
    "2826": {
        "file_id": 311,
        "content": "from log_utils import logger_print\n__doc__ = \"\"\"Creating IES topology type system.\nUsage:\n    type_system_v2.py [(-p | --plot_only) | --version]\nOptions:\n    -p --plot_only        Only save the plot picture without showing it.\n    --version             Showing version.\n\"\"\"\nimport rich\ndef generate_filename(hyphen_saved_name, prefix):\n    # banner = hyphen_saved_name.strip().replace(\"_\", \" \").upper().strip()\n    filepath = f\"{prefix}_{hyphen_saved_name.strip()}.json\"\n    return filepath\nSAVE_PREFIX = \"microgrid_v2\"\nfigure_path = \"type_system.png\"\nMAKEFILE = dict(\n    inputs=[],\n    outputs=[\n        figure_path,\n        j1 := generate_filename(\"device_port_type_mapping\", SAVE_PREFIX),\n        j2 := generate_filename(\"connectivity_matrix\", SAVE_PREFIX),\n        j3 := generate_filename(\"all_types_structured\", SAVE_PREFIX),\n    ],\n    args=[\"-p\"],\n)\n# 风力、光伏、柴油机 增加不可连接的线 删除变流器节点的不可连接线\n# 增加变流器和不可连接母线的连接\nimport traceback\nimport docopt\nfrom docopt import docopt\n# logger_print(type(__doc__))\n# breakpoint()\noptions = docopt(__doc__, version=\"2.0\")",
        "type": "code",
        "location": "/microgrid_base/type_system_v2.py:1-47"
    },
    "2827": {
        "file_id": 311,
        "content": "Creates an IES topology type system with options to plot and save the result. The code uses a version of 2.0 and generates JSON files for device port type mapping, connectivity matrix, and all types structured. It also includes the ability to only save the plot without displaying it, and a Makefile-like structure for specifying inputs and outputs.",
        "type": "comment"
    },
    "2828": {
        "file_id": 311,
        "content": "# from turtle import backward\n# import pandas\nPLOT_ONLY = options.get(\"--plot_only\", False)\n# breakpoint()\ndef check_valid_type_base_name(type_base_name):\n    type_base_name = type_base_name.replace(\" \", \"\").strip()\n    try:\n        assert not type_base_name.startswith(\"可连接\")\n        assert not type_base_name.startswith(\"不可连接\")\n        assert \"输\" not in type_base_name\n        assert \"出\" not in type_base_name\n        assert \"入\" not in type_base_name\n    except:\n        traceback.print_exc()\n        raise Exception(\"Invalid type base name:\", type_base_name)\n    return type_base_name.strip()\nclass PrefixSuffixBase:\n    def __init__(self, prefix_or_suffix, prefix=False):\n        self.prefix_or_suffix = prefix_or_suffix.strip()\n        self.is_prefix = prefix\n    def __call__(self, name):\n        if not self.is_prefix:\n            name = check_valid_type_base_name(name)\n        else:\n            name = name.strip()\n        if self.is_prefix:\n            return f\"{self.prefix_or_suffix}{name}\"\n        else:\n            return f\"{name}{self.prefix_or_suffix}\"",
        "type": "code",
        "location": "/microgrid_base/type_system_v2.py:48-81"
    },
    "2829": {
        "file_id": 311,
        "content": "This code defines a function check_valid_type_base_name() to validate type base names and a class PrefixSuffixBase() to prefix/suffix type names. The function removes spaces and asserts certain conditions on the type base name, while the class applies prefix or suffix based on user-defined input.",
        "type": "comment"
    },
    "2830": {
        "file_id": 311,
        "content": "    def check(self, name_with_prefix_or_suffix):\n        l = len(self.prefix_or_suffix)\n        if self.is_prefix:\n            name = name_with_prefix_or_suffix.strip()[l:]\n        else:\n            name = name_with_prefix_or_suffix.strip()[:-l]\n        sl = set(list(self.prefix_or_suffix))\n        # sl = set(list(name_with_prefix_or_suffix))\n        sld = {e: self.prefix_or_suffix.count(e) for e in sl}\n        nwd = {e: name_with_prefix_or_suffix.count(e) for e in sl}\n        nd = {e: name.count(e) for e in sl}\n        zd = {e: 0 for e in sl}\n        s1 = nd == zd\n        s2 = sld == nwd\n        # logger_print(s1, s2)\n        # breakpoint()\n        return s1 and s2\nclass Prefix(PrefixSuffixBase):\n    def __init__(self, prefix):\n        super().__init__(prefix, prefix=True)\nclass Suffix(PrefixSuffixBase):\n    def __init__(self, suffix):\n        super().__init__(suffix, prefix=False)\n# s0 = Prefix(\"s\")\n# d = \"s1000\"\n# s0.check(d)\n# breakpoint()\n# 元件不可和自己相连 加法器之间如果相连 连线为特殊类型 合并为一个加法器之后做合理性判断\n# 加法器不连接元件 端口属性重置为空\n# 区分设备端口和连接线 端口是点 连接线是边",
        "type": "code",
        "location": "/microgrid_base/type_system_v2.py:83-124"
    },
    "2831": {
        "file_id": 311,
        "content": "This code defines two classes, `Prefix` and `Suffix`, which inherit from the base class `PrefixSuffixBase`. The `check` function is used to determine if a given name with prefix or suffix follows certain rules. It checks if the prefix or suffix is present in the input name and counts the number of occurrences. The code also mentions that components cannot connect to themselves, and connections between adders should be treated as special types. Additionally, adders should not connect to components, and component port properties are reset to empty if connected to an adder. Lastly, the code distinguishes between device ports and connection lines, with ports being points and connection lines being edges.",
        "type": "comment"
    },
    "2832": {
        "file_id": 311,
        "content": "# 给所有不可连接线增加随机hash值 方便观察\nimport uuid\nhash_set = set()\ndef get_uniq_hash(hash_length=3):\n    while True:\n        mhash = str(uuid.uuid4()).split(\"-\")[0][:hash_length]\n        if mhash not in hash_set:\n            hash_set.add(mhash)\n            return mhash\noutput_path = \"microgrid_type_system.xlsx\"\nsheet1_name = \"类型连接矩阵\"\nsheet2_name = \"设备端口类型表\"\n# 母线输入 = 0\n# 母线输出 = 0\n# 储能端输入输出 = 1\n# 双向变流器输入输出 = 1\n# 可连接母线 = 2\n# 不可连接母线 = 2\n# 可连接供电端母线 = 3\n# 不可连接供电端母线 = 3\n# 可连接储能端母线 = 4\n# 不可连接储能端母线 = 4\n# 供电端输出,变流器输入 = 0\ndef revert_dict(mdict: dict):\n    result = {e: k for k, v in mdict.items() for e in v}\n    return result\nInput = Suffix(\"输入\")\nOutput = Suffix(\"输出\")\nIO = Suffix(\"输入输出\")\nsource_coax_triplets = {  # Input, Output, ConnectionBaseName\n    \"电\": [(\"变流器\", \"供电端\", \"供电端母线\")],\n}\nsource_and_load_coax_triplets = {\n    \"电\": [(\"电母线\", \"电母线\", \"电母线\")],\n}\nload_coax_triplets = {  # Input, Output, ConnectionBaseName\n    \"电\": [\n        (\"负荷电\", \"变压器\", \"负荷电母线\"),\n    ],\n    \"柴油\": [\n        (\"柴油\", \"柴油\", \"柴油母线\"),\n    ],\n}\n# IO_1, IO_2, ConnectionBaseName\nio_storage_coax_triplets = {\"电\": [(\"电储能端\", \"双向变流器储能端\", \"电储能端母线\")]}",
        "type": "code",
        "location": "/microgrid_base/type_system_v2.py:125-190"
    },
    "2833": {
        "file_id": 311,
        "content": "This code includes various dictionary structures that define the connections between different components in a microgrid system. It also includes functions for generating unique hash values and reversing dictionaries. The code uses UUIDs to create random but unique hashes for non-connectable lines, which can be useful for identifying specific elements during debugging or analysis. The primary purpose of this code is to define the connections and types of different components in a microgrid system, such as sources, loads, storage, and switches.",
        "type": "comment"
    },
    "2834": {
        "file_id": 311,
        "content": "#\nio_to_wire = {\"电\": [(\"双向变流器线路端\", \"电母线\")]}\ntypes = {}  # {str: set()}\nwire_types = {}\ntypes_connectivity_matrix = {}  # {frozenset([start, end]): generated_type}\ndef triplets_with_supertype(triplet_map, length=3):\n    for supertype, triplet_list in triplet_map.items():\n        for triplet in triplet_list:\n            try:\n                assert len(triplet) == length\n            except:\n                logger_print()\n                logger_print(\"ERROR!\")\n                logger_print()\n                logger_print(triplet_map)\n                raise Exception(\n                    f\"Error when unpacking triplet map with length {length}.\",\n                )\n            yield (*triplet, supertype)\ndef get_types(is_wire):\n    if is_wire:\n        return wire_types\n    else:\n        return types\ndef get_other_sets(supertype, is_wire=False):\n    mtypes = get_types(is_wire)\n    other_sets = set([e for k in mtypes.keys() if k != supertype for e in types[k]])\n    return other_sets\ndef add_to_types(supertype, typename, is_wire=False):",
        "type": "code",
        "location": "/microgrid_base/type_system_v2.py:192-231"
    },
    "2835": {
        "file_id": 311,
        "content": "Function `triplets_with_supertype` generates all triplet combinations with a supertype from the given triplet map.\nFunction `get_types` returns either 'types' or 'wire\\_types' based on the boolean input 'is\\_wire'.\nFunction `get_other_sets` retrieves other sets for the given supertype from the specified types dictionary.\nFunction `add_to_types` adds a new type to the dictionary with the given supertype and typename.",
        "type": "comment"
    },
    "2836": {
        "file_id": 311,
        "content": "    mtypes = get_types(is_wire)\n    if mtypes.get(supertype, None) is None:\n        mtypes[supertype] = set()\n    if is_wire:\n        other_sets = set([e for k, v in types.items() for e in v])\n        wire_other_sets = get_other_sets(supertype, is_wire=is_wire)\n    else:\n        other_sets = get_other_sets(supertype)\n        wire_other_sets = set([e for k, v in wire_types.items() for e in v])\n    if typename not in other_sets:\n        if typename not in wire_other_sets:\n            mtypes[supertype].add(typename)\n        else:\n            raise Exception(\n                f\"{'Wire ' if is_wire else ''}Type {typename} in category {supertype} appeared to be duplicated with wire types.\"\n            )\n    else:\n        raise Exception(\n            f\"{'Wire ' if is_wire else ''}Type {typename} in category {supertype} appeared to be duplicated with device types.\"\n        )\nConnectable = Prefix(\"可连接\")\nMergeable = Prefix(\"可合并\")\nUnconnectable = Prefix(\"不可连接\")\n# handle io to adder stuff.\nfor io, wire_name, supertype in triplets_with_supertype(io_to_wire, length=2):",
        "type": "code",
        "location": "/microgrid_base/type_system_v2.py:232-262"
    },
    "2837": {
        "file_id": 311,
        "content": "Code is retrieving type information for either wire or non-wire components and handling potential duplicates by raising exceptions. It also defines prefixes for connectable, mergeable, unconnectable types and handles input/output (io) to adder connections.",
        "type": "comment"
    },
    "2838": {
        "file_id": 311,
        "content": "    start = IO(io)\n    end = Connectable(wire_name)\n    created = Unconnectable(IO(wire_name))\n    add_to_types(supertype, start)\n    add_to_types(supertype, end, is_wire=True)\n    add_to_types(supertype, created, is_wire=True)\n    types_connectivity_matrix.update({frozenset([start, end]): created})\n# a = [(e, True) for e in triplets_with_supertype(io_coax_triplets)]\n# logger_print(a)\n# breakpoint()\ndef transform_triplets(triplets, is_io, forward, backward):\n    return [(e, is_io, forward, backward) for e in triplets_with_supertype(triplets)]\n# forward&backward for compatibility issues. just leave it be.\nfrom functools import reduce\ntriplets_config = [  # triplets, is_io, forward, backward\n    (source_coax_triplets, False, False, True),\n    (load_coax_triplets, False, True, False),\n    (source_and_load_coax_triplets, False, True, True),\n    #############################################\n    (io_storage_coax_triplets, True, True, False),\n]\nfor (i, o, wire_name, supertype), is_io, forward, backward in reduce(\n    lambda x, y: x + y,",
        "type": "code",
        "location": "/microgrid_base/type_system_v2.py:263-295"
    },
    "2839": {
        "file_id": 311,
        "content": "This code seems to be involved in handling microgrid triplets with different types of configurations, including IO (input/output) and wire connections. It uses transform_triplets function to iterate through the triplets with specific supertype, and add them to the types_connectivity_matrix. The triplets_config list defines various types of triplet configurations, including source_coax_triplets, load_coax_triplets, source_and_load_coax_triplets, and io_storage_coax_triplets. It appears to be related to managing microgrid connectivity in a complex system with multiple components and connections.",
        "type": "comment"
    },
    "2840": {
        "file_id": 311,
        "content": "    [transform_triplets(*c) for c in triplets_config],\n):\n    if is_io:\n        start = IO(i)\n        end = IO(o)\n    else:\n        start = Input(i)  # input <- adder_output <- adder\n        end = Output(o)  # output -> adder_input -> adder\n    # logger_print(i,o, start, end,wire_name)\n    # breakpoint()\n    mWireNames = (\n        connectable_wire_name,\n        unconnectable_wire_name,\n        unconnectable_input_wire_name,\n        unconnectable_output_wire_name,\n        unconnectable_io_wire_name,\n        mergeable_wire_name,\n    ) = (\n        Connectable(wire_name),\n        Unconnectable(wire_name),\n        Unconnectable(Input(wire_name)),\n        Unconnectable(Output(wire_name)),\n        Unconnectable(IO(wire_name)),\n        Mergeable(wire_name),\n    )\n    # if types.get(supertype, None) is None:\n    #     types[supertype] = set()\n    # other_sets = set([e for k in types.keys() if k!=supertype for e in types[k]])\n    # if \"储能端\" in start:\n    #     breakpoint()\n    add_to_types(supertype, start)\n    add_to_types(supertype, end)",
        "type": "code",
        "location": "/microgrid_base/type_system_v2.py:296-328"
    },
    "2841": {
        "file_id": 311,
        "content": "This code defines a set of connectable types for wires and adds them to the \"types\" dictionary. It creates different wire names based on their connectability and assigns them to specific variables. The code also checks if a supertype exists, adds it to the \"types\" dictionary, and handles special cases involving energy ends.",
        "type": "comment"
    },
    "2842": {
        "file_id": 311,
        "content": "    for wireName in mWireNames:\n        add_to_types(supertype, wireName, is_wire=True)\n    # add_to_types(supertype, connectable_wire_name, is_wire=True)\n    # add_to_types(supertype, unconnectable_wire_name, is_wire=True)\n    # add_to_types(supertype, unconnectable_input_wire_name, is_wire=True)\n    # add_to_types(supertype, unconnectable_output_wire_name, is_wire=True)\n    # add_to_types(supertype, unconnectable_wire_name, is_wire=True)\n    types_connectivity_matrix.update({frozenset([start, end]): unconnectable_wire_name})\n    types_connectivity_matrix.update(\n        {frozenset([connectable_wire_name, connectable_wire_name]): mergeable_wire_name}\n    )\n    # if forward:  # original\n    types_connectivity_matrix.update(\n        {frozenset([start, connectable_wire_name]): unconnectable_output_wire_name}\n    )\n    # if backward:\n    types_connectivity_matrix.update(\n        {frozenset([end, connectable_wire_name]): unconnectable_input_wire_name}\n    )\n# logger_print(types)\n# {\n#     '母线输入',\n#     '不可连接母线',",
        "type": "code",
        "location": "/microgrid_base/type_system_v2.py:330-357"
    },
    "2843": {
        "file_id": 311,
        "content": "The code iterates over a list of wire names and adds them as wires to the type system. It then updates a connectivity matrix based on the specific wire connections, including unconnectable, connectable, and mergeable wires in various orientations (forward or backward). The code also handles updating the connectivity matrix with unconnectable input/output wires, and connectable wires.",
        "type": "comment"
    },
    "2844": {
        "file_id": 311,
        "content": "#     '可连接储能端母线',\n#     '不可连接供电端母线',\n#     '母线输出',\n#     '供电端输出',\n#     '不可连接储能端母线',\n#     '双向变流器输入输出',\n#     '可连接供电端母线',\n#     '储能端输入输出',\n#     '可连接母线',\n#     '变流器输入'\n# }\nimport json\n# keys = []\n# with open(\"microgrid_device_params_intermediate.json\",'r') as f:\n#     data = json.load(f)\n#     for k,v in data.items():\n#         for k0, v0 in v.items():\n#             keys.append(k0)\n# logger_print(keys)\ncsv_path = \"设备接口-离网型微电网.csv\"\nfrom csv_utils import fix_csv_and_return_dataframe\nport_df = fix_csv_and_return_dataframe(csv_path)\n# lines = []\n# line_sep_count_list = []\n# with open(csv_path, \"r\") as f:\n#     for line in f.readlines():\n#         line_sep_count = line.count(\",\")\n#         if line_sep_count == 0:\n#             continue\n#         lines.append(line)\n#         line_sep_count_list.append(line_sep_count)\n# line_sep_count_max = max(line_sep_count_list)\n# for index, line_sep_count in enumerate(line_sep_count_list):\n#     lines[index] = lines[index].strip() + \",\" * (line_sep_count_max - line_sep_count)\n# with open(csv_path, \"w+\") as f:",
        "type": "code",
        "location": "/microgrid_base/type_system_v2.py:358-399"
    },
    "2845": {
        "file_id": 311,
        "content": "The code is reading a JSON file, extracting keys, and then opening a CSV file. It counts the number of comma-separated values in each line of the CSV and adjusts them to have the same number as the longest line. The purpose seems to be related to microgrid device parameters, possibly for interface data or configuration.",
        "type": "comment"
    },
    "2846": {
        "file_id": 311,
        "content": "#     for line in lines:\n#         f.write(line + \"\\n\")\n# port_df = pandas.read_csv(csv_path, header=None, on_bad_lines=\"warn\")\n# logger_print(port_df)\nimport numpy\nmycat = None\ndevice_port_dict = {}\nmydevice = None\ncontent_split = True\n# 能源端\noutput_device_with_single_port_to_port_type = revert_dict(\n    {\n        \"柴油\": [\"柴油\"],\n        \"供电端\": [\"光伏发电\", \"风力发电\", \"柴油发电-电接口\"],\n        \"电母线\": [\"变流器-电输出\", \"传输线-电输出\"],\n        \"变压器\": [\"变压器-电输出\"],\n    }\n)\n# 负荷端\ninput_device_with_single_port_to_port_type = revert_dict(\n    {\n        \"负荷电\": [\"电负荷\"],\n        \"柴油\": [\"柴油发电-燃料接口\"],\n        \"电母线\": [\"变压器-电输入\", \"传输线-电输入\"],\n        \"变流器\": [\"变流器-电输入\"],\n    }\n)\n# 储能端\nio_device_with_single_port_to_port_type = revert_dict(\n    {\"电储能端\": [\"锂电池\"], \"双向变流器储能端\": [\"双向变流器-储能端\"], \"双向变流器线路端\": [\"双向变流器-线路端\"]}\n)\ndevice_with_single_port_to_port_type = {\n    k: Input(v) for k, v in input_device_with_single_port_to_port_type.items()\n}\ndevice_with_single_port_to_port_type.update(\n    {k: Output(v) for k, v in output_device_with_single_port_to_port_type.items()}",
        "type": "code",
        "location": "/microgrid_base/type_system_v2.py:400-444"
    },
    "2847": {
        "file_id": 311,
        "content": "This code defines dictionaries for energy, load, and storage devices with their single port types. It then creates a device_with_single_port_to_port_type dictionary combining input and output device types.",
        "type": "comment"
    },
    "2848": {
        "file_id": 311,
        "content": ")\ndevice_with_single_port_to_port_type.update(\n    {k: IO(v) for k, v in io_device_with_single_port_to_port_type.items()}\n)\nmapped_types = set()\ntype_to_device_LUT = {}\nlogger_print(device_with_single_port_to_port_type)\nfor index, row in port_df.iterrows():\n    # logger_print(row.tolist())\n    # logger_print(row.tolist())\n    cat, content = row.tolist()[:2]\n    logger_print([cat, content])\n    if not (cat is numpy.nan or cat is None):\n        mycat = cat\n        device_port_dict[mycat] = {}  # init\n    if mycat:\n        if content is numpy.nan or content is None:\n            content_split = True\n        elif content_split:\n            content_split = False\n            mydevice = content.replace(\"（\", \"(\").split(\"(\")[0]\n            device_port_dict[mycat][mydevice] = {}\n        else:\n            # append port?\n            port_type = device_with_single_port_to_port_type.get(mydevice, None)\n            if port_type:\n                device_with_single_port_to_port_type[mydevice] = None\n            else:\n                port_id = f\"{mydevice}-{content}\"",
        "type": "code",
        "location": "/microgrid_base/type_system_v2.py:445-478"
    },
    "2849": {
        "file_id": 311,
        "content": "Updates device_with_single_port_to_port_type, maps types to devices in a set and dictionary, prints logger for the updated type to port mapping, iterates through each row of port_df, handles NaN or None values, assigns categories and content from rows, checks for existing data and appends ports accordingly, gets device type and ID, and updates device_with_single_port_to_port_type with new information.",
        "type": "comment"
    },
    "2850": {
        "file_id": 311,
        "content": "                port_type = device_with_single_port_to_port_type.get(port_id, None)\n                if port_type:\n                    device_with_single_port_to_port_type[port_id] = None\n            if port_type is not None:\n                device_port_dict[mycat][mydevice][content] = port_type\n                mapped_types.add(port_type)\n                type_to_device_LUT[port_type] = type_to_device_LUT.get(\n                    port_type, []\n                ) + [f\"{mydevice}-{content}\"]\n            else:\n                # logger_print(device_port_dict)\n                # breakpoint()\n                raise Exception(\n                    \"No port type definition for:\", (mycat, mydevice, content)\n                )\ndef print_with_banner(content, filepath):\n    # def print_with_banner(content, hyphen_saved_name, prefix):\n    # banner = hyphen_saved_name.strip().replace(\"_\", \" \").upper().strip()\n    logger_print(content)\n    # filepath = f\"{prefix}_{hyphen_saved_name.strip()}.json\"\n    logger_print(\"SAVING TO:\", filepath)",
        "type": "code",
        "location": "/microgrid_base/type_system_v2.py:479-502"
    },
    "2851": {
        "file_id": 311,
        "content": "This code checks the port type for a given device and content, adds it to a dictionary if found, and raises an exception if not found. It also updates a LUT with the corresponding device information. The print_with_banner function logs a message and saves it to a file.",
        "type": "comment"
    },
    "2852": {
        "file_id": 311,
        "content": "    logger_print(f\"=========[{filepath}]=========\")\n    with open(filepath, \"w+\") as f:\n        str_content = json.dumps(content, indent=4, ensure_ascii=False)\n        f.write(str_content)\n# logger_print(\"=========[DEVICE PORT TYPE MAPPING]=========\")\nprint_with_banner(device_port_dict, j1)\n# logger_print(\"=========[CONNECTIVITY MATRIX]=========\")\nlogger_print(types_connectivity_matrix)\ndef exp_froz(frz):\n    lf = list(frz)\n    if len(lf) == 1:\n        lf = lf + lf\n    return lf\ntypes_connectivity_matrix_for_json = {\n    \"{}_{}\".format(*exp_froz(k)): v for k, v in types_connectivity_matrix.items()\n}\nprint_with_banner(types_connectivity_matrix_for_json, j2)  # must convert this one.\n# logger_print(\"=========[DEVICE PORT TYPES]=========\")\n# print_with_banner(types,'device_port_types',\"microgrid\")\n# logger_print(\"=========[ALL TYPES STRUCTURED]=========\")\nwire_types_json = {k: list(v) for k, v in wire_types.items()}\n# logger_print(wire_types_json)\n# breakpoint()\nall_types_structured = {\n    \"设备\": {k: list(v) for k, v in types.items()},",
        "type": "code",
        "location": "/microgrid_base/type_system_v2.py:503-535"
    },
    "2853": {
        "file_id": 311,
        "content": "This code segment is responsible for:\n1. Printing a banner for a file path and writing the content to the file.\n2. Defining a function, `exp_froz`, which takes a frozen set and converts it into a list.\n3. Generating a dictionary, `types_connectivity_matrix_for_json`, with elements from `types_connectivity_matrix` reorganized for JSON output.\n4. Printing a banner for `types_connectivity_matrix_for_json`.\n5. Converting the `wire_types` dictionary into a list of values per key, stored in `wire_types_json`.\n6. Creating a structured representation of all types under the '设备' category in `all_types_structured`.",
        "type": "comment"
    },
    "2854": {
        "file_id": 311,
        "content": "    # 加法器改为母线\n    \"母线\": {k: [e for e in v if Connectable.check(e)] for k, v in wire_types.items()},\n    \"连接线\": {k: [e for e in v if Unconnectable.check(e)] for k, v in wire_types.items()},\n    \"合并线\": {k: [e for e in v if Mergeable.check(e)] for k, v in wire_types.items()},\n}\n# all_types_structured = {\"设备\":{k: list(v) for k,v in types.items()},\"连接线\":{k:list(v) for k,v in wire_types.items()}}\nprint_with_banner(all_types_structured, j3)\nmtypes = set([e for k, v in types.items() for e in v])\ndiff_1 = mapped_types.difference(mtypes)\ndiff_2 = mtypes.difference(mapped_types)\nif not (diff_1 == set() and diff_2 == set()):\n    logger_print(\"MAPPED TYPES UNIQ:\", diff_1)\n    logger_print(\"DEVICE TYPES UNIQ:\", diff_2)\n    raise Exception(\"Mapped types does not equal to existing device types\")\n# now the final: validity check!\n# reachable?\nimport networkx\nG = networkx.Graph()\nall_types = mtypes.union(set([e for k, v in wire_types.items() for e in v]))\n# for node_name in all_types:\n#     G.add_node(node_name)\nimport copy\ndef alter_type_name(type_name):",
        "type": "code",
        "location": "/microgrid_base/type_system_v2.py:536-569"
    },
    "2855": {
        "file_id": 311,
        "content": "This code is checking the types of devices and connections in a microgrid system. It filters them based on specific criteria and creates a dictionary for each type (mother lines, connection lines, merging lines). The code then checks if there are any unique types between the mapped and device types and raises an exception if they are not equal. Finally, it constructs a graph to check reachability of all types in the system.",
        "type": "comment"
    },
    "2856": {
        "file_id": 311,
        "content": "    logger_print(\"ALTER TYPE NAME:\", type_name)\n    if type_name.startswith(\"不可连接\"):\n        if type_name.endswith(\"]\"):\n            type_name = type_name[:-4]\n        result = copy.copy(type_name) + f\"[{get_uniq_hash()}]\"\n        # breakpoint()\n    else:\n        result = type_name\n    # logger_print(\"RESULT?\", result)\n    # breakpoint()\n    return result\ndef is_wire(name):\n    return Connectable.check(name) or Unconnectable.check(name)\nfor fzset, wire_name in types_connectivity_matrix.items():\n    # logger_print(fzset, wire_name)\n    start, end = exp_froz(fzset)\n    start = alter_type_name(start)\n    end = alter_type_name(end)\n    wire_name = alter_type_name(wire_name)\n    G.add_edge(start, wire_name)\n    G.add_edge(wire_name, end)\n    # G.add_edge(start, end)\n# logger_print(G.nodes)\nfor node_name in G.nodes:\n    neighbors = G.neighbors(node_name)\n    logger_print(\"NODE:\", node_name)\n    logger_print(\"    NEIGHBOR:\", [n for n in neighbors])\n# import matplotlib.font_manager as fm\n# font_path = \"/Volumes/CaseSensi",
        "type": "code",
        "location": "/microgrid_base/type_system_v2.py:570-608"
    },
    "2857": {
        "file_id": 311,
        "content": "This code appears to be involved in the manipulation and addition of nodes and edges to a graph (G) based on a types_connectivity_matrix, potentially for network connectivity analysis. It modifies node names by altering type names if they meet specific conditions, and logs node and neighbor information. The code also utilizes the get_uniq_hash() function and possibly a logger_print function for logging purposes.",
        "type": "comment"
    },
    "2858": {
        "file_id": 311,
        "content": "tive/pyjom/tests/render_and_recognize_long_text_to_filter_unwanted_characters/get_and_merge_fonts/GoNotoCurrent.ttf\"\n# font_path = \"/Users/jamesbrown/Desktop/works/jubilant-adventure/GoNotoCurrent.ttf\"\n# WRYH = fm.FontProperties(fname = '/Users/liuhuanshuo/Desktop/可视化图鉴/font/WeiRuanYaHei-1.ttf')\nimport matplotlib\nmatplotlib.rcParams[\"font.sans-serif\"] = [\"Songti SC\"]\nimport matplotlib.pyplot as plt\ndef plot_graph(G, figure_path: str, width=20, height=30, plot_only=False):\n    plt.figure(figsize=(width, height))\n    draw_options = {\n        \"node_color\": \"yellow\",\n        \"node_size\": 0,\n        \"font_color\": \"red\",\n        \"edge_color\": \"blue\",\n        # \"fontproperties\":WRYH\n    }\n    networkx.draw_kamada_kawai(G, with_labels=True, font_weight=\"bold\", **draw_options)\n    logger_print(\"Saving graph figure to:\", figure_path)\n    plt.savefig(figure_path)\n    if not plot_only:\n        plt.show()\nplot_graph(G, figure_path, plot_only=PLOT_ONLY)\nG1 = networkx.Graph()\ndef lookup_type_to_device(type_name):\n    result = [e.split(\"-\") for e in type_to_device_LUT.get(type_name, [])]",
        "type": "code",
        "location": "/microgrid_base/type_system_v2.py:608-645"
    },
    "2859": {
        "file_id": 311,
        "content": "The code defines a function `plot_graph` that takes a graph G, figure path, width, and height as input. It creates a figure with specified size and draws the graph using NetworkX's draw_kamada_kawai function with custom options for node color, font color, etc. If plot_only is False, it saves the figure to the given filepath and displays it. The code also defines a function `lookup_type_to_device` that returns a list of device names for a given type name based on the type_to_device_LUT dictionary.",
        "type": "comment"
    },
    "2860": {
        "file_id": 311,
        "content": "    if result == []:\n        return [(None, type_name)]\n    return result\nfor fzset, wire_name in types_connectivity_matrix.items():\n    # logger_print(fzset, wire_name)\n    start, end = exp_froz(fzset)\n    for ds, ds_port in lookup_type_to_device(start):\n        for de, de_port in lookup_type_to_device(end):\n            if ds:\n                mstart = ds\n            else:\n                mstart = ds_port\n            if de:\n                mend = de\n            else:\n                mend = de_port\n            mstart = alter_type_name(mstart)\n            mend = alter_type_name(mend)\n            wire_name = alter_type_name(wire_name)\n            G1.add_edge(mstart, wire_name)\n            G1.add_edge(mend, wire_name)\nfigure_path = \"device_connectivity_matrix.png\"\nplot_graph(G1, figure_path, plot_only=PLOT_ONLY)",
        "type": "code",
        "location": "/microgrid_base/type_system_v2.py:646-673"
    },
    "2861": {
        "file_id": 311,
        "content": "The code is generating a graph using a connectivity matrix and plotting it. It iterates through the types_connectivity_matrix, identifies start and end devices based on type names, and adds edges to the graph G1 between these devices and the wire name. The plot_graph function then generates a visual representation of this graph and saves it as \"device_connectivity_matrix.png\".",
        "type": "comment"
    },
    "2862": {
        "file_id": 312,
        "content": "/microgrid_base/type_utils.py.j2",
        "type": "filepath"
    },
    "2863": {
        "file_id": 312,
        "content": "The code creates a Prolog environment for a microgrid system, verifies topology statuses and conditions, logs errors, validates using Python scripts, and checks if the program can proceed based on energy types and topology status.",
        "type": "summary"
    },
    "2864": {
        "file_id": 312,
        "content": "from log_utils import logger_print\nfrom type_def import *\nimport os\nfrom constants import UNKNOWN\n{# import parse #}\n\"\"\"static & dynamic topology type checking\"\"\"\ndef logFailedRule(passed:bool, banner:str):\n    if not passed:\n        logger_print(f\"Rule {banner} failed.\")\n    return passed\n{# PORT_NAME_FORMAT = \"{deviceSubtype}_{deviceIndex}_{portName}\" #}\ndef portNameTransformer(port_name):\n    result = port_name.split(\"_\")\n    {# result = parse.parse(PORT_NAME_FORMAT, port_name) #}\n    result_length = len(result)\n    if result_length == 3:\n        transformed_port_name = f\"{result[0]}_{result[2]}\"\n        {# transformed_port_name = f\"{result['deviceSubtype']}_{result['portName']}\" #}\n    else:\n        raise Exception(f'Failed to parse port name \"{port_name}\" (mismatched splited size: {result_length})')\n        {# raise Exception(f'Failed to parse port name \"{port_name}\" with format \"{PORT_NAME_FORMAT}\"') #}\n    return transformed_port_name\ndeviceTypes = {{deviceTypes}}\nenergyTypes = {{energyTypes}}\ndeviceTypeToTypeInfo = {",
        "type": "code",
        "location": "/microgrid_base/type_utils.py.j2:1-31"
    },
    "2865": {
        "file_id": 312,
        "content": "This code is importing functions from other modules and defining a function to check the validity of topology rules. It also includes a method to transform port names according to a specific format and lists of deviceTypes and energyTypes. The code uses string formatting for readability, but it's not clear which parts are placeholders or static values.",
        "type": "comment"
    },
    "2866": {
        "file_id": 312,
        "content": "{% for deviceType, requiredPortFrontendNameToPortPossibleStates,requiredPortFrontendNameToEnergyTypes in deviceTypeTriplets %}\n    {{repr(deviceType)}}: {\n        \"requiredPortFrontendNameToPortPossibleStates\": {{requiredPortFrontendNameToPortPossibleStates}},\n        \"requiredPortFrontendNameToEnergyTypes\": {{requiredPortFrontendNameToEnergyTypes}}\n    },\n{% endfor %}\n}\nport_verifier_lookup_table = {\n{% for k, v in port_verifier_lookup_table.items() %}\n    {{repr(k)}}: {\n    {% for v_k, v_v in v.items() %}\n        {{repr(v_k)}}: {{v_v}},\n    {% endfor %}\n    },\n{% endfor %}\n}\nconjugate_port_verifier_constructor_lookup_table = {\n{% for k, v in conjugate_port_verifier_constructor_lookup_table.items() %}\n    {{repr(k)}}: {{v}},\n{% endfor %}\n}\ndef convert_topo_to_prolog_render_params_and_verification_params(topo):\n    possibleEnergyTypes = set()\n    possibleDeviceTypes = set()\n    portNameToPortPossibleStates = {} #\n    deviceTypeToDeviceNames = {} #\n    deviceNameToPortNames = {} #\n    energyTypeToPortNames = {} #\n    adderNameToAdderPortNames = {} #",
        "type": "code",
        "location": "/microgrid_base/type_utils.py.j2:32-64"
    },
    "2867": {
        "file_id": 312,
        "content": "The code defines lookup tables for port verifier, conjugate port verifier constructor, and creates empty dictionaries to store data for topology conversion. It uses sets and dictionaries to keep track of device types, possible energy types, port states, device names, port names, and adder names.",
        "type": "comment"
    },
    "2868": {
        "file_id": 312,
        "content": "    port_name_lookup_table = {}\n    adders = topo.get_all_adders()\n    adder_index_to_adder_name = {}\n    port_verifiers = {}\n    conjugate_port_verifiers = {} # TODO: parse additional conjugate port verifiers from topo object.\n    for devInfo in topo.get_all_devices():\n        node_id = devInfo['id']\n        node_subtype = devInfo['subtype']\n        possibleDeviceTypes.add(node_subtype)\n        devName = f\"{node_subtype}_{node_id}\"\n        deviceNameToPortNames[devName] = []\n        if node_subtype not in deviceTypeToDeviceNames.keys():\n            deviceTypeToDeviceNames[node_subtype] = []\n        deviceTypeToDeviceNames[node_subtype].append(devName)\n        ports = devInfo['ports']\n        typeInfo = deviceTypeToTypeInfo[node_subtype]\n        requiredPortFrontendNameToPortPossibleStates = typeInfo['requiredPortFrontendNameToPortPossibleStates']\n        requiredPortFrontendNameToEnergyTypes = typeInfo['requiredPortFrontendNameToEnergyTypes']\n        port_kind_to_port_name = {}\n        for port_kind, port_info in ports.items():",
        "type": "code",
        "location": "/microgrid_base/type_utils.py.j2:66-91"
    },
    "2869": {
        "file_id": 312,
        "content": "This code initializes various dictionaries for storing device names, port names, and their properties. It also adds device subtypes to a set of possible device types. The code iterates through the topology's devices and ports, organizing the information into these dictionaries. Conjugate port verifiers are also supposed to be parsed from the topo object in the future.",
        "type": "comment"
    },
    "2870": {
        "file_id": 312,
        "content": "            portPossibleStates = requiredPortFrontendNameToPortPossibleStates[port_kind]\n            portPossibleEnergyTypes = requiredPortFrontendNameToEnergyTypes[port_kind]\n            possibleEnergyTypes.update(portPossibleEnergyTypes)\n            port_name = f\"{devName}_{port_kind}\"\n            port_kind_to_port_name[port_kind] = port_name\n            verifier = port_verifier_lookup_table.get(node_subtype, {}).get(port_kind, None)\n            if verifier:\n                port_verifiers[port_name] = verifier\n            deviceNameToPortNames[devName].append(port_name)\n            port_id = port_info['id']\n            port_name_lookup_table[port_id] = port_name\n            portNameToPortPossibleStates[port_name] = portPossibleStates\n            for energyType in portPossibleEnergyTypes:\n                if energyType not in energyTypeToPortNames.keys():\n                    energyTypeToPortNames[energyType] = []\n                energyTypeToPortNames[energyType].append(port_name)\n        conjugate_ver",
        "type": "code",
        "location": "/microgrid_base/type_utils.py.j2:92-113"
    },
    "2871": {
        "file_id": 312,
        "content": "The code is setting up port information for a microgrid system. It retrieves the possible states and energy types for a given port kind, updates the list of possible energy types, creates a unique name for each port based on its device and type, adds the port verifier if it exists, stores information in lookup tables for quick access, and finally organizes the port names by their associated energy types.",
        "type": "comment"
    },
    "2872": {
        "file_id": 312,
        "content": "ifiers_constructor = conjugate_port_verifier_constructor_lookup_table.get(node_subtype, lambda d: {})\n        conjugate_verifiers = conjugate_verifiers_constructor(port_kind_to_port_name)\n        conjugate_port_verifiers.update(conjugate_verifiers)\n    for adder_index, adder_def in adders.items():\n        index = str(adder_index).replace('-','_')\n        adder_name = f'adder{index}'\n        adder_index_to_adder_name[adder_index] = adder_name\n        port_name_list = []\n        for _, port_index_list in adder_def.items():\n            for port_index in port_index_list:\n                port_name = port_name_lookup_table[port_index]\n                port_name_list.append(port_name)\n        adderNameToAdderPortNames[adder_name] = port_name_list\n    render_params = dict(\n        portNameToPortPossibleStates=portNameToPortPossibleStates,\n        deviceTypes=list(possibleDeviceTypes),\n        deviceTypeToDeviceNames=deviceTypeToDeviceNames,\n        deviceNameToPortNames=deviceNameToPortNames,\n        energyTypes=list(possibleEnergyTypes),",
        "type": "code",
        "location": "/microgrid_base/type_utils.py.j2:113-133"
    },
    "2873": {
        "file_id": 312,
        "content": "The code creates a dictionary of port verifiers, updates with additional conjugate verifiers, adds adder information for index and name lookup, populates an adderNameToAdderPortNames dictionary, and prepares render parameters including port states, device types, device names, and energy types.",
        "type": "comment"
    },
    "2874": {
        "file_id": 312,
        "content": "        energyTypeToPortNames=energyTypeToPortNames,\n        adderNameToAdderPortNames=adderNameToAdderPortNames,\n    )\n    port_index_lookup_table = {v:k for k, v in port_name_lookup_table.items()}\n    adder_name_to_adder_index = {v:k for k, v in adder_index_to_adder_name.items()}\n    adder_index_to_port_name = {}\n    for adderName, adderPortNames in adderNameToAdderPortNames.items():\n        {# adderPortNames #}\n        port_index_to_port_name = {port_index_lookup_table[portName]:portName for portName in adderPortNames}\n        adder_index = adder_name_to_adder_index[adderName]\n        adder_index_to_port_name[adder_index] = port_index_to_port_name\n    verification_params = (adder_index_to_port_name, port_verifiers, conjugate_port_verifiers)\n    return render_params, verification_params\nbasepath = os.path.dirname(__file__)\ntemplate_path = \"prolog_gen.pro.j2\"\ntemplate_abs_path = os.path.join(basepath, template_path)\nos.environ['NO_PYTHON_TYPECHECK'] = 'True'\nfrom jinja_utils import load_template_text\nwith open(template_abs_path, 'r') as f:",
        "type": "code",
        "location": "/microgrid_base/type_utils.py.j2:134-162"
    },
    "2875": {
        "file_id": 312,
        "content": "Code sets up a lookup table for port names and adder indexes based on the provided energy types and adder names. It then generates an absolute path to the template file, sets an environment variable to disable Python type checking, imports a module, opens the template file, and assigns its contents to a variable.",
        "type": "comment"
    },
    "2876": {
        "file_id": 312,
        "content": "    template_content = f.read()\n    template_obj = load_template_text(template_content)\ndef render_prolog_code(render_params):\n    prolog_code = template_obj.render(**render_params)\n    logger_print(\"prolog code:\", prolog_code)\n    return prolog_code\ndef dynamic_verify_topo_object(topo):\n    render_params, verification_params = convert_topo_to_prolog_render_params_and_verification_params(topo)\n    adder_index_to_port_name, port_verifiers, conjugate_port_verifiers = verification_params\n    adderNameToAdderPortNames = render_params[\"adderNameToAdderPortNames\"]\n    if ies_env.USE_PROLOG_CODE:\n        prolog_script_content = render_prolog_code(render_params)\n        can_proceed, isomorphic_topo_status = execute_prolog_script_and_check_if_can_proceed(prolog_script_content, adder_index_to_port_name, port_verifiers, conjugate_port_verifiers, adderNameToAdderPortNames)\n    else:\n        can_proceed, isomorphic_topo_status = execute_python_code_and_check_if_can_proceed(render_params, adder_index_to_port_name, port_verifiers, conjugate_port_verifiers, adderNameToAdderPortNames)",
        "type": "code",
        "location": "/microgrid_base/type_utils.py.j2:163-185"
    },
    "2877": {
        "file_id": 312,
        "content": "This code snippet contains functions for rendering Prolog code and performing dynamic topology verification. The `render_prolog_code` function renders the template Prolog code, while `dynamic_verify_topo_object` converts a topology to render parameters and verification params. If using Prolog code, it executes the script and checks if can proceed; otherwise, it executes Python code. The result is either a can_proceed boolean and isomorphic_topo_status.",
        "type": "comment"
    },
    "2878": {
        "file_id": 312,
        "content": "    return can_proceed, isomorphic_topo_status\n##############################################\nfrom error_utils import ErrorManager\nfrom failsafe_utils import chdir_context\n##############################################\nfrom swiplserver import PrologMQI, PrologThread\nfrom pydantic import BaseModel\nfrom typing import List, Dict\n# from HashableDict.HashableDict import HashDict\nfrom frozendict import frozendict\nimport rich\nimport os\nimport tempfile\nfrom config import ies_env\nbanner = lambda title: logger_print(title.center(60, \"-\"))\n{# PROLOG_STACK_LIMIT = 8 #}\n{# PROLOG_STACK_LIMIT = 4 # in GB #}\nPROLOG_STACK_LIMIT = ies_env.PROLOG_STACK_LIMIT\nPROLOG_SHARED_TABLE_LIMIT = ies_env.PROLOG_SHARED_TABLE_LIMIT\nPROLOG_TABLE_SIZE_LIMIT = ies_env.PROLOG_TABLE_SIZE_LIMIT\ndef query_result_from_prolog(prolog_script_content: str, adder_index_to_port_name, adderNameToAdderPortNames):\n    banner(\"querying\")\n    topology_status_dict = {}\n    with tempfile.TemporaryDirectory() as temp_dir:\n        with chdir_context(temp_dir):\n            prolog_file_path = \"prolog_script.pro\"",
        "type": "code",
        "location": "/microgrid_base/type_utils.py.j2:187-219"
    },
    "2879": {
        "file_id": 312,
        "content": "The code is defining functions for querying a prolog script using the Swipl server, setting table and stack limits from configs, and handling temporary directories. It uses various imports such as `PrologMQI`, `PrologThread` and utilities like `chdir_context` and `tempfile`. The code is part of a larger system that likely involves complex queries using Prolog scripts.",
        "type": "comment"
    },
    "2880": {
        "file_id": 312,
        "content": "            prolog_file_path_abs = os.path.join(prolog_file_path)\n            prolog_path_args = []\n            if PROLOG_STACK_LIMIT is not None:\n                prolog_path_args.append(f\"--stack-limit={PROLOG_STACK_LIMIT}G\")\n            if PROLOG_SHARED_TABLE_LIMIT is not None:\n                prolog_path_args.append(f\"--shared-table-space={PROLOG_SHARED_TABLE_LIMIT}G\")\n            if PROLOG_TABLE_SIZE_LIMIT is not None:\n                prolog_path_args.append(f\"--table-space={PROLOG_TABLE_SIZE_LIMIT}G\")\n            with open(prolog_file_path_abs, \"w+\") as f:\n                f.write(prolog_script_content)\n            with PrologMQI(prolog_path_args = prolog_path_args) as mqi:\n                with mqi.create_thread() as prolog_thread:\n                    topology_status_dict = query_prolog_in_context(\n                        topology_status_dict,\n                        prolog_file_path,\n                        prolog_thread,\n                        adder_index_to_port_name,\n                        adderNameToAdderPortNames",
        "type": "code",
        "location": "/microgrid_base/type_utils.py.j2:220-237"
    },
    "2881": {
        "file_id": 312,
        "content": "This code sets up a Prolog environment by creating a Prolog script file, then initializes a PrologMQI object with optional stack limit, shared table space limit, and table size limit arguments. It opens the script file in write mode, writes the prolog_script_content to it, then creates a Prolog thread using the PrologMQI object. Finally, it calls query_prolog_in_context function passing necessary parameters for execution.",
        "type": "comment"
    },
    "2882": {
        "file_id": 312,
        "content": "                    )\n    return topology_status_dict\ndef construct_query_result_iterator(thread, query):\n    thread.query_async(query, find_all=False)\n    while True:\n        it = thread.query_async_result()\n        if it is not None:\n            yield it\n        else:\n            break\nimport progressbar\nimport hashlib\nimport itertools\ndef get_all_combinations(portNameToPortPossibleStates, energyTypeToPortNames, adderNameToAdderPortNames):\n    port_name_to_possible_energy_types = {}\n    for k,vlist in energyTypeToPortNames.items():\n        for v in vlist:\n            if v not in port_name_to_possible_energy_types.keys():\n                port_name_to_possible_energy_types[v] = [k]\n            port_name_to_possible_energy_types[v].append(k)\n    adder_name_list = list(adderNameToAdderPortNames.keys())\n    possible_simutaneous_adder_energy_types = set()\n    adder_name_to_possible_adder_energy_types = {}\n    for adder_name, _port_name_list in adderNameToAdderPortNames.items():\n        paet = set()\n        for pn in _port_name_list:",
        "type": "code",
        "location": "/microgrid_base/type_utils.py.j2:238-272"
    },
    "2883": {
        "file_id": 312,
        "content": "This code defines a function `get_all_combinations` which takes three inputs: `portNameToPortPossibleStates`, `energyTypeToPortNames`, and `adderNameToAdderPortNames`. It generates all possible combinations of ports and adapters for energy types and returns them. The code also defines some other functions like `construct_query_result_iterator` and utilities such as `progressbar`, `hashlib`, and `itertools`.",
        "type": "comment"
    },
    "2884": {
        "file_id": 312,
        "content": "            {# ets = [et for et in port_name_to_possible_energy_types[pn] if et != UNKNOWN] #}\n            {# if we do that then the energy type will just be undetermined #}\n            {# so we would rather assign all possible energy types to the disjunctive device or the directed line device #}\n            {# and add some exclusive rules for all ports #}\n            {# these devices might not be defined in the excel #}\n            ets = port_name_to_possible_energy_types[pn]\n            paet.update(ets)\n        adder_name_to_possible_adder_energy_types[adder_name] = paet\n    possible_simutaneous_adder_energy_types = []\n    possible_simutaneous_adder_energy_types = list(itertools.product(*adder_name_to_possible_adder_energy_types.values()))\n    result = []\n    # get `possible_adder_energy_types` from prolog?\n    for simutaneous_adder_energy_types in possible_simutaneous_adder_energy_types:\n        simutaneous_state = []\n        # all idle, otherwise at least one input one output\n        aet_to_ps_l = []",
        "type": "code",
        "location": "/microgrid_base/type_utils.py.j2:273-292"
    },
    "2885": {
        "file_id": 312,
        "content": "Code snippet handles possible energy types for ports and adders in a microgrid configuration. It updates port energy type sets, adds exclusive rules for all ports, and generates combinations of possible adder energy types. It also checks if `possible_adder_energy_types` can be retrieved from Prolog.",
        "type": "comment"
    },
    "2886": {
        "file_id": 312,
        "content": "        for adder_index, aet in enumerate(simutaneous_adder_energy_types):\n            sasp = []\n            adder_name = adder_name_list[adder_index]\n            _port_name_list = adderNameToAdderPortNames[adder_name]\n            psl = []\n            for pn in _port_name_list:\n                ppet = port_name_to_possible_energy_types[pn]\n                pps = portNameToPortPossibleStates[pn]\n                if aet in ppet:\n                    ps = pps\n                else:\n                    assert 'idle' in pps\n                    ps = ['idle']\n                psl.append(ps)\n            for elem in itertools.product(*psl):\n                if all([e == 'idle' for e in elem]) or ('input' in elem and 'output' in elem):\n                    sasp.append([aet, elem])\n            aet_to_ps_l.append(sasp)\n        for elem in itertools.product(*aet_to_ps_l):\n            simutaneous_state.append(elem)\n        result.extend(simutaneous_state)\n    return result\n{% macro query_result_mixin()%}\n    adder_name_list, adder_index_mapping = query_init(adder_index_to_port_name)",
        "type": "code",
        "location": "/microgrid_base/type_utils.py.j2:293-318"
    },
    "2887": {
        "file_id": 312,
        "content": "The code iterates through energy types for simultaneous adders, checks the possible states and energy types for each port name, creates a list of valid state combinations for each adder, generates all possible state combinations from these lists, filters out invalid combinations, and appends the final list of combinations to result. The macro defines functions for initializing adder name list and index mapping based on adder index to port name query.",
        "type": "comment"
    },
    "2888": {
        "file_id": 312,
        "content": "{{caller()}}\n    logger_print(\"parsing result\")\n    topology_status_dict = parse_status_list(STATUS_LIST, adder_index_mapping, adder_index_to_port_name, adderNameToAdderPortNames)\n    logger_print('result parsed')\n    return topology_status_dict\n{% endmacro%}\ndef query_result_from_python(render_params, adder_index_to_port_name, adderNameToAdderPortNames):\n{% call query_result_mixin()%}\n    STATUS_LIST = get_all_combinations(render_params['portNameToPortPossibleStates'], render_params['energyTypeToPortNames'], render_params['adderNameToAdderPortNames'])\n{% endcall%}\ndef parse_status_list(STATUS_LIST, adder_index_mapping, adder_index_to_port_name, adderNameToAdderPortNames):\n    topology_status_dict = {}\n    for simutaneous_status in progressbar.progressbar(STATUS_LIST):\n        adder_status_dict = {}\n        port_status_dict = {}\n        for _index, adder_simutaneous_status in enumerate(simutaneous_status):\n            adder_index = adder_index_mapping[_index]\n            adder_name = \"adder{}\".format(str(adder_index).replace('-','_'))",
        "type": "code",
        "location": "/microgrid_base/type_utils.py.j2:320-342"
    },
    "2889": {
        "file_id": 312,
        "content": "This code defines a function `query_result_from_python` that calls `query_result_mixin()` macro and uses another helper function `parse_status_list`. The `query_result_from_python` function retrieves a list of possible status combinations based on input parameters, then the `parse_status_list` function processes these combinations to create a dictionary representing the status of each port in the topology. The code also includes progress bar functionality for tracking progress during processing.",
        "type": "comment"
    },
    "2890": {
        "file_id": 312,
        "content": "            adder_energy_type, adder_port_status = adder_simutaneous_status\n            adder_status_dict[adder_index] = adder_energy_type\n            {# logger_print(f\"adder #{adder_index}\")\n            logger_print(f\"\\tenergy type: {adder_energy_type}\")\n            logger_print(f\"\\tport_status:\") #}\n            port_index_to_port_name = adder_index_to_port_name[adder_index]\n            for _port_index, port_status in enumerate(adder_port_status):\n                port_name = adderNameToAdderPortNames[adder_name][_port_index]\n                {# port_name = port_index_to_port_name[adder_port_index] #}\n                port_status_dict[port_name] = port_status\n                {# logger_print(f\"\\t\\t{port_name}: {port_status}\") #}\n        key = frozendict(adder_status_dict)\n        value = frozendict(port_status_dict)\n        if key not in topology_status_dict.keys():\n            topology_status_dict[key] = set()\n        topology_status_dict[key].add(value)\n        {# logger_print(\"-\" * 60) #}\n    return topology_status_dict",
        "type": "code",
        "location": "/microgrid_base/type_utils.py.j2:343-360"
    },
    "2891": {
        "file_id": 312,
        "content": "This function generates the status dictionary for an adder, logging its energy type and port statuses, then updates a larger topology status dictionary.",
        "type": "comment"
    },
    "2892": {
        "file_id": 312,
        "content": "def query_prolog_common(adder_name_list, prolog_file_path, prolog_thread):\n    adder_names = \", \".join(adder_name_list)\n    logger_print('adder_names: ',adder_names)\n    prolog_thread.query(f'[\"{prolog_file_path}\"].')\n    logger_print(\"retrieving result\")\n    query = f\"adder_port_status_list([{adder_names}], STATUS)\"\n    _iterator = construct_query_result_iterator(prolog_thread, query)\n    STATUS_LIST = []\n    hashset = set()\n    for result in progressbar.progressbar(_iterator):\n        STATUS = result[0][\"STATUS\"]\n        status_hash = hashlib.md5(str(STATUS).encode()).hexdigest()\n        if status_hash not in hashset:\n            hashset.add(status_hash)\n            STATUS_LIST.append(STATUS)\n    return STATUS_LIST\ndef query_init(adder_index_to_port_name):\n    adder_name_list = []\n    adder_index_mapping = {}\n    for i, k in enumerate(adder_index_to_port_name.keys()):\n        adder_name_list.append(\"adder{}\".format(str(k).replace('-','_')))\n        adder_index_mapping[i] = k\n    return adder_name_list, adder_index_mapping",
        "type": "code",
        "location": "/microgrid_base/type_utils.py.j2:362-390"
    },
    "2893": {
        "file_id": 312,
        "content": "The code defines two functions: `query_prolog_common` and `query_init`. The `query_prolog_common` function takes a list of adder names, a Prolog file path, and a Prolog thread. It queries the Prolog database using the provided file path and adder names to retrieve the status of each adder. It then filters and returns the unique statuses in a list. The `query_init` function generates a list of adder names from an index-to-port-name dictionary and creates an index mapping for later reference.",
        "type": "comment"
    },
    "2894": {
        "file_id": 312,
        "content": "def query_prolog_in_context(\n    topology_status_dict, prolog_file_path, prolog_thread, adder_index_to_port_name, adderNameToAdderPortNames\n):\n{% call query_result_mixin()%}\n    STATUS_LIST = query_prolog_common(adder_name_list, prolog_file_path, prolog_thread)\n{% endcall%}\ndef verify_topology_status_dict(\n    topology_status_dict,\n    port_verifiers,\n    conjugate_port_verifiers,\n    adder_index_to_port_name,\n):\n    banner(\"unverified topo status\")\n    logger_print(topology_status_dict)\n    banner(\"verifying\")\n    verified_topology_status_dict = {}\n    cached_conjugate_verifiers = {}\n    cached_port_verifiers = {}\n    for topo_status_index, (adder_status, topo_status) in enumerate(\n        topology_status_dict.items()\n    ):\n        topo_status_frame_flatten = {}\n        port_verified = {}\n        conjugate_port_verified = {}\n        port_name_to_energy_type = {\n            v_v: adder_status[k]\n            for k, v in adder_index_to_port_name.items()\n            for v_k, v_v in v.items()\n        }\n        for topo_status_frame in topo_status:",
        "type": "code",
        "location": "/microgrid_base/type_utils.py.j2:392-428"
    },
    "2895": {
        "file_id": 312,
        "content": "The function `query_prolog_in_context` takes in a dictionary, path to prolog file, thread for querying prolog, and two dictionaries mapping indexes to port names. It returns the list of status values from a common prolog query function. The `verify_topology_status_dict` function prints a banner, logs the unverified topology status dictionary, then verifies each entry in the dictionary by iterating over its items and creating a new verified dictionary. This function utilizes two other dictionaries to map indexes to port names and store cached verifiers for efficiency.",
        "type": "comment"
    },
    "2896": {
        "file_id": 312,
        "content": "            for topo_status_frame_index, (port_name, port_status) in enumerate(\n                topo_status_frame.items()\n            ):\n                # breakpoint()\n                if port_name not in topo_status_frame_flatten.keys():\n                    topo_status_frame_flatten[port_name] = set()\n                _conjugate_verified = True\n                cached_quit = False\n                with ErrorManager(suppress_error=True) as em:\n                    for (\n                        conjugate_ports,\n                        conjugate_verifier,\n                    ) in conjugate_port_verifiers.items():\n                        # if not found, then skip this port or idle?\n                        conds = [\n                            topo_status_frame.get(port_name, UNKNOWN)\n                            for port_name in conjugate_ports\n                        ]\n                        energytypes = [\n                            port_name_to_energy_type.get(port_name, UNKNOWN)\n                            for port_name in conjugate_ports",
        "type": "code",
        "location": "/microgrid_base/type_utils.py.j2:429-449"
    },
    "2897": {
        "file_id": 312,
        "content": "Iterates over a dictionary of port names and their statuses, flattening the resulting data structure as needed. Ensures each port name exists in the flattened dictionary and initializes necessary variables for error management. The code then iterates over pairs of conjugate ports and verifiers, checking conditions for each port to determine if it has been found or is idle.",
        "type": "comment"
    },
    "2898": {
        "file_id": 312,
        "content": "                        ]\n                        cache_key = (tuple([portNameTransformer(cp) for cp in conjugate_ports]), tuple(conds), tuple(energytypes))\n                        {# cache_key = (tuple(conjugate_ports), tuple(conds), tuple(energytypes)) #}\n                        cached = False\n                        if cache_key in cached_conjugate_verifiers.keys():\n                            cached = True\n                            conjugate_verified = cached_conjugate_verifiers[cache_key]\n                        else:\n                            conjugate_verified = conjugate_verifier(*conds, *energytypes)\n                            cached_conjugate_verifiers[cache_key] = conjugate_verified\n                        # conjugate_verified = conjugate_verifier(*conds)\n                        if not conjugate_verified:\n                            if not cached:\n                                em.append('-'*60)\n                                em.append(\n                                    f\"conjugat",
        "type": "code",
        "location": "/microgrid_base/type_utils.py.j2:450-465"
    },
    "2899": {
        "file_id": 312,
        "content": "This code checks if the cache_key of conjugate ports, conditions, and energy types is in the dictionary of cached conjugate verifiers. If it exists, it retrieves the conjugate verification result from the cache; otherwise, it calculates the result using the conjugate verifier function and adds it to the cache for future use.",
        "type": "comment"
    }
}