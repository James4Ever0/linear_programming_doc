{
    "2700": {
        "file_id": 302,
        "content": "# # walk over all connections.\n# conn = 连接线(graph, PV.ports[\"电接口\"], LOAD.ports[\"电接口\"])\n# conn_merge = 合并线(L0, L1)  # what do you do?\ntopo.check_consistency()\n# shall raise error.\n# methods for computing.\ndevs = topo.get_all_devices()\nprint_with_banner(devs, \"设备\")\n# {\n#     'type': '设备',\n#     'subtype': '双向变流器',\n#     'ports': {\n#         '线路端': {'subtype': '双向变流器线路端输入输出', 'id': 18},\n#         '储能端': {'subtype': '双向变流器储能端输入输出', 'id': 19}\n#     }\n# }\n# device, ports, device_data\nadders = topo.get_all_adders()\nprint_with_banner(adders, \"加法器\")\n# input, output, io\n# {\n#     16: {'input': [6], 'output': [9], 'IO': [18]},\n#     14: {'input': [1, 3], 'output': [5], 'IO': []},\n#     -1: {'input': [], 'output': [], 'IO': [19, 13]},\n#     -2: {'input': [8], 'output': [11], 'IO': []}\n# }\n###############\n# dump to dict\n###############\nmdict = topo.to_json()\nmdictList = [mdict]  # 传入API的计算参数\nprint_with_banner(mdict, \"图序列化\")\nwith open(\"template_input.json\", \"w+\") as f:\n    f.write(json.dumps(mdictList, ensure_ascii=False, indent=4))",
        "type": "code",
        "location": "/microgrid_base/test_topo_check.py:243-285"
    },
    "2701": {
        "file_id": 302,
        "content": "Code walks over all connections in the graph and checks for consistency. It retrieves devices, adders, and converts the topology to a JSON format for further use.",
        "type": "comment"
    },
    "2702": {
        "file_id": 302,
        "content": "###############\n# load from dict\n###############\nimport sys\nflag = sys.argv[-1]\nfrom fastapi_celery_functions import calculate_energyflow_graph_base\n# TODO: add test of celery app\nfrom fastapi_datamodel_template import EnergyFlowGraph\n### TEST PARSING ###\n# from filediff.diff import file_diff_compare\nfrom copy import deepcopy\nimport os\n# breakpoint()  # error while reloading params\nEFG = EnergyFlowGraph(\n    mDictList=deepcopy(mdictList), residualEquipmentLife=2\n)  # override default.\nif flag in [\"-f\", \"--full\"]:  # been replaced by celery full test.\n    ret = calculate_energyflow_graph_base(EFG.dict())\n    logger_print(ret)\n    if ret:\n        with open(saved_path := \"test_output_full.json\", \"w+\") as f:\n            f.write(json.dumps(ret, ensure_ascii=False, indent=4))\n        logger_print(f\"dumped to: {saved_path}\")\n# if True: # override to debug.\nelif flag in [\"-p\", \"--partial\"]:\n    from solve_model import solveModelFromCalcParamList, mDictListToCalcParamList\n    mdictList2 = EFG.dict()[\"mDictList\"]\n    # text1 = json.dumps(mdictList[0]['nodes'], indent=4, ensure_ascii=False)",
        "type": "code",
        "location": "/microgrid_base/test_topo_check.py:287-321"
    },
    "2703": {
        "file_id": 302,
        "content": "Loading from dictionary, parsing test, copying mDictList to override default residualEquipmentLife. If flag is \"-f\" or \"--full\", calculate energy flow graph using `calculate_energyflow_graph_base` and store result in \"test_output_full.json\". If flag is \"-p\" or \"--partial\", use `solveModelFromCalcParamList` after modifying mDictList and then dump the modified list.",
        "type": "comment"
    },
    "2704": {
        "file_id": 302,
        "content": "    # text2 = json.dumps(mdictList2[0]['nodes'], indent=4, ensure_ascii=False)\n    # with open(\"input_1.json\", 'w+') as f:\n    #     f.write(text1)\n    # with open(\"input_2.json\", 'w+') as f:\n    #     f.write(text2)\n    # # file_diff_compare(f1, f2, \"diff_result.html\")\n    # # exit()\n    # import difflib\n    # max_width=150\n    # diff_out = \"diff_result.html\"\n    # numlines=0\n    # show_all=False\n    # logger_print(\"WRITE DIFF TO:\",diff_out)\n    # d = difflib.HtmlDiff(wrapcolumn=max_width)\n    # with open(diff_out, 'w', encoding=\"u8\") as f:\n    #     f.write(d.make_file(text1, text2, context=not show_all, numlines=numlines))\n    # exit()\n    ### YOU MAY WANT TO DIFF IT ###\n    calcParamList = mDictListToCalcParamList(mdictList2)\n    resultList = solveModelFromCalcParamList(calcParamList)\n    logger_print(resultList)\n    logger_print(\"RESULT:\", resultList)\n    if resultList:\n        with open(saved_path := \"test_output_partial.json\", \"w+\") as f:\n            f.write(\n                json.dumps(resultList, ensure_ascii=False, indent=4).replace(",
        "type": "code",
        "location": "/microgrid_base/test_topo_check.py:322-352"
    },
    "2705": {
        "file_id": 302,
        "content": "This code compares two JSON files and writes the differences into a third file. It then calculates the result from the second JSON file, logs it, and saves the result in a fourth JSON file if it's not empty.",
        "type": "comment"
    },
    "2706": {
        "file_id": 302,
        "content": "                    \"NaN\", \"nan\"\n                )\n            )\n        logger_print(f\"dumped to: {saved_path}\")\nelif os.path.basename(flag) != os.path.basename(__file__):\n    raise Exception(f\"Invalid command line arguments: {sys.argv}\")\n# may you get infeasible constraints on some row.\n# Row 'c_e_x1988826_' infeasible, all entries at implied bounds.\n# but this row has been transformed by pyomo, which is hard to retrieve.",
        "type": "code",
        "location": "/microgrid_base/test_topo_check.py:353-363"
    },
    "2707": {
        "file_id": 302,
        "content": "The code is checking the topology of a microgrid and dumping data to a file. It raises an exception if invalid command line arguments are given, and logs information about infeasible constraints in the system. The constraints have been transformed by Pyomo, making it difficult to retrieve their original form.",
        "type": "comment"
    },
    "2708": {
        "file_id": 303,
        "content": "/microgrid_base/test_wrapper.py",
        "type": "filepath"
    },
    "2709": {
        "file_id": 303,
        "content": "The code initializes a Celery application and worker process with specific configurations, defining a task function `mfunc` that raises an exception. It ensures the worker operates within defined resource constraints.",
        "type": "summary"
    },
    "2710": {
        "file_id": 303,
        "content": "from log_utils import logger_print\nfrom ies_optim import ModelWrapperContext\nfrom celery.app.task import Task\nTask.__class_getitem__ = classmethod(lambda cls, *args, **kwargs: cls)  # type: ignore[attr-defined]\ndef func():\n    def func2():\n        with ModelWrapperContext(...) as m:\n            raise Exception(\"error\")\n    func2()\n# func()\nfrom celery import Celery\nfrom passwords import redis_password\nfrom typing import Union\nMAIN_NAME = \"test_wrapper\"\napp = Celery(\n    MAIN_NAME,\n    broker=\"amqp://guest@localhost:5672//\",\n    backend=f\"redis://:{redis_password}@localhost:6380\",\n    # backend=f\"redis://:{redis_password}@localhost:6379\",\n)\n@app.task(store_errors_even_if_ignored=True)\ndef mfunc():\n    func()\napp.conf.update(task_track_started=True)\napp.conf.update(worker_send_task_events=True)\nconcurrent_tasks = 3\napp.conf.update(worker_concurrency=concurrent_tasks)\nmemory_limit = 20_000_000  # kB -> 20GB\napp.conf.update(worker_max_memory_per_child=memory_limit)\ntime_limit = 60 * 25  # sec, 25 minutes.\napp.conf.update(worker_time_limit=time_limit)",
        "type": "code",
        "location": "/microgrid_base/test_wrapper.py:1-45"
    },
    "2711": {
        "file_id": 303,
        "content": "This code initializes a Celery application with specific configurations for error handling, worker settings, and task execution. It defines a function `mfunc` as a Celery task that calls another function `func`, which raises an exception.",
        "type": "comment"
    },
    "2712": {
        "file_id": 303,
        "content": "# limits on ram usage, concurrency, execution time\nif __name__ == \"__main__\":\n    worker = app.Worker()\n    worker.start()",
        "type": "code",
        "location": "/microgrid_base/test_wrapper.py:46-50"
    },
    "2713": {
        "file_id": 303,
        "content": "Initializes a worker process with resource constraints and starts it. This ensures the worker operates within defined limits of RAM, concurrency, and execution time.",
        "type": "comment"
    },
    "2714": {
        "file_id": 304,
        "content": "/microgrid_base/test_wrapper_celery.py",
        "type": "filepath"
    },
    "2715": {
        "file_id": 304,
        "content": "This code imports necessary functions and libraries, creates a task using the Celery app, and continuously prints the status of that task indefinitely. It is likely used for monitoring task execution progress or status.",
        "type": "summary"
    },
    "2716": {
        "file_id": 304,
        "content": "from log_utils import logger_print\nfrom test_wrapper import MAIN_NAME, app\nfunction_id = f\"{MAIN_NAME}.mfunc\"\n# from celery.result import AsyncResult\ntask = app.send_task(function_id)\n# installed stub: pip install celery-types\n# task:AsyncResult = app.send_task(function_id)\nimport time\nimport rich\nwhile True:\n    time.sleep(1)\n    logger_print(\"STATUS?\", task.status)\n    # logger_print(dir(task), type(task))\n    logger_print(task.__dict__)",
        "type": "code",
        "location": "/microgrid_base/test_wrapper_celery.py:1-18"
    },
    "2717": {
        "file_id": 304,
        "content": "This code imports necessary functions and libraries, creates a task using the Celery app, and continuously prints the status of that task indefinitely. It is likely used for monitoring task execution progress or status.",
        "type": "comment"
    },
    "2718": {
        "file_id": 305,
        "content": "/microgrid_base/topo_check.py",
        "type": "filepath"
    },
    "2719": {
        "file_id": 305,
        "content": "Imports necessary modules and functions from log_utils and topo_check_v2 for the microgrid base topology checking.",
        "type": "summary"
    },
    "2720": {
        "file_id": 305,
        "content": "from log_utils import logger_print\nfrom topo_check_v2 import *",
        "type": "code",
        "location": "/microgrid_base/topo_check.py:1-3"
    },
    "2721": {
        "file_id": 305,
        "content": "Imports necessary modules and functions from log_utils and topo_check_v2 for the microgrid base topology checking.",
        "type": "comment"
    },
    "2722": {
        "file_id": 306,
        "content": "/microgrid_base/topo_check_v1.py.j2",
        "type": "filepath"
    },
    "2723": {
        "file_id": 306,
        "content": "The code performs microgrid network validation, initializes topology graphs and nodes, establishes connections, and handles exceptions. It utilizes libraries, defines functions, and creates instances of devices and interfaces from JSON data.",
        "type": "summary"
    },
    "2724": {
        "file_id": 306,
        "content": "from log_utils import logger_print\n{# from pydantic import BaseModel #}\n{# import when needed. #}\nimport networkx\nfrom networkx.readwrite import json_graph\nfrom config import ies_env\n# when to check topology:\n# \t1.  Building topology <- which the frontend does the job\n# \t2.  Importing topology <- where algorithm kicks in\n# so here we only check topo when importing. we don't check validity during topo construction.\n{# type_sys = {{str(type_sys)}} # will work? #}\n# 母线最多99个对接的接口\ndef getMainAndSubType(data):\n    logger_print(\"DATA:\", data)\n    return data['type'], data['subtype']\n# better use some template.\n# 设备、母线、连接线、合并线\n{% for mtype, mdata in 类型集合分类 %}\n{{mtype}}类型 = {{mdata}}\n{% endfor %}\n设备接口集合 = {{ 设备接口集合 }}\n连接类型映射表 = {{连接类型映射表}}\n{# \ndef getMainAndSubType(data):\n    mainType = data['type']\n    subType = data['subtype']\n    return mainType, subType #}\n{% macro neighborIterator() %}\n                for n in neighbors:\n                    ne_data = self.G.nodes[n]\n                    ne_type, ne_subtype = getMainAndSubType(ne_data)",
        "type": "code",
        "location": "/microgrid_base/topo_check_v1.py.j2:1-41"
    },
    "2725": {
        "file_id": 306,
        "content": "Code imports necessary libraries, defines a function to get main and subtype from data, and sets up various types of objects (devices, busbars, lines) in a template-based manner. It also defines a neighbor iterator macro.",
        "type": "comment"
    },
    "2726": {
        "file_id": 306,
        "content": "{% endmacro %}\n{% macro adderMacro(source_subtype, source_id, target)%}\n                    if {{source_subtype}}.endswith(\"输入输出\"):\n                        {{target}}['IO'].append({{source_id}})\n                    elif {{source_subtype}}.endswith(\"输入\"):\n                        {{target}}['output'].append({{source_id}})\n                    elif {{source_subtype}}.endswith(\"输出\"):\n                        {{target}}['input'].append({{source_id}})\n                    else:\n                        raise Exception(\"Unknown type:\", {{source_subtype}})\n{% endmacro %}\n{% macro error_node_info(node_id=\"node_id\")%}节点 {{\"#{\"}}{{node_id}}{{\"}\"}}{% endmacro %}\nclass 拓扑图:\n    def __init__(self, **kwargs):\n        self.node_count = 0\n        self.G = networkx.Graph(**kwargs)\n        self.合并母线ID集合列表 = []\n        self.is_valid = ies_env.FAILSAFE\n    def get_all_devices(self) -> list:\n        devs = []\n        for node_index, node_data in self.G.nodes.items():\n            node_type = node_data['type']\n            node_data['id'] = node_index",
        "type": "code",
        "location": "/microgrid_base/topo_check_v1.py.j2:43-69"
    },
    "2727": {
        "file_id": 306,
        "content": "This code defines a class for a topology graph and includes helper macros to add nodes and handle errors. The main functionality is initializing the topology graph object, iterating through node data in the graph, setting IDs, and handling different types of nodes (input, output, input/output). It also checks if the node type is known or throws an exception if not.",
        "type": "comment"
    },
    "2728": {
        "file_id": 306,
        "content": "            if node_type == \"设备\":\n                devs.append(node_data)\n        return devs\n    def get_all_adders(self) -> dict: # don't care about types here.\n        # use adder ids. adder starts with -1\n        adders = {min(s):{\"input\":[], \"output\":[], \"IO\":[]} for s in self.合并母线ID集合列表} # 用到：合并母线ID集合列表\n        adder_id = -1\n        母线ID映射表 = {e:min(s) for s in self.合并母线ID集合列表 for e in s}\n        # format: {\"input\":input_ids, \"output\": output_ids, \"IO\": IO_ids}\n        for node_index, node_data in self.G.nodes.items():\n            node_type = node_data[\"type\"]\n            if node_type == \"连接线\":\n                adder = {\"input\":[], \"output\":[], \"IO\":[]}\n                #  检查连接线两端\n                left_id, right_id = self.G.neighbors(node_index)\n                left_type = self.G.nodes[left_id]['type']\n                right_type = self.G.nodes[right_id]['type']\n                left_subtype = self.G.nodes[left_id]['subtype']\n                right_subtype = self.G.nodes[right_id]['subtype']\n                if left_type == \"母线\" and right_type == \"锚点\":",
        "type": "code",
        "location": "/microgrid_base/topo_check_v1.py.j2:71-95"
    },
    "2729": {
        "file_id": 306,
        "content": "This code defines two functions, `get_all_devs()` and `get_all_adders()`, which appear to be part of a larger class. The `get_all_devs()` function returns a list of device nodes based on their types, while the `get_all_adders()` function populates an adder dictionary using adder IDs and node information from the graph (G). It seems that this code is related to some sort of network or grid topology.",
        "type": "comment"
    },
    "2730": {
        "file_id": 306,
        "content": "                    (left_id, left_type, left_subtype), (right_id, right_type,right_subtype) = (right_id, right_type,right_subtype), (left_id, left_type, left_subtype)\n                if left_type == \"锚点\" and right_type == \"锚点\":\n{{ adderMacro(\"left_subtype\", \"left_id\", \"adder\") }}\n{{ adderMacro(\"right_subtype\", \"right_id\", \"adder\") }}\n                    adders[adder_id] = adder\n                    adder_id -= 1\n                elif left_type == \"锚点\" and right_type == \"母线\":\n                    madder_id = 母线ID映射表[right_id]\n{{ adderMacro(\"left_subtype\", \"left_id\", \"adders[madder_id]\") }}\n                else:\n                    raise Exception(f\"不合理的连接线两端：{left_type}[{left_subtype}]-{right_type}[{right_subtype}]\")\n                {# adders.append(adder) #}\n        return adders\n    def get_graph_data(self) -> dict: # primary data. shall be found somewhere.\n        graph_data = self.G.graph\n        return graph_data\n    def add_node(self, **kwargs):\n        self.G.add_node(self.node_count,**kwargs)\n        node_id = self.node_count",
        "type": "code",
        "location": "/microgrid_base/topo_check_v1.py.j2:96-119"
    },
    "2731": {
        "file_id": 306,
        "content": "The code appears to be part of a network topology checker, with functions for adding nodes, getting graph data, and checking connections between different types of elements. It seems to involve some translation or mapping between \"锚点\" (anchor points) and \"母线\" (mother lines). The adderMacro function is used to process subtypes and adders. An exception is thrown for unreasonable connection line endpoints.",
        "type": "comment"
    },
    "2732": {
        "file_id": 306,
        "content": "        self.node_count += 1\n        return node_id\n    # monotonically adding a node.\n    def check_consistency(self): # return nothing.\n        #  use subgraph\n        # 提取所有母线ID\n        母线ID列表 = []\n        合并线ID列表 = []\n        for node_id, node_data in self.G.nodes.items():\n            node_type, node_subtype = getMainAndSubType(node_data)\n            logger_print(\"NODE TYPE:\", node_type)\n            logger_print(\"NODE SUBTYPE:\", node_subtype)\n            neighbors = list(self.G.neighbors(node_id))\n            logger_print(\"NEIGHBORS:\", neighbors)\n            for n in neighbors:\n                logger_print(self.G.nodes[n])\n            logger_print(\"=\"*40)\n            if node_type == \"母线\":\n                母线ID列表.append(node_id)\n                assert node_subtype in 母线类型, f\"{{error_node_info()}} 不存在的母线类型: {node_subtype}\"\n                assert len(neighbors) <= 99, f\"{{error_node_info()}} 母线连接数超过99: {len(neighbors)}\"\n{{ neighborIterator()}}\n                    if ne_type == \"合并线\":\n                        # just check type.",
        "type": "code",
        "location": "/microgrid_base/topo_check_v1.py.j2:120-143"
    },
    "2733": {
        "file_id": 306,
        "content": "This code is performing a consistency check on a microgrid network. It iterates through each node, checks its type and subtype, and ensures that the connections and attributes are correct. If any errors occur, it raises an assertion error with relevant information about the problematic node. The function also includes a call to `neighborIterator()`, likely for further processing of neighboring nodes.",
        "type": "comment"
    },
    "2734": {
        "file_id": 306,
        "content": "                        assert ne_subtype in 合并线类型, f\"{{error_node_info('n')}} 不存在的合并线类型: {ne_subtype}\"\n                        assert ne_subtype.replace(\"合并\", \"连接\") == node_subtype, f\"{{error_node_info('n')}}\"\n                    elif ne_type == \"连接线\":\n                        assert ne_subtype in 连接线类型, f\"{{error_node_info('n')}} 不存在的连接线类型: {ne_subtype}\"\n                        assert ne_subtype.replace('不可','可').replace(\"输入\",\"\").replace(\"输出\",\"\") == node_subtype, f\"{{error_node_info('n')}} 不合理的连接对： ({ne_subtype}, {node_subtype})\"\n                    else:\n                        raise Exception(f\"{{error_node_info('n')}} {node_subtype}连接非法类型节点：\",ne_type)\n            elif node_type == \"设备\":\n                assert node_subtype in 设备类型, f\"{{error_node_info()}} 不存在的设备类型: {node_subtype}\"\n                port_set = set()\n{{neighborIterator()}}\n                    port_name = ne_data['port_name']\n                    assert ne_type == \"锚点\", f\"{{error_node_info('n')}} 错误的节点类型: {ne_type}\"\n                  ",
        "type": "code",
        "location": "/microgrid_base/topo_check_v1.py.j2:144-158"
    },
    "2735": {
        "file_id": 306,
        "content": "The code is validating the node subtype and ensuring that it belongs to a defined set of types for each type of node. It also checks if the connection between nodes is logical by comparing their subtypes. If any of these assertions fail, an exception is raised with a descriptive error message. The \"设备类型\" and \"连接线类型\" sets are not defined in this code snippet but should be available elsewhere in the codebase to allow for proper validation of the node subtype.",
        "type": "comment"
    },
    "2736": {
        "file_id": 306,
        "content": "  assert len(list(self.G.neighbors(n))) == 2, f\"{{error_node_info('n')}} 相邻节点数错误: {len(list(self.G.neighbors(n)))} 相邻节点: {(list(self.G.neighbors(n)))}\"\n                    port_set.add((port_name, ne_subtype))\n                assert port_set == 设备接口集合[node_subtype], f\"{{error_node_info()}}  PORT SET: {port_set} TARGET: {设备接口集合[node_subtype]}\"\n            elif node_type == \"连接线\":\n                assert node_subtype in 连接线类型, f'{{error_node_info()}} 不合理连接线类型： {node_subtype}'\n                assert len(neighbors) == 2, f'{{error_node_info()}} 不合理连接线相邻节点数: {len(neighbors)} 相邻节点: {neighbors}'\n                dev_ids = set()\n                subtypes = []\n                {{neighborIterator()}}\n                    assert ne_type in [\"锚点\",\"母线\"]\n                    subtypes.append(ne_subtype)\n                    if ne_type == \"锚点\":\n                        dev_ids.add(ne_data['device_id'])\n                    else:\n                        dev_ids.add(n)\n                assert len(dev_ids) == 2, f'{{error_node_info()}} invalid dev_ids: {dev_ids}' # no self-connection.",
        "type": "code",
        "location": "/microgrid_base/topo_check_v1.py.j2:158-174"
    },
    "2737": {
        "file_id": 306,
        "content": "This code checks the number of neighbors for each node and verifies if they are of valid subtypes. It also ensures that the port set is correct and prevents self-connections. The code handles nodes of types \"电源站\" and \"连接线\".",
        "type": "comment"
    },
    "2738": {
        "file_id": 306,
        "content": "                try:\n                    assert 连接类型映射表[frozenset(subtypes)] == node_subtype\n                except:\n                    raise Exception(f\"{{error_node_info()}} 未知连接组合: (两端: {subtypes} 连接线: {node_subtype})\")\n            elif node_type == \"合并线\":\n                合并线ID列表.append(node_id)\n                assert node_subtype in 合并线类型, f\"{{error_node_info()}} 未知合并线类型: {node_subtype}\"\n                assert len(neighbors) == 2, f\"{{error_node_info()}} 不合理相邻节点数: {len(neighbors)} 相邻节点: {len(neighbors)}\"\n                node_ids = set()\n                {{neighborIterator()}}\n                    assert ne_type == \"母线\", f\"{{error_node_info('n')}} 不合理类型: {ne_type}\"\n                    node_ids.add(n)\n                assert len(node_ids) == 2, f\"{{error_node_info()}} 不合理合并线总节点数：{len(node_ids)} 节点列表: {node_ids}\"\n            elif node_type == '锚点':\n                continue\n            else:\n                raise Exception(\"unknown node type:\", node_type)\n        subgraph = self.G.subgraph(母线ID列表+合并线ID列表) # check again.",
        "type": "code",
        "location": "/microgrid_base/topo_check_v1.py.j2:175-192"
    },
    "2739": {
        "file_id": 306,
        "content": "This code is checking the types of nodes in a topology and ensuring they adhere to certain conditions. It handles three types: connection lines, merging lines, and anchors. The code raises exceptions for unknown node subtypes or if merging lines have an incorrect number of neighbors. If the node type is not recognized, it throws an exception with the unknown type. Finally, it creates a subgraph containing all mother and merge lines.",
        "type": "comment"
    },
    "2740": {
        "file_id": 306,
        "content": "        logger_print(\"母线ID列表:\", 母线ID列表)\n        {# breakpoint() #}\n        self.合并母线ID集合列表 = list(networkx.connected_components(subgraph))\n        self.合并母线ID集合列表 = [set([i for i in e if i not in 合并线ID列表]) for e in self.合并母线ID集合列表]\n        logger_print(\"合并母线ID集合列表:\", self.合并母线ID集合列表)\n        for id_set in self.合并母线ID集合列表:\n            has_input = False\n            has_output = False\n            input_conns = []\n            output_conns = []\n            for node_id in id_set:\n                node_data = self.G.nodes[node_id]\n                {# if node_data['type'] == '合并线': continue #}\n                conn = [e for e in node_data['conn'] if not e.startswith(\"可合并\")] # list.\n                merge = [e for e in node_data['conn'] if e.startswith(\"可合并\")]\n                assert len(merge)<=2, f'{{error_node_info()}} 错误的可合并连接数: {len(merge)} 可合并线列表: {merge}'\n                for c in conn:\n                    if not c.endswith(\"输入输出\"):\n                        if c.endswith(\"输入\"):\n                            input_conns.append(c)",
        "type": "code",
        "location": "/microgrid_base/topo_check_v1.py.j2:193-212"
    },
    "2741": {
        "file_id": 306,
        "content": "This code initializes a logger print of the bus ID list, then merges bus IDs into a set and stores them in a list. It checks if there are any input or output connections for each bus and stores them separately.",
        "type": "comment"
    },
    "2742": {
        "file_id": 306,
        "content": "                            has_input=True\n                        elif c.endswith(\"输出\"):\n                            output_conns.append(c)\n                            has_output=True\n                        else:\n                            raise Exception(f\"{self.G.nodes[node_id]['type']}不可接受的连接类型: {c}\")\n            if has_input and has_output:\n                # 检查柴油类型的\n                if output_conns[0] == \"不可连接柴油母线输出\":\n                    assert len(output_conns) == 1, f\"{{error_node_info()}} 柴油母线有且只有一个与柴油元件的连接\"\n            else:\n                logger_print()\n                logger_print(\"============ERROR LOG============\")\n                logger_print()\n                for n in id_set:\n                    logger_print(\"母线:\", self.G.nodes[n])\n                logger_print()\n                logger_print(\"INPUT:\", has_input)\n                logger_print(\"OUTPUT:\", has_output)\n                logger_print()\n                raise Exception(f\"母线组{id_set}未实现至少一进一出\")\n        self.is_valid = True\n    def to_json(self) -> dict:",
        "type": "code",
        "location": "/microgrid_base/topo_check_v1.py.j2:213-236"
    },
    "2743": {
        "file_id": 306,
        "content": "The code checks the connections of motherlines and their nodes, ensuring they have at least one input and one output connection. If a motherline does not meet this requirement, it raises an exception with error information. If all motherlines satisfy the condition, the code continues execution.",
        "type": "comment"
    },
    "2744": {
        "file_id": 306,
        "content": "        data = json_graph.node_link_data(self.G)\n        return data\n    @staticmethod\n    def from_json(data):\n        # load data to graph\n        G = json_graph.node_link_graph(data)\n        kwargs = G.graph\n        topo = 拓扑图(**kwargs)\n        topo.G = G\n        if not ies_env.FAILSAFE:\n            topo.check_consistency()\n        return topo\n    # with checking.\n    # iterate through all nodes.\n# 下面的都需要传拓扑图进来\nclass 节点:\n    def __init__(self, topo:拓扑图, **kwargs):\n        self.topo = topo\n        self.kwargs = kwargs\n        self.id = self.topo.add_node(**kwargs)\nclass 母线(节点):\n    def __init__(self, topo:拓扑图, subtype:str, **kwargs):\n        super().__init__(topo, type=\"母线\", subtype=subtype ,conn = [],**kwargs)\n        # infinite ports.\nclass 设备(节点):\n    def __init__(self, topo:拓扑图, device_type:str, port_definition, # iterable. \n    **kwargs):\n        # check if device type is one of the common types.\n        super().__init__(topo, type=\"设备\", subtype=device_type, ports={}, **kwargs)\n        self.ports = {}\n        for port_name, port_type in port_definition:",
        "type": "code",
        "location": "/microgrid_base/topo_check_v1.py.j2:237-273"
    },
    "2745": {
        "file_id": 306,
        "content": "This code defines a class for topology graphs, a Node class representing nodes in the graph, and a Busbar class and Device class extending Node. The classes can be initialized with specific types, subtypes, and other parameters. The code also includes methods to create a topology from JSON data and check the consistency of the topology.",
        "type": "comment"
    },
    "2746": {
        "file_id": 306,
        "content": "            port_node_id = self.topo.add_node(type=\"锚点\", port_name=port_name, subtype=port_type, device_id = self.id)\n            self.ports.update({port_name: {\"subtype\": port_type,\"id\":port_node_id}})\n            self.topo.G.add_edge(self.id, port_node_id)\n            {# logger_print(\"EDGE IDS:\", self.id, port_node_id)\n            breakpoint() #}\n        self.topo.G.nodes[self.id]['ports'] = self.ports\nclass 连接节点(节点):\n    def __init__(self, topo:拓扑图, _type:str, subtype:str, conn_start_id:int, conn_end_id:int, **kwargs):\n        super().__init__(topo, type=_type, subtype = subtype, **kwargs)\n        self.topo.G.add_edge(conn_start_id, self.id)\n        self.topo.G.add_edge(self.id, conn_end_id)\n        if self.topo.G.nodes[conn_start_id][\"type\"] == \"母线\":\n            self.topo.G.nodes[conn_start_id][\"conn\"].append(subtype)\n        if self.topo.G.nodes[conn_end_id][\"type\"] == \"母线\":\n            self.topo.G.nodes[conn_end_id][\"conn\"].append(subtype)\n{% macro makeConnNodeInstance(className) %}\nclass {{className}}(连接节点):",
        "type": "code",
        "location": "/microgrid_base/topo_check_v1.py.j2:274-293"
    },
    "2747": {
        "file_id": 306,
        "content": "This code adds a new node to the topology, representing a port connection. It assigns an ID to the node based on its type and port name. The newly added node's information is updated in the ports dictionary, and edges are created between the main node and this port node. Additionally, if either of the connected nodes are mother lines, the subtype of this new port node is appended to their list of connected types. Finally, a macro function is defined for creating instances of custom connection node classes.",
        "type": "comment"
    },
    "2748": {
        "file_id": 306,
        "content": "    def __init__(self, topo:拓扑图, subtype:str, conn_start_id:int, conn_end_id:int, **kwargs):\n        super().__init__(topo, _type=\"{{className}}\", subtype = subtype, conn_start_id= conn_start_id, conn_end_id=conn_end_id, **kwargs)\n{% endmacro %}\n{{ makeConnNodeInstance(\"连接线\") }}\n{{ makeConnNodeInstance(\"合并线\") }}\n{% macro makeDevice(device_name, port_definition) %}\nclass {{device_name}}(设备):\n    def __init__(self, topo:拓扑图, **kwargs):\n        super().__init__(topo=topo, device_type=\"{{device_name}}\",  port_definition={{port_definition}}, **kwargs)\n        {% for port_name, port_type in port_definition %}\n        self.{{ port_name }} = self.ports[\"{{port_name}}\"]['id']\n        {% endfor %}\n{% endmacro %}\n{% for device_name, port_definition in 设备接口集合.items() %}\n{{makeDevice(device_name, port_definition)}}\n{% endfor %}",
        "type": "code",
        "location": "/microgrid_base/topo_check_v1.py.j2:294-317"
    },
    "2749": {
        "file_id": 306,
        "content": "Code defines a class with the name \"microgrid_base/topo_check_v1.py\" and contains functions to create instances of connections, devices, and device interfaces using pre-defined templates or definitions. These instances are used to represent various components in a network topology. The code also includes a macro definition for creating device classes with specific port configurations.",
        "type": "comment"
    },
    "2750": {
        "file_id": 307,
        "content": "/microgrid_base/topo_check_v2.py.j2",
        "type": "filepath"
    },
    "2751": {
        "file_id": 307,
        "content": "This code manages network topology, defines node types and device handling, and includes classes for microgrid topology graphs and network analysis. It checks connectivity, creates subgraphs, and stores properties in a \"ports\" dictionary.",
        "type": "summary"
    },
    "2752": {
        "file_id": 307,
        "content": "from log_utils import logger_print\nfrom log_utils import logger_traceback\nfrom type_utils import dynamic_verify_topo_object\nimport networkx\nfrom networkx.readwrite import json_graph\nfrom config import ies_env\nfrom pydantic import BaseModel\nfrom typing import List, Dict, Literal\n# when to check topology:\n# \t1.  Building topology <- which the frontend does the job\n# \t2.  Importing topology <- where algorithm kicks in\n# so here we only check topo when importing. we don't check validity during topo construction.\n# 母线最多99个对接的接口\ndef getMainAndSubType(data):\n    logger_print(\"DATA:\", data)\n    return data[\"type\"], data[\"subtype\"]\ndef getMainType(data):\n    logger_print(\"DATA:\", data)\n    return data[\"type\"]\n# better use some template.\n# 设备、母线、连接线、合并线\n设备类型 = {{设备类型}}\n设备接口名称集合 = {{设备接口名称集合}}\ndirectionLookupTable = {{directionLookupTable}}\nclass NodeStruct(BaseModel):\n    id:int\n    type:str\n    subtype:str\n    direction:Literal[None, \"输入输出\", \"输入\", \"输出\"] = None\ndef constructAdder() -> Dict[str,List[int]]:\n    return {\"input\": [], \"output\": [], \"IO\": []}",
        "type": "code",
        "location": "/microgrid_base/topo_check_v2.py.j2:1-49"
    },
    "2753": {
        "file_id": 307,
        "content": "The code defines functions for getting main and sub types, main type, and constructs an adder dictionary. It also imports necessary modules, sets when to check topology, and defines a NodeStruct class. The code is related to network topology management, data processing, and handling device types and interfaces.",
        "type": "comment"
    },
    "2754": {
        "file_id": 307,
        "content": "def parse_node_struct_and_update_adder(node:NodeStruct, adder:Dict[str,List[int]]):\n    # this is the main reason you cannot make subtype passed from frontend.\n    # TODO: resolve direction from rules\n    direction = node.direction\n    if direction == \"输入输出\":\n        adder[\"IO\"].append(node.id)\n    elif direction == \"输入\":\n        adder[\"output\"].append(node.id)\n    elif direction == \"输出\":\n        adder[\"input\"].append(node.id)\n    elif direction is None:\n        raise Exception(\"direction is not specified in node struct:\", node)\n    else:\n        raise Exception(\"Unknown direction for node:\", node)\ndef get_node_struct_from_node_id_and_node_data(node_id, node_data):\n    _type = node_data[\"type\"]\n    subtype = node_data[\"subtype\"]\n    direction = node_data.get('direction', None)\n    node_struct = NodeStruct(id = node_id, type= _type, subtype=subtype, direction = direction)\n    return node_struct\ndef lookup_port_direction(device_name, node_name):\n    direction = directionLookupTable[device_name][node_name]\n    return direction",
        "type": "code",
        "location": "/microgrid_base/topo_check_v2.py.j2:51-76"
    },
    "2755": {
        "file_id": 307,
        "content": "This code defines three functions: `parse_node_struct_and_update_adder`, `get_node_struct_from_node_id_and_node_data`, and `lookup_port_direction`. The first function updates a dictionary with node IDs based on their direction, the second function creates a `NodeStruct` object from node data, and the third function looks up the direction for a device and node combination.",
        "type": "comment"
    },
    "2756": {
        "file_id": 307,
        "content": "class 拓扑图:\n    def __init__(self, **kwargs):\n        self.node_count = 0\n        self.G = networkx.Graph(**kwargs)\n        self.合并母线ID集合列表 = []\n        self.is_valid = ies_env.FAILSAFE\n    def get_direction_from_node_id(self, node_id):\n        direction = None\n        node_data = self.G.nodes[node_id]\n        if node_data['type'] == '锚点':\n            node_name = node_data['port_name']\n            for neighbor_id in self.G.neighbors(node_id):\n                neighbor_data = self.G.nodes[neighbor_id]\n                if neighbor_data['type'] == '设备':\n                    device_name = neighbor_data['subtype']\n                    direction = lookup_port_direction(device_name, node_name)\n        return direction\n    def get_node_struct_from_node_id(self, node_id):\n        node_data = self.G.nodes[node_id]\n        direction = self.get_direction_from_node_id(node_id)\n        if direction is not None:\n            node_data['direction'] = direction\n        node_struct = get_node_struct_from_node_id_and_node_data(node_id, node_data)",
        "type": "code",
        "location": "/microgrid_base/topo_check_v2.py.j2:78-105"
    },
    "2757": {
        "file_id": 307,
        "content": "The code defines a class \"拓扑图\" that represents a topology graph. It initializes the node count, creates a networkx graph object, and maintains a list of merged feeder IDs. The class has two methods: \"get_direction_from_node_id\" retrieves the direction from a node ID by looking up the port name and device subtype, and \"get_node_struct_from_node_id\" gets the node structure for a given node ID and its data. If the direction is not None, it adds the direction to the node data before returning the node structure using another function.",
        "type": "comment"
    },
    "2758": {
        "file_id": 307,
        "content": "        return node_struct\n    def get_left_and_right_node_struct_from_connector_node_index(self, node_index):\n        left_id, right_id = self.G.neighbors(node_index)\n        left_node_struct, right_node_struct = self.get_node_struct_from_node_id(left_id), self.get_node_struct_from_node_id(right_id)\n        return left_node_struct, right_node_struct\n    def get_all_devices(self) -> list:\n        devs = []\n        for node_index, node_data in self.G.nodes.items():\n            node_type = node_data[\"type\"]\n            node_data[\"id\"] = node_index\n            if node_type == \"设备\":\n                devs.append(node_data)\n        return devs\n    def get_all_adders(self) -> dict:  # don't care about types here.\n        # use adder ids. adder starts with -1\n        adders = {\n            min(s): constructAdder() for s in self.合并母线ID集合列表\n        }  # 用到：合并母线ID集合列表\n        adder_id = -1\n        母线ID映射表 = {e: min(s) for s in self.合并母线ID集合列表 for e in s}\n        # format: {\"input\":input_ids, \"output\": output_ids, \"IO\": IO_ids}",
        "type": "code",
        "location": "/microgrid_base/topo_check_v2.py.j2:106-130"
    },
    "2759": {
        "file_id": 307,
        "content": "This code is related to a microgrid, specifically for topology checking. It includes functions for getting the left and right node structures from a connector node index, getting all devices in the network, and creating a dictionary of adders using merged line IDs. The merged line ID set is used to map adder IDs and create an input-output-IO structure for the adders.",
        "type": "comment"
    },
    "2760": {
        "file_id": 307,
        "content": "        for node_index, node_data in self.G.nodes.items():\n            node = get_node_struct_from_node_id_and_node_data(node_index, node_data)\n            {# node.type = node_data[\"type\"] #}\n            if node.type == \"连接线\":\n                #  检查连接线两端\n                left, right = self.get_left_and_right_node_struct_from_connector_node_index(node_index)\n                if left.type == \"母线\" and right.type == \"锚点\": # swap\n                    right, left = left, right\n                if left.type == \"锚点\" and right.type == \"锚点\":\n                    adder = constructAdder()\n                    parse_node_struct_and_update_adder(left, adder)\n                    parse_node_struct_and_update_adder(right, adder)\n                    adders[adder_id] = adder\n                    adder_id -= 1\n                elif left.type == \"锚点\" and right.type == \"母线\":\n                    madder_id = 母线ID映射表[right.id]\n                    adder = adders[madder_id]\n                    parse_node_struct_and_update_adder(left, adder)",
        "type": "code",
        "location": "/microgrid_base/topo_check_v2.py.j2:131-154"
    },
    "2761": {
        "file_id": 307,
        "content": "Iterates through each node in the graph and checks if it is a \"连接线\". If both adjacent nodes are \"母线\" and \"锚点\", it creates an adder. If one is a \"锚点\" and the other is a \"母线\", it uses the existing adder for the \"母线\". Updates the adders dictionary as needed.",
        "type": "comment"
    },
    "2762": {
        "file_id": 307,
        "content": "                else:\n                    raise Exception(\n                        f\"不合理的连接线两端：{left.type}[{left.subtype}]-{right.type}[{right.subtype}]\"\n                    )\n        return adders\n    def get_graph_data(self) -> dict:  # primary data. shall be found somewhere.\n        graph_data = self.G.graph\n        return graph_data\n    def add_node(self, **kwargs):\n        self.G.add_node(self.node_count, **kwargs)\n        node_id = self.node_count\n        self.node_count += 1\n        return node_id\n    def get_neighbors_by_node_id(self, node_id):\n        neighbors = list(self.G.neighbors(node_id))\n        logger_print(f\"NEIGHBORS FOR NODE #{node_id}:\", neighbors)\n        for n in neighbors:\n            logger_print(self.G.nodes[n])\n        return neighbors\n    # monotonically adding a node.\n    def _check_consistency(self):  # return nothing.\n        #  use subgraph\n        # 提取所有母线ID\n        母线ID列表 = []\n        合并线ID列表 = []\n        for node_id, node_data in self.G.nodes.items():\n            node = get_node_struct_from_node_id_and_node_data(node_id, node_data)",
        "type": "code",
        "location": "/microgrid_base/topo_check_v2.py.j2:156-188"
    },
    "2763": {
        "file_id": 307,
        "content": "This code appears to define a class for microgrid network analysis, including functions to add nodes, check consistency, and retrieve neighboring nodes. The class utilizes a graph data structure and includes methods to access and manipulate the network topology. It also has error handling in place to identify unreasonable connection lines.",
        "type": "comment"
    },
    "2764": {
        "file_id": 307,
        "content": "            logger_print(\"NODE TYPE:\", node.type)\n            logger_print(\"NODE SUBTYPE:\", node.subtype)\n            neighbors = self.get_neighbors_by_node_id(node.id)\n            neighbors_count = len(neighbors)\n            logger_print(\"=\" * 40)\n            if node.type == \"母线\":\n                母线ID列表.append(node.id)\n                assert (\n                   neighbors_count <= 99\n                ), f\"节点 #{node.id} 母线连接数超过99: {neighbors_count}\"\n                for n in neighbors:\n                    ne_data = self.G.nodes[n]\n                    ne_type, ne_subtype = getMainAndSubType(ne_data)\n                    if ne_type in [\"合并线\", \"连接线\"]:\n                        pass\n                    else:\n                        raise Exception(f\"节点 #{n} {node.subtype}连接非法类型节点：\", ne_type)\n            elif node.type == \"设备\":\n                try:\n                    assert node.subtype in 设备类型, f\"节点 #{node.id} 不存在的设备类型: {node.subtype}\"\n                    port_name_set = set()\n                    for n in neighbors:",
        "type": "code",
        "location": "/microgrid_base/topo_check_v2.py.j2:190-217"
    },
    "2765": {
        "file_id": 307,
        "content": "This code checks the type and subtype of a node, retrieves its neighbors, and asserts that it has no more than 99 connections. If the node is a \"母线\", it adds its ID to a list and further checks if all neighbors are of valid types. For \"设备\" nodes, it checks if their subtype exists in the \"设备类型\" list. The code also handles exceptions for invalid neighbor types and non-existing device types.",
        "type": "comment"
    },
    "2766": {
        "file_id": 307,
        "content": "                        ne_data = self.G.nodes[n]\n                        ne_type, ne_subtype = getMainAndSubType(ne_data)\n                        port_name = ne_data[\"port_name\"]\n                        assert ne_type == \"锚点\", f\"节点 #{n} 错误的节点类型: {ne_type}\"\n                        assert (\n                            len(list(self.G.neighbors(n))) == 2\n                        ), f\"节点 #{n} 相邻节点数错误: {len(list(self.G.neighbors(n)))} 相邻节点: {(list(self.G.neighbors(n)))}\"\n                        port_name_set.add(port_name)\n                        {# port_set.add((port_name, ne_subtype)) #}\n                    assert (\n                        port_name_set == 设备接口名称集合[node.subtype]\n                    ), f\"节点 #{node.id}  PORT SET: {port_name_set} TARGET: {设备接口名称集合[node.subtype]}\"\n                except Exception as e:\n                    if ies_env.FAILSAFE or ies_env.IGNORE_ANCHOR_EXCEPTIONS:\n                        logger_print(\"Ignoring exception in device type:\", node.subtype)\n                        logger_traceback(e)",
        "type": "code",
        "location": "/microgrid_base/topo_check_v2.py.j2:218-235"
    },
    "2767": {
        "file_id": 307,
        "content": "This code is part of a network topology checking function. It checks if a node has the correct type, two neighbors, and if its port name matches expected values. If any errors occur, an assertion error is thrown. If exceptions are ignored due to specific environment settings, they will be logged.",
        "type": "comment"
    },
    "2768": {
        "file_id": 307,
        "content": "                    else:\n                        raise e\n            elif node.type == \"连接线\":\n                {# assert node.subtype in 连接线类型, f\"节点 #{node.id} 不合理连接线类型： {node.subtype}\" #}\n                assert (\n                    len(neighbors) == 2\n                ), f\"节点 #{node.id} 不合理连接线相邻节点数: {len(neighbors)} 相邻节点: {neighbors}\"\n                dev_ids = set()\n                subtypes = []\n                for n in neighbors:\n                    ne_data = self.G.nodes[n]\n                    ne_type, ne_subtype = getMainAndSubType(ne_data)\n                    assert ne_type in [\"锚点\", \"母线\"]\n                    {# subtypes.append(ne_subtype) #}\n                    if ne_type == \"锚点\":\n                        dev_ids.add(ne_data[\"device_id\"])\n                    else:\n                        dev_ids.add(n)\n                assert (\n                    len(dev_ids) == 2\n                ), f\"节点 #{node.id} invalid dev_ids: {dev_ids}\"  # no self-connection.\n                {# try:\n                    assert 连接类型映射表[frozenset(subtypes)] == node.subtype",
        "type": "code",
        "location": "/microgrid_base/topo_check_v2.py.j2:236-260"
    },
    "2769": {
        "file_id": 307,
        "content": "This code is validating the connectivity of nodes in a network. It checks if the node type is \"连接线\" and ensures that it has exactly 2 neighbors, raising an error if not. It then asserts that the neighbors have valid subtypes and that there are no self-connections. The code also attempts to verify the connection type based on the subtypes of the connected nodes.",
        "type": "comment"
    },
    "2770": {
        "file_id": 307,
        "content": "                except:\n                    raise Exception(\n                        f\"节点 #{node.id} 未知连接组合: (两端: {subtypes} 连接线: {node.subtype})\"\n                    ) #}\n            elif node.type == \"合并线\":\n                合并线ID列表.append(node.id)\n                {# assert node.subtype in 合并线类型, f\"节点 #{node.id} 未知合并线类型: {node.subtype}\" #}\n                assert (\n                    len(neighbors) == 2\n                ), f\"节点 #{node.id} 不合理相邻节点数: {len(neighbors)} 相邻节点: {len(neighbors)}\"\n                node_ids = set()\n                for n in neighbors:\n                    ne_data = self.G.nodes[n]\n                    ne_type, ne_subtype = getMainAndSubType(ne_data)\n                    assert ne_type == \"母线\", f\"节点 #{n} 不合理类型: {ne_type}\"\n                    node_ids.add(n)\n                assert (\n                    len(node_ids) == 2\n                ), f\"节点 #{node.id} 不合理合并线总节点数：{len(node_ids)} 节点列表: {node_ids}\"\n            elif node.type == \"锚点\":\n                continue\n            else:\n                raise Exception(\"unknown node type:\", node.type)",
        "type": "code",
        "location": "/microgrid_base/topo_check_v2.py.j2:261-285"
    },
    "2771": {
        "file_id": 307,
        "content": "Except block handles unknown connection combinations, raising an exception with node ID and details. For merge nodes, it checks if the subtype is valid and if the node has exactly 2 neighbors. It also ensures that the neighbors are of type \"mother cable\" and that the total number of node IDs for the merge node is 2. If a node type is unknown, an exception is raised with the type.",
        "type": "comment"
    },
    "2772": {
        "file_id": 307,
        "content": "        subgraph = self.G.subgraph(母线ID列表 + 合并线ID列表)  # check again.\n        logger_print(\"母线ID列表:\", 母线ID列表)\n        self.合并母线ID集合列表 = list(networkx.connected_components(subgraph))\n        self.合并母线ID集合列表 = [\n            set([i for i in e if i not in 合并线ID列表]) for e in self.合并母线ID集合列表\n        ]\n        logger_print(\"合并母线ID集合列表:\", self.合并母线ID集合列表)\n    def check_consistency(self):\n        self._check_consistency()\n        verified = False\n        isomorphic_topo_status = None\n        if ies_env.DYNAMIC_TYPE_VERIFICATION:\n            verified, isomorphic_topo_status = dynamic_verify_topo_object(self)\n        else:\n            logger_print(\"skipping dynamic verification\")\n            verified = True\n        if not verified:\n            raise Exception(\"Dynamical verification failed.\")\n        self.is_valid = True\n        return verified, isomorphic_topo_status\n    def to_json(self) -> dict:\n        data = json_graph.node_link_data(self.G)\n        return data\n    @staticmethod\n    def from_json(data):\n        # load data to graph",
        "type": "code",
        "location": "/microgrid_base/topo_check_v2.py.j2:286-314"
    },
    "2773": {
        "file_id": 307,
        "content": "The code is creating a subgraph of the network using bus and branch IDs, checking if the subgraph is consistent, and then converting the graph to JSON format. The code also performs dynamic verification for consistency and raises an exception if it fails. Finally, it sets the is_valid flag to True if all checks pass.",
        "type": "comment"
    },
    "2774": {
        "file_id": 307,
        "content": "        G = json_graph.node_link_graph(data)\n        kwargs = G.graph\n        topo = 拓扑图(**kwargs)\n        topo.G = G\n        try:\n            topo.check_consistency()\n        except Exception as e:\n            if not ies_env.FAILSAFE:\n                raise e\n            else:\n                logger_traceback(e)\n                logger_print(\"检测到拓扑图不合法，但仍然继续运行\")\n        return topo\n    # with checking.\n    # iterate through all nodes.\n# 下面的都需要传拓扑图进来\nclass 节点:\n    def __init__(self, topo: 拓扑图, **kwargs):\n        self.topo = topo\n        self.kwargs = kwargs\n        self.id = self.topo.add_node(**kwargs)\nclass 母线(节点):\n    def __init__(self, topo: 拓扑图, subtype: str, **kwargs):\n        super().__init__(topo, type=\"母线\", subtype=subtype, conn=[], **kwargs)\n        # infinite ports.\nclass 设备(节点):\n    def __init__(\n        self, topo: 拓扑图, device_type: str, port_definition, **kwargs  # iterable.\n    ):\n        # check if device type is one of the common types.\n        super().__init__(topo, type=\"设备\", subtype=device_type, ports={}, **kwargs)",
        "type": "code",
        "location": "/microgrid_base/topo_check_v2.py.j2:315-354"
    },
    "2775": {
        "file_id": 307,
        "content": "This code defines a topology class and two node classes, Busbar and Device. The topology class is created from a graph using the json_graph library and contains a graph G as an attribute. The Node class initializes with a topology object and additional keyword arguments, adding a node to the graph using the add_node method. The Busbar class extends the Node class and is specifically for mother lines. The Device class also extends the Node class, and takes in device type and port definition as parameters while checking if the device type is one of the common types.",
        "type": "comment"
    },
    "2776": {
        "file_id": 307,
        "content": "        self.ports = {}\n        for port_name in port_definition:\n            subtype = 'unknown'\n            port_node_id = self.topo.add_node(\n                type=\"锚点\", port_name=port_name, subtype=subtype, device_id=self.id\n            )\n            self.ports.update({port_name: {\"subtype\": subtype, \"id\": port_node_id}})\n            self.topo.G.add_edge(self.id, port_node_id)\n        self.topo.G.nodes[self.id][\"ports\"] = self.ports\nclass 连接节点(节点):\n    def __init__(\n        self,\n        topo: 拓扑图,\n        _type: str,\n        subtype: str,\n        conn_start_id: int,\n        conn_end_id: int,\n        **kwargs,\n    ):\n        super().__init__(topo, type=_type, subtype=subtype, **kwargs)\n        self.topo.G.add_edge(conn_start_id, self.id)\n        self.topo.G.add_edge(self.id, conn_end_id)\n        if self.topo.G.nodes[conn_start_id][\"type\"] == \"母线\":\n            self.topo.G.nodes[conn_start_id][\"conn\"].append(subtype)\n        if self.topo.G.nodes[conn_end_id][\"type\"] == \"母线\":\n            self.topo.G.nodes[conn_end_id][\"conn\"].append(subtype)",
        "type": "code",
        "location": "/microgrid_base/topo_check_v2.py.j2:355-382"
    },
    "2777": {
        "file_id": 307,
        "content": "This code defines a class for anchor nodes and connection nodes in a microgrid topology. Anchor nodes are added to the topology, and their properties such as subtype and ID are stored in the \"ports\" dictionary. Connection nodes are initialized with a given type, subtype, and connected nodes. If the connected node is a cable, its \"conn\" list is updated with the connection's subtype.",
        "type": "comment"
    },
    "2778": {
        "file_id": 307,
        "content": "{% macro makeConnNodeInstance(className) %}\nclass {{className}}(连接节点):\n    def __init__(self, topo:拓扑图, subtype:str, conn_start_id:int, conn_end_id:int, **kwargs):\n        super().__init__(topo, _type=\"{{className}}\", subtype = subtype, conn_start_id= conn_start_id, conn_end_id=conn_end_id, **kwargs)\n{% endmacro %}\n{{ makeConnNodeInstance(\"连接线\") }}\n{{ makeConnNodeInstance(\"合并线\") }}\n{% macro makeDevice(device_name, port_definition) %}\nclass {{device_name}}(设备):\n    def __init__(self, topo:拓扑图, **kwargs):\n        super().__init__(topo=topo, device_type=\"{{device_name}}\",  port_definition={{port_definition}}, **kwargs)\n        {% for port_name in port_definition %}\n        {# {% for port_name, port_type in port_definition %} #}\n        self.{{ port_name }} = self.ports[\"{{port_name}}\"]['id']\n        {% endfor %}\n{% endmacro %}\n{% for device_name, port_definition in 设备接口名称集合.items() %}\n{{makeDevice(device_name, port_definition)}}\n{% endfor %}",
        "type": "code",
        "location": "/microgrid_base/topo_check_v2.py.j2:384-411"
    },
    "2779": {
        "file_id": 307,
        "content": "This code is defining classes for connection nodes (such as \"连接线\" and \"合并线\") and devices using macro functions. It creates instances of these classes based on provided names and port definitions, initializing them with a given topology graph. The for loop iterates through the device name-port definition pairs from a collection called 设备接口名称集合 to create instances of each device class.",
        "type": "comment"
    },
    "2780": {
        "file_id": 308,
        "content": "/microgrid_base/type_def.py",
        "type": "filepath"
    },
    "2781": {
        "file_id": 308,
        "content": "The code uses StrEnum to define energy sources, water types, and refrigerants. It includes mappings between these types and a function to flatten the lists of type members. The code also resolves basic types by iterating over an input list, checking for matches in the `类型细分表`, adding corresponding types to a set, and recursively calling itself until all types are resolved.",
        "type": "summary"
    },
    "2782": {
        "file_id": 308,
        "content": "from log_utils import logger_print\n\"\"\"static & dynamic topology type checking\"\"\"\nfrom enum import auto\nfrom strenum import StrEnum\nclass 基本类型(StrEnum):\n    柴油 = auto()\n    天然气 = auto()\n    氢气 = auto()\n    电 = auto()\n    水 = auto()\n    蒸汽 = auto()\n    烟气 = auto()\n    导热油 = auto()\n    乙二醇 = auto()\nclass 水类型(StrEnum):\n    管道水 = auto()\n    自来水 = auto()\nclass 乙二醇类型(StrEnum):\n    冷乙二醇 = auto()\n    热乙二醇 = auto()\n    冰乙二醇 = auto()\nclass 管道水类型(StrEnum):\n    热水 = auto()\n    冷水 = auto()\n_mappings = {\n    基本类型.水: 水类型,\n    水类型.管道水: 管道水类型,\n    基本类型.乙二醇: 乙二醇类型,\n}\n类型泛化表 = {}\ndef flatten_mappings(c, cs: list):\n    if isinstance(c, str):\n        cs.append(c)\n    elif issubclass(c, StrEnum):\n        cs.extend(list(c.__members__.values()))\n    else:\n        raise Exception(\"Unsupported type:\", type(c))\nfrom error_utils import ErrorManager\nwith ErrorManager(default_error=f\"Found duplicated keys while processing.\") as em:\n    for v, k in _mappings.items():\n        ks = []\n        vs = []\n        flatten_mappings(k, ks)\n        flatten_mappings(v, vs)",
        "type": "code",
        "location": "/microgrid_base/type_def.py:1-62"
    },
    "2783": {
        "file_id": 308,
        "content": "This code defines various types of energy sources, water types, and refrigerants, using StrEnum class from the strenum module. It also includes mappings between these types and a function to flatten the lists of type members. The ErrorManager is used to check for duplicated keys while processing the mappings.",
        "type": "comment"
    },
    "2784": {
        "file_id": 308,
        "content": "        for k in ks:\n            for v in vs:\n                if k in 类型泛化表.keys():\n                    em.append(f\"Duplicated: {k} -> {v} (Already have: {类型泛化表[k]})\")\n                else:\n                    类型泛化表[str(k)] = str(v)\n类型细分表 = {}\nfor k, v in 类型泛化表.items():\n    if v not in 类型细分表.keys():\n        类型细分表[v] = set()\n    类型细分表[v].add(k)\ndef 解析基本类型(t0):\n    if isinstance(t0, str):\n        t = [t0]\n    else:\n        t = t0\n    t_resolved = set()\n    for _t in t:\n        # if _t in ['乙', '醇', '二']:\n        #     breakpoint()\n        if _t in 类型细分表.keys():\n            # logger_print('update:', _t)\n            t_resolved.update(类型细分表[_t])\n        else:\n            # logger_print('add:', _t)\n            t_resolved.add(_t)\n    ret = list(t_resolved)\n    # logger_print('ret:', ret)\n    if t_resolved == set(t):\n        return ret\n    else:\n        # logger_print(\"t_resolved:\", t_resolved)\n        # if t_resolved == {'乙', '醇', '二'}: breakpoint()\n        # logger_print('rec ret:', ret)\n        return 解析基本类型(ret)",
        "type": "code",
        "location": "/microgrid_base/type_def.py:63-100"
    },
    "2785": {
        "file_id": 308,
        "content": "The code defines a function `解析基本类型(t0)` to resolve basic types by iterating over the input list `t0`. It checks if the type is in the `类型细分表`, and if so, adds its corresponding types to the `t_resolved` set. If not found in the table, it simply adds the type to the set. The function returns a resolved list of basic types when there are no more updates, otherwise recursively calls itself with the updated list until all types are resolved. The code also defines two dictionaries: `类型泛化表` and `类型细分表`, which map generalized types to specific types and vice versa respectively.",
        "type": "comment"
    },
    "2786": {
        "file_id": 309,
        "content": "/microgrid_base/type_system.md",
        "type": "filepath"
    },
    "2787": {
        "file_id": 309,
        "content": "This code establishes rules and formats for microgrid devices, connections, and merging lines. It associates parameters with topology IDs and anchors, representing distinct points using one-to-one mapping. Three methods are used to represent connection relationships based on varying length topology ID groups.",
        "type": "summary"
    },
    "2788": {
        "file_id": 309,
        "content": "# 文件内容格式\n|  文件名  |  内容  | 格式 |\n| -- | -- | -- |\n| microgrid_v2_all_types_structured.json | 类型分类表（不包含设备名称） |  分类->能源->类型  |\n| microgrid_v2_connectivity_matrix.json |  连接类型映射表  | \"端点1_端点2\"->生成连接类型  |\n| microgrid_v2_device_port_type_mapping.json |  设备锚点类型表  |  设备分类->设备名称->锚点名称->锚点类型  |\n# 类型命名规则\n类型分为设备类型、设备锚点类型、母线类型、连接线类型、合并线类型。\n设备类型和设备名称一致。\n对于母线类型、连接线类型、合并线类型，有以下规则：\n## 前缀\n1. \"可合并\"开头的是合并线类型。\n2. \"可连接\"开头的是母线类型。\n3. \"不可连接\"开头的是连接线类型。\n除以上三种前缀以外，是设备锚点类型。\n## 后缀\n连接线类型中，\"输入\"/\"输出\"/\"输入输出\"结尾的是设备锚点和母线之间的连线类型，其余为设备锚点之间的连线类型。\n# 连接规则\n1. 设备（包括母线）不能和自己相连（同一个设备的锚点之间不能相连）。\n2. 设备每个锚点最多出来一根线。\n3. 两个母线之间最多有一根合并线。\n4. 两个设备锚点相连，判断是否可以连接，如果可以，产生对应类型的连接线。\n# 类型生成规则\n1. 母线以及用合并线与之相连的所有母线在没有设备锚点与之相连时，这些母线和合并线的类型分别为\"可连接母线\"和\"可合并母线\"(默认空类型)。\n2. 母线以及用合并线与之相连的所有母线若是默认类型，和设备锚点相连时，根据规则自动转换类型。\n3. 母线以及用合并线与之相连的所有母线若是默认类型，用合并线和其他非默认类型的母线相连时，类型自动变化。\n4. 母线最多有99个与之相连的线。\n----\n1. 合并线两端如果都是默认类型母线，则合并线是默认类型。\n2. 合并线两端如果只有一端是默认类型母线，合并线类型和默认类型母线的类型自动转换。\n3. 合并线两端如果都不是默认类型母线，检查两类型是否一致，如果一致则建立连接，否则连接失败。\n# 数据表示规则\n向算法发送数据时，需要全局信息（气象信息、设备信息、负荷信息、计算设置）、拓扑信息和连接关系。\n拓扑信息包括拓扑设备参数、ID-类型对。",
        "type": "code",
        "location": "/microgrid_base/type_system.md:1-53"
    },
    "2789": {
        "file_id": 309,
        "content": "Code explains the organization and rules for microgrid device types, connection types, and merging lines. It details file formats, naming conventions, connection rules, type generation rules, and data representation guidelines.",
        "type": "comment"
    },
    "2790": {
        "file_id": 309,
        "content": "拓扑设备参数和设备拓扑ID以及设备锚点ID相关联。\nID-类型对是一对一的映射，表示不同的ID代表点的不同类型，其中点可以是设备、设备锚点、母线、连接线、合并线。\n连接关系有三种表示方法，分别对应三种不同长度的拓扑ID组：\n1. 设备ID->设备锚点ID—>连接线ID->设备锚点ID->设备ID\n1. 设备ID->设备锚点ID—>连接线ID->母线ID\n1. 母线ID—>合并线ID->母线ID",
        "type": "code",
        "location": "/microgrid_base/type_system.md:55-63"
    },
    "2791": {
        "file_id": 309,
        "content": "The code associates topology device parameters, device topology ID, and anchor point ID. It maps ID-type pairs as a one-to-one relationship, representing different IDs for distinct points such as devices, device anchors, conductors, or junction lines. Three methods represent connection relationships based on varying length topology ID groups: 1) Device ID -> Anchor Point ID -> Connector ID -> Anchor Point ID -> Device ID; 2) Device ID -> Anchor Point ID -> Connector ID -> Bus Bar ID; and 3) Bus Bar ID -> Merging Line ID -> Bus Bar ID.",
        "type": "comment"
    },
    "2792": {
        "file_id": 310,
        "content": "/microgrid_base/type_system.py",
        "type": "filepath"
    },
    "2793": {
        "file_id": 310,
        "content": "The code manages device ports, connection lines, and microgrid types, ensuring uniqueness and raising exceptions. It transforms data structures, logs information, reads CSV files, creates DataFrames, defines mappings, converts ports, populates dictionaries, handles errors, and visualizes graphs for analysis.",
        "type": "summary"
    },
    "2794": {
        "file_id": 310,
        "content": "from log_utils import logger_print\n# 风力、光伏、柴油机 增加不可连接的线 删除变流器节点的不可连接线\n# 增加变流器和不可连接母线的连接\nimport rich\n# 区分设备端口和连接线 端口是点 连接线是边\n# 给所有不可连接线增加随机hash值 方便观察\nPLOT_ONLY = False\n# from turtle import backward\n# import pandas\nimport uuid\nhash_set = set()\ndef get_uniq_hash():\n    while True:\n        mhash = str(uuid.uuid4()).split(\"-\")[0][:2]\n        if mhash not in hash_set:\n            hash_set.add(mhash)\n            return mhash\noutput_path = \"microgrid_type_system.xlsx\"\nsheet1_name = \"类型连接矩阵\"\nsheet2_name = \"设备端口类型表\"\n# 母线输入 = 0\n# 母线输出 = 0\n# 储能端输入输出 = 1\n# 双向变流器输入输出 = 1\n# 可连接母线 = 2\n# 不可连接母线 = 2\n# 可连接供电端母线 = 3\n# 不可连接供电端母线 = 3\n# 可连接储能端母线 = 4\n# 不可连接储能端母线 = 4\n# 供电端输出,变流器输入 = 0\ndef revert_dict(mdict: dict):\n    result = {e: k for k, v in mdict.items() for e in v}\n    return result\ndef check_valid_type_base_name(type_base_name):\n    try:\n        assert \"输\" not in type_base_name\n        assert \"出\" not in type_base_name\n        assert \"入\" not in type_base_name\n    except:\n        raise Exception(\"Invalid type base name:\", type_base_name)\n    return type_base_name.strip()",
        "type": "code",
        "location": "/microgrid_base/type_system.py:1-58"
    },
    "2795": {
        "file_id": 310,
        "content": "The code defines functions for type system management in a microgrid. It handles device ports and connection lines, assigns unique hashes to non-connecting wires, and specifies device types and their input/output connections. The code also includes functions for revert dictionary, checking valid type base name, and saving data to an Excel file.",
        "type": "comment"
    },
    "2796": {
        "file_id": 310,
        "content": "def Input(type_base_name):\n    type_base_name = check_valid_type_base_name(type_base_name)\n    return f\"{type_base_name.strip()}输入\"\ndef Output(type_base_name):\n    type_base_name = check_valid_type_base_name(type_base_name)\n    return f\"{type_base_name.strip()}输出\"\ndef IO(type_base_name):\n    type_base_name = check_valid_type_base_name(type_base_name)\n    return f\"{type_base_name.strip()}输入输出\"\nsource_coax_triplets = {  # Input, Output, ConnectionBaseName\n    \"电\": [(\"变流器\", \"供电端\", \"供电端母线\")],\n}\nsource_and_load_coax_triplets = {\n    \"电\": [(\"电母线\", \"电母线\", \"电母线\")],\n}\nload_coax_triplets = {  # Input, Output, ConnectionBaseName\n    \"电\": [\n        (\"负荷电\", \"变压器\", \"负荷电母线\"),\n    ],\n    \"柴油\": [\n        (\"柴油\", \"柴油\", \"柴油母线\"),\n    ],\n}\n# IO_1, IO_2, ConnectionBaseName\nio_storage_coax_triplets = {\"电\": [(\"电储能端\", \"双向变流器储能端\", \"电储能端母线\")]}\n#\nio_to_wire = {\"电\": [(\"双向变流器线路端\", \"电母线\")]}\ntypes = {}  # {str: set()}\nwire_types = {}\ntypes_connectivity_matrix = {}  # {frozenset([start, end]): generated_type}\ndef triplets_with_supertype(triplet_map, length=3):",
        "type": "code",
        "location": "/microgrid_base/type_system.py:61-105"
    },
    "2797": {
        "file_id": 310,
        "content": "This code defines functions to represent inputs, outputs, and I/O operations for various types. It also includes dictionaries representing coaxial triplet connections for source, load, and IO devices with specific types (e.g., \"电\" or \"柴油\"). The code further creates mappings between certain IO types and their associated wire types, as well as a function to generate a connectivity matrix based on the provided type mapping and length of triplets.",
        "type": "comment"
    },
    "2798": {
        "file_id": 310,
        "content": "    for supertype, triplet_list in triplet_map.items():\n        for triplet in triplet_list:\n            try:\n                assert len(triplet) == length\n            except:\n                logger_print()\n                logger_print(\"ERROR!\")\n                logger_print()\n                logger_print(triplet_map)\n                raise Exception(\n                    f\"Error when unpacking triplet map with length {length}.\",\n                )\n            yield (*triplet, supertype)\ndef get_types(is_wire):\n    if is_wire:\n        return wire_types\n    else:\n        return types\ndef get_other_sets(supertype, is_wire=False):\n    mtypes = get_types(is_wire)\n    other_sets = set([e for k in mtypes.keys() if k != supertype for e in types[k]])\n    return other_sets\ndef add_to_types(supertype, typename, is_wire=False):\n    mtypes = get_types(is_wire)\n    if mtypes.get(supertype, None) is None:\n        mtypes[supertype] = set()\n    if is_wire:\n        other_sets = set([e for k, v in types.items() for e in v])\n        wire_other_sets = get_other_sets(supertype, is_wire=is_wire)",
        "type": "code",
        "location": "/microgrid_base/type_system.py:106-141"
    },
    "2799": {
        "file_id": 310,
        "content": "This code seems to be a part of a type system in a microgrid management system. It checks the length of triplet lists in a map and yields a new list with supertype added to each triplet. The `get_types` function returns either wire types or non-wire types depending on the input parameter, and `get_other_sets` gets other sets based on a given supertype. Lastly, `add_to_types` adds a new type to the map based on the given supertype.",
        "type": "comment"
    }
}