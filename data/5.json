{
    "500": {
        "file_id": 66,
        "content": "# msc = 20\n# msc = 12\nmsc = 10\n# msc = 12\nsubsections = adaptive_piecewise_approximation(x, y, max_subsection_count=msc)\nprint(\"Subsections:\", subsections)\nprint(\"Subsection lengths:\", [(end-start) for start, end in subsections])",
        "type": "code",
        "location": "/microgrid_base/adaptive_sampling/test_bisect.py:61-67"
    },
    "501": {
        "file_id": 66,
        "content": "The code snippet adjusts the max subsection count for an adaptive piecewise approximation and prints the resulting subsections along with their lengths.",
        "type": "comment"
    },
    "502": {
        "file_id": 67,
        "content": "/microgrid_base/adaptive_sampling/test_decision_tree_linear_regression.py",
        "type": "filepath"
    },
    "503": {
        "file_id": 67,
        "content": "The code uses a Decision Tree Regressor for data segmentation and performs piecewise linear regression within each segment for accurate predictions. It then plots the original data as scattered points with the piecewise approximation as a line, labeling the axes and providing a title.",
        "type": "summary"
    },
    "504": {
        "file_id": 67,
        "content": "# we can use the pure endpoint average method, instead of solving the intersection, which can be undecidable in nature\n# TODO: free memory after fitting\nimport numpy as np\nfrom sklearn.tree import DecisionTreeRegressor\nfrom sklearn.linear_model import LinearRegression\nimport matplotlib.pyplot as plt\n# Generate sample data\n# TODO: ensure start & end points are preserved.\nx_start, x_end, sample_size = 0, 5000, 100\nx = np.linspace(x_start, x_end, sample_size)\n# x = np.linspace(0, 10, 100)\n# y = np.sin(x)\n# y = np.sin(x) + np.random.normal(0, 0.2, 100)\n# x = np.linspace(10, 1e5, 10000)\ny = x**2\n# Define the number of turning points and segments\nnum_turning_points = 3\nnum_segments = num_turning_points + 1\n# Fit a decision tree to segment the data\n# 2 -> 4\n# tree_model = DecisionTreeRegressor(criterion = 'absolute_error', max_depth=4)  # 4 -> 16\ntree_model = DecisionTreeRegressor(max_depth=4)  # 4 -> 16\n# tree_model = DecisionTreeRegressor(max_depth=20)  # 4 -> 16\n# tree_model = DecisionTreeRegressor(max_depth=12)  # 4 -> 16",
        "type": "code",
        "location": "/microgrid_base/adaptive_sampling/test_decision_tree_linear_regression.py:1-33"
    },
    "505": {
        "file_id": 67,
        "content": "This code is using a Decision Tree Regressor to segment sample data with different maximum depths. The goal is to fit the data into segments and find the appropriate number of turning points. The code generates sample data, defines the number of turning points and segments, fits a decision tree model, and plots the results. The TODO comments indicate potential improvements like freeing memory after fitting and ensuring start and end points are preserved.",
        "type": "comment"
    },
    "506": {
        "file_id": 67,
        "content": "# tree_model = DecisionTreeRegressor(max_depth=10)  # 4 -> 16\n# tree_model = DecisionTreeRegressor(max_depth=3)  # 4 -> 16\n# tree_model = DecisionTreeRegressor(max_depth=1) # 3 -> 8\n# tree_model = DecisionTreeRegressor(max_depth=num_segments)\ntree_model.fit(x.reshape(-1, 1), y)\n# Perform piecewise linear regression within each segment\nsegment_indices = tree_model.apply(x.reshape(-1, 1))\n# print(segment_indices)\n# breakpoint()\nsegind = np.zeros(100)\nactual_segments = -1\nlast_segind = -1\nfor index, i in enumerate(segment_indices.reshape(-1).tolist()):\n    if i != last_segind:\n        actual_segments += 1\n        last_segind = i\n    segind[index] = actual_segments\nlinear_models = []\nfor segment in range(actual_segments + 1):\n    segment_x = x[segind == segment]\n    segment_y = y[segind == segment]\n    # print('seg_x', segment_x)\n    # print('seg_y', segment_y)\n    linear_model = LinearRegression()\n    linear_model.fit(segment_x.reshape(-1, 1), segment_y)\n    linear_models.append(linear_model)\n# Generate predictions for the piecewise approximation",
        "type": "code",
        "location": "/microgrid_base/adaptive_sampling/test_decision_tree_linear_regression.py:34-66"
    },
    "507": {
        "file_id": 67,
        "content": "Code snippet trains a decision tree regressor with varying maximum depth values and then performs piecewise linear regression within each segment generated by the decision tree. It creates separate linear regression models for each identified segment and generates predictions using these models.",
        "type": "comment"
    },
    "508": {
        "file_id": 67,
        "content": "x_pred = np.linspace(x_start, x_end, sample_size)\n# x_pred = np.linspace(0, 10, 100)\n# x_pred = np.linspace(0, 10, 1000)\ny_pred = np.zeros_like(x_pred)\nprint(\"SEGCOUNT:\", actual_segments + 1)\nfor segment in range(actual_segments + 1):\n    segment_indices = segind == segment\n    # print(\"segind\", segment_indices)\n    # segment_indices = tree_model.predict(x_pred.reshape(-1, 1)) == segment\n    y_pred[segment_indices] = linear_models[segment].predict(\n        x_pred[segment_indices].reshape(-1, 1)\n    )\n# Plot the original data and the piecewise approximation\nplt.scatter(x, y, label=\"Original Data\")\nplt.plot(x_pred, y_pred, label=\"Piecewise Approximation\")\nplt.legend()\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.title(\"Piecewise Function Approximation\")\nplt.show()",
        "type": "code",
        "location": "/microgrid_base/adaptive_sampling/test_decision_tree_linear_regression.py:67-88"
    },
    "509": {
        "file_id": 67,
        "content": "This code creates evenly spaced x-values between two limits (x\\_start and x\\_end) over a specified number of samples. It then initializes y\\_pred to the same size as x\\_pred with zeros. The code prints \"SEGCOUNT\" representing the actual segments plus one, and iterates through each segment using a for loop. For each segment, it selects the indices where segind matches the current segment and uses these indices to predict values from linear_models[segment] for the selected x-values. Finally, it plots the original data as scattered points and the piecewise approximation as a line, labeling the axes and providing a title before displaying the plot.",
        "type": "comment"
    },
    "510": {
        "file_id": 68,
        "content": "/microgrid_base/adaptive_sampling/test_get_breakpoints.py",
        "type": "filepath"
    },
    "511": {
        "file_id": 68,
        "content": "The code generates sample data, defines a decision tree regressor model with dynamic max depth, performs piecewise linear regression, finds breakpoints using linear regression, generates average x and y values between them, plots the original data and piecewise approximation, and labels axes and legend.",
        "type": "summary"
    },
    "512": {
        "file_id": 68,
        "content": "# we can use the pure endpoint average method, instead of solving the intersection, which can be undecidable in nature\n# TODO: free memory after fitting\nimport numpy as np\n# from sklearn.ensemble import RandomForestRegressor\nfrom sklearn.tree import DecisionTreeRegressor\nfrom sklearn.linear_model import LinearRegression\nimport matplotlib.pyplot as plt\n# Generate sample data\n# TODO: ensure start & end points are preserved.\n# x_start, x_end, sample_size = -500, 500, 100\nx_start, x_end, sample_size = 10, 5000, 100\n# x_start, x_end, sample_size = 0, 5000, 100\nx = np.linspace(x_start, x_end, sample_size)\n_y = x**2\n# _y = np.sin(x)\n# _y = np.sin(x) + np.random.normal(0, 0.2, 100)\n# let's take derivative instead.\ny_der = np.diff(_y)\n# y_der_sqrt = np.sqrt(np.abs(y_der))\n# y = np.append(y_der_sqrt, y_der_sqrt[-1])\ny = np.append(y_der, y_der[-1])\n# print(y)\n# must_include_points = [(0,0)]\n# still it might misalign\n# inversion method:\n# total-x\n# (total-x)/x\n# 1/x\nx_start, y_start = x[0], _y[0]\nx_end, y_end = x[-1], _y[-1]\n# x_start, y_start = x[0], y[0]",
        "type": "code",
        "location": "/microgrid_base/adaptive_sampling/test_get_breakpoints.py:1-43"
    },
    "513": {
        "file_id": 68,
        "content": "The code is importing necessary libraries and defining variables for generating sample data. It generates a linearly increasing x-axis from x_start to x_end with sample_size intervals, calculates the corresponding y values using a function, and takes the derivative of y to create y_der. It also includes comments on potential alternative approaches and data manipulation.",
        "type": "comment"
    },
    "514": {
        "file_id": 68,
        "content": "# x_end, y_end = x[-1], y[-1]\n# Define the number of turning points and segments\n# max_depth = 2\n# max_depth = 6\nmax_depth = 3\n# max_depth = 5\n# max_depth = 4\ntree_model = DecisionTreeRegressor(max_depth=max_depth)  # shall you invert the loss\n# tree_model = RandomForestRegressor(max_depth=max_depth)\ntree_model.fit(x.reshape(-1, 1), y)\n# tree_model.fit(x.reshape(-1, 1), y)\n# Perform piecewise linear regression within each segment\nsegment_indices = tree_model.apply(x.reshape(-1, 1))\nprint(segment_indices)\n# breakpoint()\nsegind = np.zeros(100)\nactual_segments = -1\nlast_segind = -1\nfor index, i in enumerate(segment_indices.reshape(-1).tolist()):\n    if i != last_segind:\n        actual_segments += 1\n        last_segind = i\n    segind[index] = actual_segments\nlinear_models = []\nbreakpoints_left = []\nbreakpoints_right = []\nseglens = []\nfor segment in range(actual_segments + 1):\n    segment_x = x[segind == segment]\n    seglens.append(len(segment_x))\n    segment_y = _y[segind == segment]\n    # segment_y = y[segind == segment]",
        "type": "code",
        "location": "/microgrid_base/adaptive_sampling/test_get_breakpoints.py:44-86"
    },
    "515": {
        "file_id": 68,
        "content": "This code dynamically sets the maximum depth of a decision tree regressor, fits the model on reshaped x and y data, performs piecewise linear regression within each segment based on the fitted model, assigns segment indices to each point, creates a list of segment lengths for further calculations.",
        "type": "comment"
    },
    "516": {
        "file_id": 68,
        "content": "    bx_l, bx_r = segment_x[0], segment_x[-1]\n    # print('seg_x', segment_x)\n    # print('seg_y', segment_y)\n    linear_model = LinearRegression()\n    linear_model.fit(segment_x.reshape(-1, 1), segment_y)\n    # pred_y = linear_model.predict(np.array([bx_l, bx_r]).reshape(-1,1))\n    # print(pred_y, pred_y.shape)\n    by_l, by_r = linear_model.predict(np.array([bx_l, bx_r]).reshape(-1, 1))\n    # by_l, by_r = ..., ...\n    breakpoints_left.append((bx_l, by_l))\n    breakpoints_right.append((bx_r, by_r))\n    # breakpoint()\n    linear_models.append(linear_model)\nactual_points = [(x_start, y_start)]\nprint(\"segment lengths:\",seglens)\nfor next_left, last_right in zip(breakpoints_left[1:], breakpoints_right[:-1]):\n    x_nl, y_nl = next_left\n    x_lr, y_lr = last_right\n    avg_x, avg_y = (x_nl + x_lr) / 2, (y_nl + y_lr) / 2\n    # avg_x, avg_y = (x_nl + x_lr) / 2, (y_nl + y_lr) / 2\n    actual_points.append((avg_x, avg_y))\nactual_points.append((x_end, y_end))\n# actual_points.extend(must_include_points)\n# actual_points.sort(key=lambda x: x[0])",
        "type": "code",
        "location": "/microgrid_base/adaptive_sampling/test_get_breakpoints.py:87-114"
    },
    "517": {
        "file_id": 68,
        "content": "This code segment is used to find breakpoints and generate a list of actual points for plotting. It uses linear regression to predict y values at given x values and calculates average x and y values between consecutive breakpoints. The actual_points list is then updated with these averages and the final endpoint coordinates.",
        "type": "comment"
    },
    "518": {
        "file_id": 68,
        "content": "actual_points = np.array(actual_points)\nx_pred, y_pred = actual_points[:, 0], actual_points[:, 1]\n# Plot the original data and the piecewise approximation\nplt.plot(x_pred, y_pred, label=\"Piecewise Approximation\", color=\"red\")\nplt.scatter(x, _y, label=\"Original Data\")\n# plt.scatter(x, y, label=\"Original Data\")\nplt.legend()\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.title(\"Piecewise Function Approximation\")\nplt.show()",
        "type": "code",
        "location": "/microgrid_base/adaptive_sampling/test_get_breakpoints.py:116-127"
    },
    "519": {
        "file_id": 68,
        "content": "This code plots the original data as scatter points and the piecewise approximation as a red line. It labels the axes, adds a legend, and displays the plot.",
        "type": "comment"
    },
    "520": {
        "file_id": 69,
        "content": "/microgrid_base/adaptive_sampling/test_mlinsights.py",
        "type": "filepath"
    },
    "521": {
        "file_id": 69,
        "content": "This code demonstrates PiecewiseRegressor's usage by generating sample data, splitting it into train and test sets, fitting a piecewise model using DecisionTreeRegressor as the binner, and visualizing predictions. It uses matplotlib to display the plot titled \"Piecewise Linear Regression\\n2 buckets\".",
        "type": "summary"
    },
    "522": {
        "file_id": 69,
        "content": "# ref: http://www.xavierdupre.fr/app/mlinsights/helpsphinx/notebooks/piecewise_linear_regression.html\nimport numpy\nimport numpy.random as npr\nimport matplotlib.pyplot as plt\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.tree import DecisionTreeRegressor\nfrom sklearn.preprocessing import KBinsDiscretizer\nfrom sklearn.dummy import DummyRegressor\nfrom mlinsights.mlmodel import PiecewiseRegressor\nX = npr.normal(size=(1000, 4))\nalpha = [4, -2]\nt = (X[:, 0] + X[:, 3] * 0.5) > 0\nswitch = numpy.zeros(X.shape[0])\nswitch[t] = 1\ny = alpha[0] * X[:, 0] * t + alpha[1] * X[:, 0] * (1 - t) + X[:, 2]\nfig, ax = plt.subplots(1, 1)\nax.plot(X[:, 0], y, \".\")\nax.set_title(\"Piecewise examples\")\nX_train, X_test, y_train, y_test = train_test_split(X[:, :1], y)\nmodel = PiecewiseRegressor(\n    verbose=True, binner=DecisionTreeRegressor(min_samples_leaf=300)\n)\nmodel.fit(X_train, y_train)\npred = model.predict(X_test)\n# pred[:5]\nfig, ax = plt.subplots(1, 1)\nax.plot(X_test[:, 0], y_test, \".\", label=\"data\")\nax.plot(X_test[:, 0], pred, \".\", label=\"predictions\")",
        "type": "code",
        "location": "/microgrid_base/adaptive_sampling/test_mlinsights.py:1-32"
    },
    "523": {
        "file_id": 69,
        "content": "This code demonstrates the usage of PiecewiseRegressor from mlinsights library. It generates sample data, splits it into train and test sets, fits a piecewise regression model using DecisionTreeRegressor as the binner, and visualizes the predictions compared to the actual data.",
        "type": "comment"
    },
    "524": {
        "file_id": 69,
        "content": "ax.set_title(\"Piecewise Linear Regression\\n2 buckets\")\nax.legend()\nplt.show()",
        "type": "code",
        "location": "/microgrid_base/adaptive_sampling/test_mlinsights.py:33-36"
    },
    "525": {
        "file_id": 69,
        "content": "This code sets the title of the plot to \"Piecewise Linear Regression\\n2 buckets\", adds a legend, and displays the plot using matplotlib's plt.show().",
        "type": "comment"
    },
    "526": {
        "file_id": 70,
        "content": "/microgrid_base/adaptive_sampling/test_np_piecewise_curve_fit.py",
        "type": "filepath"
    },
    "527": {
        "file_id": 70,
        "content": "The code imports necessary libraries, defines x and y arrays representing a dataset, creates a piecewise linear function, uses optimize.curve_fit to fit the data with the piecewise linear model, generates a plot of the original data points and the fitted curve on the same graph, and displays the resulting plot.",
        "type": "summary"
    },
    "528": {
        "file_id": 70,
        "content": "from scipy import optimize\nimport matplotlib.pyplot as plt\nimport numpy as np\nx = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ,11, 12, 13, 14, 15], dtype=float)\ny = np.array([5, 7, 9, 11, 13, 15, 28.92, 42.81, 56.7, 70.59, 84.47, 98.36, 112.25, 126.14, 140.03])\ndef piecewise_linear(x, x0, y0, k1, k2):\n    return np.piecewise(x, [x < x0, x >= x0], [lambda x:k1*x + y0-k1*x0, lambda x:k2*x + y0-k2*x0])\np , e = optimize.curve_fit(piecewise_linear, x, y)\nxd = np.linspace(0, 15, 100)\nplt.plot(x, y, \"o\")\nplt.plot(xd, piecewise_linear(xd, *p))\nplt.show()",
        "type": "code",
        "location": "/microgrid_base/adaptive_sampling/test_np_piecewise_curve_fit.py:1-15"
    },
    "529": {
        "file_id": 70,
        "content": "The code imports necessary libraries, defines x and y arrays representing a dataset, creates a piecewise linear function, uses optimize.curve_fit to fit the data with the piecewise linear model, generates a plot of the original data points and the fitted curve on the same graph, and displays the resulting plot.",
        "type": "comment"
    },
    "530": {
        "file_id": 71,
        "content": "/microgrid_base/adaptive_sampling/test_piecewise_regression.py",
        "type": "filepath"
    },
    "531": {
        "file_id": 71,
        "content": "This code imports piecewise_regression and uses it to fit a sinusoidal function with adjustable breakpoints, then plots the data, fit, breakpoints, and confidence intervals. The number of breakpoints can be adjusted for better or worse fits, but too many may lead to non-convergence and instability.",
        "type": "summary"
    },
    "532": {
        "file_id": 71,
        "content": "import piecewise_regression\nimport numpy as np\nx_start, x_end, sample_size =0, 5000, 100\n# x_start, x_end, sample_size = -500,500 , 100\nx = np.linspace(x_start, x_end, sample_size)\n# y = x**2\ny = np.sin(x)\nnb =12\n# nb =5\n# this is even.\n# slow? before compilation\n# sometimes the algo does not converge. dangerous.\npw_fit = piecewise_regression.Fit(x, y, n_breakpoints=nb)\n# pw_fit.summary()\nimport matplotlib.pyplot as plt\n# Plot the data, fit, breakpoints and confidence intervals\npw_fit.plot_data(color=\"grey\", s=20)\n# Pass in standard matplotlib keywords to control any of the plots\npw_fit.plot_fit(color=\"red\", linewidth=4)\npw_fit.plot_breakpoints()\npw_fit.plot_breakpoint_confidence_intervals()\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.show()\n# plt.close()",
        "type": "code",
        "location": "/microgrid_base/adaptive_sampling/test_piecewise_regression.py:1-31"
    },
    "533": {
        "file_id": 71,
        "content": "This code imports piecewise_regression and uses it to fit a sinusoidal function with adjustable breakpoints, then plots the data, fit, breakpoints, and confidence intervals. The number of breakpoints can be adjusted for better or worse fits, but too many may lead to non-convergence and instability.",
        "type": "comment"
    },
    "534": {
        "file_id": 72,
        "content": "/microgrid_base/adaptive_sampling/test_shift.py",
        "type": "filepath"
    },
    "535": {
        "file_id": 72,
        "content": "The function iteratively shifts subsections of data to optimize the region with lowest error, using adaptive sampling and calculating overall error for comparison.",
        "type": "summary"
    },
    "536": {
        "file_id": 72,
        "content": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\ndef fit_and_get_error(x, y, region):\n    start, end = region\n    model = LinearRegression()\n    model.fit(x[start : end + 1].reshape(-1, 1), y[start : end + 1])\n    # Calculate the predicted values\n    y_pred = model.predict(x[start : end + 1].reshape(-1, 1))\n    # Calculate the error (element-wise)\n    error = np.abs(y[start : end + 1] - y_pred)\n    return np.sum(error)\ndef perform_shift(x, y, left_region, right_region):\n    # either return one or two regions after shifting\n    left_start, _ = left_region\n    _, right_end = right_region\n    merged_region = (left_start, right_end)\n    regions_to_error = [(merged_region, fit_and_get_error(x, y, merged_region))]\n    for i in range(right_end - left_start - 2):\n        new_left_start = left_start + i + 1\n        new_right_start = new_left_start + 1\n        new_left_region = (left_start, new_left_start)\n        new_right_region = (new_right_start, right_end)\n        left_error = fit_and_get_error(x, y, new_left_region)",
        "type": "code",
        "location": "/microgrid_base/adaptive_sampling/test_shift.py:1-31"
    },
    "537": {
        "file_id": 72,
        "content": "This function performs a shift in the data and calculates errors for different regions, aiming to optimize the region with lowest error.",
        "type": "comment"
    },
    "538": {
        "file_id": 72,
        "content": "        right_error = fit_and_get_error(x, y, new_right_region)\n        total_error = left_error + right_error\n        regions_to_error.append(((new_left_region, new_right_region), total_error))\n    regions_to_error.sort(key=lambda x: x[1])\n    # print(regions_to_error)\n    regions = regions_to_error[0][0]\n    regions = list(regions)\n    return regions\nimport copy\n# Iterative shifting of breakpoints\ndef shifting_approximation(x, y, subsections: list[tuple[float, float]]):\n    assert (\n        len(subsections) >= 2\n    ), f\"cannot merge subsections because you only have one or less section.\\npassed: {subsections}\"\n    subsections = [(x, y) for x, y in subsections]\n    subsections.sort(key=lambda x: x[0])\n    last_sections = []\n    current_sections = copy.deepcopy(subsections)\n    # Iterate until the maximum subsection count is reached\n    # i = 0\n    while set(last_sections) != set(current_sections):\n        # print(f'iteration: #{i}')\n        # i+=1\n        last_sections = copy.deepcopy(current_sections)\n        left_region = current_sections[0]",
        "type": "code",
        "location": "/microgrid_base/adaptive_sampling/test_shift.py:32-63"
    },
    "539": {
        "file_id": 72,
        "content": "Function for iteratively shifting breakpoints based on subsections of x and y data. Continues until maximum subsection count is reached or no change in subsections.",
        "type": "comment"
    },
    "540": {
        "file_id": 72,
        "content": "        right_region = current_sections[1]\n        new_subsections = perform_shift(x, y, left_region, right_region)\n        for candidate in current_sections[2:]:\n            last_new_candidate = new_subsections.pop(-1)\n            outputs = perform_shift(x, y, last_new_candidate, candidate)\n            new_subsections.extend(outputs)\n        # Update the subsections\n        current_sections = new_subsections\n    return current_sections\n# Example usage\nx = np.linspace(0, 10, 100)\ny = x**2\n# y = np.sin(x)\ndef get_overall_error(x, y, regions):\n    error = 0\n    for region in regions:\n        error += fit_and_get_error(x, y, region)\n    return error\n# randomize and shift?\nimport random\ndef get_random_regions(population, size):\n    start = 0\n    end = population -1\n    candidates = list(range(1, population-1))\n    assert len(candidates) > 0, f\"wrong population and size: ({population}, {size})\"\n    chosen = random.sample(candidates, k=size)\n    chosen.sort()\n    ret = []\n    for _s, _e in zip([start, *chosen[:-1]], [*chosen[1:], end]):",
        "type": "code",
        "location": "/microgrid_base/adaptive_sampling/test_shift.py:64-102"
    },
    "541": {
        "file_id": 72,
        "content": "This function performs adaptive sampling by shifting subsections within three given sections. It takes x and y as input, along with current_sections, and returns updated current_sections after performing shifts. The fit_and_get_error function is used to calculate the error for each region. The function also includes examples of getting random regions, which can be useful for implementing adaptive sampling strategies.",
        "type": "comment"
    },
    "542": {
        "file_id": 72,
        "content": "        ret.append((_s, _e))\n    return ret\nregion_to_size = lambda regions: [y - x for x, y in regions]\n# no better than uniform regions\nsubsections = get_random_regions(100, 10)\n# 6.52 -> 6.52\n# subsections = [(i * 10, (i + 1) * 10 - 1) for i in range(10)]\n# 5.76 -> 4.54\n# subsections = [(0, 6), (7, 12), (13, 24), (25, 31), (32, 37), (38, 49), (50, 56), (57, 62), (63, 74), (75, 81), (82, 87), (88, 99)]\n# 7.94 -> 7.10\n# subsections = [(0, 6), (7, 12), (13, 24), (25, 31), (32, 37), (38, 49), (50, 62), (63, 74), (75, 87), (88, 99)]\nprint(\n    \"Before:\",\n    subsections,\n    region_to_size(subsections),\n    get_overall_error(x, y, subsections),\n    sep=\"\\n\",\n)\nsubsections = shifting_approximation(x, y, subsections)\nprint(\n    \"After:\",\n    subsections,\n    region_to_size(subsections),\n    get_overall_error(x, y, subsections),\n    sep=\"\\n\",\n)",
        "type": "code",
        "location": "/microgrid_base/adaptive_sampling/test_shift.py:103-130"
    },
    "543": {
        "file_id": 72,
        "content": "This code calculates and prints the overall error for a set of subsections, then applies shifting approximation to improve the sections and recalculates the error. The code compares different methods of creating subsections and evaluates their effectiveness by measuring the overall error before and after the shifting approximation is applied.",
        "type": "comment"
    },
    "544": {
        "file_id": 73,
        "content": "/microgrid_base/adaptive_sampling/test_torchpwl.py",
        "type": "filepath"
    },
    "545": {
        "file_id": 73,
        "content": "The code imports the torchpwl library and creates a Piecewise Linear (PWL) function with 5 channels and 3 breakpoints. A random tensor x is generated, and the PWL function is applied to it, resulting in output tensor y.",
        "type": "summary"
    },
    "546": {
        "file_id": 73,
        "content": "import torchpwl\n# Create a PWL consisting of 3 segments for 5 channels - each channel will have its own PWL function.\npwl = torchpwl.PWL(num_channels=5, num_breakpoints=3)\nx = torch.Tensor(11, 5).normal_()\ny = pwl(x)",
        "type": "code",
        "location": "/microgrid_base/adaptive_sampling/test_torchpwl.py:1-6"
    },
    "547": {
        "file_id": 73,
        "content": "The code imports the torchpwl library and creates a Piecewise Linear (PWL) function with 5 channels and 3 breakpoints. A random tensor x is generated, and the PWL function is applied to it, resulting in output tensor y.",
        "type": "comment"
    },
    "548": {
        "file_id": 74,
        "content": "/microgrid_base/arbitrary_topology_generation.py",
        "type": "filepath"
    },
    "549": {
        "file_id": 74,
        "content": "The code uses the NetworkX library to create a graph with a maximum of 10 nodes, representing devices, and applies the Barabasi-Albert model to generate random connections. The resulting microgrid topology is displayed using matplotlib's pyplot library.",
        "type": "summary"
    },
    "550": {
        "file_id": 74,
        "content": "# from pyomo_environ import *\nfrom log_utils import logger_print\n# import networkx as nx\n# from aco_tsp import ACO, Graph\n# # define the set of nodes/devices\n# devices = ['Diesel source', 'Diesel generator', 'Solar power generator', 'Wind power generator', 'Power converter', 'Power lines', 'Power load']\n# # define the set of rules\n# rules = {\n#     'Diesel source': ['Diesel generator'],\n#     'Diesel generator': ['Power lines'],\n#     'Solar power generator': ['Power lines'],\n#     'Wind power generator': ['Power lines'],\n#     'Power converter': ['Power lines', 'Power load'],\n#     'Power lines': ['Diesel generator', 'Solar power generator', 'Wind power generator', 'Power converter'],\n#     'Power load': ['Power converter']\n# }\n# # define the graph\n# G = Graph(len(devices), devices)\n# # add edges based on the rules\n# for i in range(len(devices)):\n#     for j in range(i+1, len(devices)):\n#         if devices[j] in rules[devices[i]]:\n#             G.add_edge(i, j, 1)  # add an edge with cost 1 if the nodes can be connected",
        "type": "code",
        "location": "/microgrid_base/arbitrary_topology_generation.py:1-28"
    },
    "551": {
        "file_id": 74,
        "content": "This code defines a graph based on a set of nodes/devices and rules for connecting them. The graph represents connections between devices such as power lines, converters, loads, and generators. Edges are added between nodes if they can be connected according to the specified rules.",
        "type": "comment"
    },
    "552": {
        "file_id": 74,
        "content": "# # define the ACO parameters\n# aco = ACO(ants=10, generations=100, alpha=1.0, beta=10.0, rho=0.5, q=1.0)\n# # run the ACO algorithm to generate the graph\n# path, cost = aco.solve(G)\n# # convert the path to a NetworkX graph\n# edges = [(devices[path[i]], devices[path[i+1]]) for i in range(len(path)-1)]\n# G_nx = nx.Graph(edges)\n# # visualize the graph\n# nx.draw(G_nx, with_labels=True)\n# above code does not seem to be right.\n# the library is fictional.\n# TSP is not of our type of problem.\nimport networkx as nx\n# set the maximum number of nodes/devices\nmax_nodes = 10\n# create an empty graph\nG = nx.Graph()\n# add the initial nodes/devices\ndevices = [\n    \"Diesel source\",\n    \"Diesel generator\",\n    \"Solar power generator\",\n    \"Wind power generator\",\n    \"Power lines\",\n]\nG.add_nodes_from(devices)\n# add edges based on the rules\nG.add_edge(\"Diesel source\", \"Diesel generator\")\nG.add_edge(\"Diesel generator\", \"Power lines\")\nG.add_edge(\"Solar power generator\", \"Power lines\")\nG.add_edge(\"Wind power generator\", \"Power lines\")\nimport random",
        "type": "code",
        "location": "/microgrid_base/arbitrary_topology_generation.py:30-72"
    },
    "553": {
        "file_id": 74,
        "content": "The code generates a microgrid topology using NetworkX library, with maximum 10 nodes (devices) including Diesel source, Diesel generator, Solar power generator, Wind power generator, and Power lines. It creates an empty graph, adds initial nodes, and adds edges based on specific rules.",
        "type": "comment"
    },
    "554": {
        "file_id": 74,
        "content": "# use the BA model to add new nodes with connections\nfor i in range(len(devices), max_nodes):\n    G.add_node(i)\n    # connect to existing nodes with probability proportional to their degree\n    targets = list(G.nodes())\n    probabilities = [\n        deg / sum(dict(G.degree()).values()) for deg in dict(G.degree()).values()\n    ]\n    for j in range(len(targets)):\n        if i != targets[j]:\n            if random.choices(\n                [True, False], weights=[probabilities[j], 1 - probabilities[j]], k=1\n            )[0]:\n                # if nx.utils.random.choice([True, False], p=[probabilities[j], 1-probabilities[j]]):\n                G.add_edge(i, targets[j])\nimport matplotlib.pyplot as plt\nnx.draw(G, with_labels=True)\nplt.show()",
        "type": "code",
        "location": "/microgrid_base/arbitrary_topology_generation.py:74-93"
    },
    "555": {
        "file_id": 74,
        "content": "This code segment utilizes the Barabasi-Albert (BA) model to generate a random graph with new nodes and connections. It iterates over each node, adding it to the graph and connecting it to existing nodes based on their degree probability. The resulting graph is then displayed using matplotlib's pyplot library.",
        "type": "comment"
    },
    "556": {
        "file_id": 75,
        "content": "/microgrid_base/celery_test.py",
        "type": "filepath"
    },
    "557": {
        "file_id": 75,
        "content": "This code loads and modifies a JSON file, sends POST requests to check/create tasks on server with specified IP & port based on test variable, and can parse the JSON data. It uses logging functionality and may interact with EnergyFlowGraph objects. Some commenting is missing or incomplete.",
        "type": "summary"
    },
    "558": {
        "file_id": 75,
        "content": "from log_utils import logger_print\nimport os\nos.environ[\"http_proxy\"] = \"\"\nos.environ[\"https_proxy\"] = \"\"\nos.environ[\"all_proxy\"] = \"\"\nimport json\nparsing = False\n# parsing = True\nwith open(\"template_input.json\", \"r\") as f:\n    mDictList = json.load(f)\n# 修改为环保目标\nmDictList[0][\"graph\"][\"计算目标\"] = \"环保\"\nimport requests\nport = 9870\n# ip = \"127.0.0.1\"\n# ip = \"43.192.122.65\"\nip = \"69.234.199.80\"\n# port = 9871\n# ip = \"192.168.3.10\"\nurl = f\"http://{ip}:{port}/calculate_async\"\nresult_url = f\"http://{ip}:{port}/get_calculation_result_async\"\nstatus_url = f\"http://{ip}:{port}/get_calculation_state\"\n# test = \"create_task\"\ntest = \"check_result\"\n# test = \"check_status\"\ntask_id = \"9ebda25b-92f9-4b77-acc3-9c85c0cfefa9\"\n# task_id = \"914702ea-433c-4534-97ea-5cc619e37730\"\n# task_id = \"2533b339-86db-45bb-8d03-5d38ff9ff52c\"\ncheck_data = dict(calculation_id=task_id)\nif test == \"create_task\":\n    from fastapi_datamodel_template import EnergyFlowGraph\n    # from ies_optim import 设备节点\n    if parsing:\n        data = EnergyFlowGraph(mDictList=mDictList).dict()",
        "type": "code",
        "location": "/microgrid_base/celery_test.py:1-48"
    },
    "559": {
        "file_id": 75,
        "content": "This code is loading a JSON file named \"template_input.json\", modifying the calculation target to \"环保\" and then sending POST requests to check the result, status or create a task on a server at specified IP and port using the provided URLs. It also checks if a test variable equals \"create_task\", \"check_result\", or \"check_status\" to determine which request to send. If parsing is enabled, it converts the JSON data into an EnergyFlowGraph object for further processing.",
        "type": "comment"
    },
    "560": {
        "file_id": 75,
        "content": "    else:\n        data = dict(mDictList=mDictList)\n    # mdata = mDictList[0]['nodes'][25] # 25-35\n    # import rich\n    # logger_print(mdata) # 设备\n    # r = requests.post(url, json=data.dict())\n    r = requests.post(url, json=data)\n    logger_print(r.json())\n    logger_print(r.status_code)\nelif test == \"check_result\":\n    r = requests.get(result_url, params=check_data)\n    logger_print(r.status_code)\n    logger_print(r.content)\n    output_path = \"output_template.json\"\n    logger_print(f\"writing to: {output_path}\")\n    with open(output_path, \"w+\") as f:\n        f.write(json.dumps(r.json(), indent=4, ensure_ascii=False))\nelif test == \"check_status\":\n    r = requests.get(status_url, params=check_data)\n    logger_print(r.status_code)\n    logger_print(r.content)\nelse:\n    raise Exception(\"TEST IS NOT CREATED:\", test)\n# t = 设备节点.parse_obj(mdata)\n# logger_print(t)",
        "type": "code",
        "location": "/microgrid_base/celery_test.py:49-73"
    },
    "561": {
        "file_id": 75,
        "content": "This code appears to be part of a larger program that sends requests to different URLs depending on the value of the 'test' variable. It uses the requests library to send POST and GET requests and handles various responses. The code also includes logging functionality, using logger_print(), and potentially interacts with JSON data. There is some commenting missing or incomplete, which could provide more clarity for future maintenance or review.",
        "type": "comment"
    },
    "562": {
        "file_id": 76,
        "content": "/microgrid_base/chatgpt_convert_latex_to_python/README.md",
        "type": "filepath"
    },
    "563": {
        "file_id": 76,
        "content": "This code suggests displaying examples of converting LaTeX formulas to Python code from previous work, and then using an API to convert new ones. It also provides a link for text fragment highlighting.",
        "type": "summary"
    },
    "564": {
        "file_id": 76,
        "content": "show some examples (from our previous work) on how to convert latex formulas to python code, then invoke api to convert new ones.\n[to highlight code](https://developer.mozilla.org/en-US/docs/Web/Text_fragments)\n```\nhttps://example.com#:~:text=[prefix-,]textStart[,textEnd][,-suffix]\n```",
        "type": "code",
        "location": "/microgrid_base/chatgpt_convert_latex_to_python/README.md:1-7"
    },
    "565": {
        "file_id": 76,
        "content": "This code suggests displaying examples of converting LaTeX formulas to Python code from previous work, and then using an API to convert new ones. It also provides a link for text fragment highlighting.",
        "type": "comment"
    },
    "566": {
        "file_id": 77,
        "content": "/microgrid_base/chatgpt_convert_latex_to_python/convert_code_to_webpage.cmd",
        "type": "filepath"
    },
    "567": {
        "file_id": 77,
        "content": "The code executes Python's pygments library, formatting the test_code.py file with full lexing and inline line numbers. It generates an HTML output file named \"test_code.html\" that includes the Python code with syntax highlighting.",
        "type": "summary"
    },
    "568": {
        "file_id": 77,
        "content": "python -m pygments -O full,linenos=inline,lineanchors=line,nobackground -f html -o test_code.html test_code.py",
        "type": "code",
        "location": "/microgrid_base/chatgpt_convert_latex_to_python/convert_code_to_webpage.cmd:1-1"
    },
    "569": {
        "file_id": 77,
        "content": "The code executes Python's pygments library, formatting the test_code.py file with full lexing and inline line numbers. It generates an HTML output file named \"test_code.html\" that includes the Python code with syntax highlighting.",
        "type": "comment"
    },
    "570": {
        "file_id": 78,
        "content": "/microgrid_base/chatgpt_convert_latex_to_python/example_snippet.md",
        "type": "filepath"
    },
    "571": {
        "file_id": 78,
        "content": "The code utilizes HTML, CSS and SymPy for syntax-highlighted text editors with symbolic math capabilities, Latex conversion, and creating functions.",
        "type": "summary"
    },
    "572": {
        "file_id": 78,
        "content": "# example snippet line 10-20\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01//EN\"\n   \"http://www.w3.org/TR/html4/strict.dtd\">\n<!--\ngenerated by Pygments <https://pygments.org/>\nCopyright 2006-2023 by the Pygments team.\nLicensed under the BSD license, see LICENSE for details.\n-->\n<html>\n<head>\n<title></title>\n<meta content=\"text/html; charset=utf-8\" http-equiv=\"content-type\"/>\n<style type=\"text/css\">\n/*\ngenerated by Pygments <https://pygments.org/>\nCopyright 2006-2023 by the Pygments team.\nLicensed under the BSD license, see LICENSE for details.\n*/\npre { line-height: 125%; }\ntd.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }\nspan.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }\ntd.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }\nspan.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }\nbody .hll { background-color: #ffffcc }",
        "type": "code",
        "location": "/microgrid_base/chatgpt_convert_latex_to_python/example_snippet.md:1-26"
    },
    "573": {
        "file_id": 78,
        "content": "This code is a generated HTML document for syntax highlighting using Pygments, with a CSS styling section. It sets the content type to UTF-8 and includes styling for line numbers and highlighted code sections.",
        "type": "comment"
    },
    "574": {
        "file_id": 78,
        "content": "body .c { color: #3D7B7B; font-style: italic } /* Comment */\nbody .err { border: 1px solid #FF0000 } /* Error */\nbody .k { color: #008000; font-weight: bold } /* Keyword */\nbody .o { color: #666666 } /* Operator */\nbody .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */\nbody .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */\nbody .cp { color: #9C6500 } /* Comment.Preproc */\nbody .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */\nbody .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */\nbody .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */\nbody .gd { color: #A00000 } /* Generic.Deleted */\nbody .ge { font-style: italic } /* Generic.Emph */\nbody .gr { color: #E40000 } /* Generic.Error */\nbody .gh { color: #000080; font-weight: bold } /* Generic.Heading */\nbody .gi { color: #008400 } /* Generic.Inserted */\nbody .go { color: #717171 } /* Generic.Output */\nbody .gp { color: #000080; font-weight: bold } /* Generic.Prompt */\nbody .gs { font-weight: bold } /* Generic.Strong */",
        "type": "code",
        "location": "/microgrid_base/chatgpt_convert_latex_to_python/example_snippet.md:27-44"
    },
    "575": {
        "file_id": 78,
        "content": "This code defines CSS styles for different syntax elements in a programming language or markdown. It categorizes them as comments, keywords, operators, and other special characters or sections, with distinct colors and formatting to improve readability.",
        "type": "comment"
    },
    "576": {
        "file_id": 78,
        "content": "body .gu { color: #800080; font-weight: bold } /* Generic.Subheading */\nbody .gt { color: #0044DD } /* Generic.Traceback */\nbody .kc { color: #008000; font-weight: bold } /* Keyword.Constant */\nbody .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */\nbody .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */\nbody .kp { color: #008000 } /* Keyword.Pseudo */\nbody .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */\nbody .kt { color: #B00040 } /* Keyword.Type */\nbody .m { color: #666666 } /* Literal.Number */\nbody .s { color: #BA2121 } /* Literal.String */\nbody .na { color: #687822 } /* Name.Attribute */\nbody .nb { color: #008000 } /* Name.Builtin */\nbody .nc { color: #0000FF; font-weight: bold } /* Name.Class */\nbody .no { color: #880000 } /* Name.Constant */\nbody .nd { color: #AA22FF } /* Name.Decorator */\nbody .ni { color: #717171; font-weight: bold } /* Name.Entity */\nbody .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */\nbody .nf { color: #0000FF } /* Name.Function */",
        "type": "code",
        "location": "/microgrid_base/chatgpt_convert_latex_to_python/example_snippet.md:45-62"
    },
    "577": {
        "file_id": 78,
        "content": "This code defines CSS styles for different syntax highlighting elements in a programming language. It sets the color and font-weight properties for constants, declarations, namespaces, keywords, pseudo, reserved words, types, literals (numbers and strings), attributes, built-ins, classes, exceptions, functions, and entities.",
        "type": "comment"
    },
    "578": {
        "file_id": 78,
        "content": "body .nl { color: #767600 } /* Name.Label */\nbody .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */\nbody .nt { color: #008000; font-weight: bold } /* Name.Tag */\nbody .nv { color: #19177C } /* Name.Variable */\nbody .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */\nbody .w { color: #bbbbbb } /* Text.Whitespace */\nbody .mb { color: #666666 } /* Literal.Number.Bin */\nbody .mf { color: #666666 } /* Literal.Number.Float */\nbody .mh { color: #666666 } /* Literal.Number.Hex */\nbody .mi { color: #666666 } /* Literal.Number.Integer */\nbody .mo { color: #666666 } /* Literal.Number.Oct */\nbody .sa { color: #BA2121 } /* Literal.String.Affix */\nbody .sb { color: #BA2121 } /* Literal.String.Backtick */\nbody .sc { color: #BA2121 } /* Literal.String.Char */\nbody .dl { color: #BA2121 } /* Literal.String.Delimiter */\nbody .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */\nbody .s2 { color: #BA2121 } /* Literal.String.Double */\nbody .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */",
        "type": "code",
        "location": "/microgrid_base/chatgpt_convert_latex_to_python/example_snippet.md:63-80"
    },
    "579": {
        "file_id": 78,
        "content": "Code snippet sets specific CSS styles for different code syntax elements, such as Names.Label, Namespace, Tag, Variable, Operator, Literal numbers, and strings.",
        "type": "comment"
    },
    "580": {
        "file_id": 78,
        "content": "body .sh { color: #BA2121 } /* Literal.String.Heredoc */\nbody .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */\nbody .sx { color: #008000 } /* Literal.String.Other */\nbody .sr { color: #A45A77 } /* Literal.String.Regex */\nbody .s1 { color: #BA2121 } /* Literal.String.Single */\nbody .ss { color: #19177C } /* Literal.String.Symbol */\nbody .bp { color: #008000 } /* Name.Builtin.Pseudo */\nbody .fm { color: #0000FF } /* Name.Function.Magic */\nbody .vc { color: #19177C } /* Name.Variable.Class */\nbody .vg { color: #19177C } /* Name.Variable.Global */\nbody .vi { color: #19177C } /* Name.Variable.Instance */\nbody .vm { color: #19177C } /* Name.Variable.Magic */\nbody .il { color: #666666 } /* Literal.Number.Integer.Long */\n  </style>\n</head>\n<body>\n<h2></h2>\n<div class=\"highlight\"><pre><span></span><a id=\"line-10\" name=\"line-10\"></a><span class=\"linenos\">10</span><span class=\"c1\"># a, b= sympy.symbols(\"a^b b\")</span>\n<a id=\"line-11\" name=\"line-11\"></a><span class=\"linenos\">11</span><span class=\"c1\"># r = sympy.Range(1,10)</span>",
        "type": "code",
        "location": "/microgrid_base/chatgpt_convert_latex_to_python/example_snippet.md:81-100"
    },
    "581": {
        "file_id": 78,
        "content": "This code snippet provides styling for a syntax-highlighted text editor using CSS classes. It sets different colors and font styles for various types of literals, names, and numbers in the source code. The code examples used are related to SymPy library functions and variables.",
        "type": "comment"
    },
    "582": {
        "file_id": 78,
        "content": "<a id=\"line-12\" name=\"line-12\"></a><span class=\"linenos\">12</span><span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">symbols</span><span class=\"p\">(</span><span class=\"s2\">\"b\"</span><span class=\"p\">,</span> <span class=\"n\">positive</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">integer</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<a id=\"line-13\" name=\"line-13\"></a><span class=\"linenos\">13</span><span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">IndexedBase</span><span class=\"p\">(</span><span class=\"s2\">\"a\"</span><span class=\"p\">)</span>\n<a id=\"line-14\" name=\"line-14\"></a><span class=\"linenos\">14</span><span class=\"n\">summation</span> <span class=\"o\">=</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">Sum</span><span class=\"p\">(</span>\n<a id=\"li",
        "type": "code",
        "location": "/microgrid_base/chatgpt_convert_latex_to_python/example_snippet.md:101-104"
    },
    "583": {
        "file_id": 78,
        "content": "Line 100-103: Defining symbols 'b' and 'a', where 'b' is a positive integer symbol and 'a' is an indexed base symbol. These will be used for further calculations in the code.",
        "type": "comment"
    },
    "584": {
        "file_id": 78,
        "content": "ne-15\" name=\"line-15\"></a><span class=\"linenos\">15</span>    <span class=\"n\">a</span><span class=\"p\">[</span><span class=\"n\">b</span><span class=\"p\">],</span>\n<a id=\"line-16\" name=\"line-16\"></a><span class=\"linenos\">16</span>    <span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">),</span>\n<a id=\"line-17\" name=\"line-17\"></a><span class=\"linenos\">17</span><span class=\"p\">)</span>\n<a id=\"line-18\" name=\"line-18\"></a><span class=\"linenos\">18</span><span class=\"c1\"># summation = sympy.Sum(a, (a, 1, b), r)</span>\n<a id=\"line-19\" name=\"line-19\"></a><span class=\"linenos\">19</span><span class=\"c1\"># summation = sympy.Sum(c[a], (a, 1, b), r)</span>\n<a id=\"line-20\" name=\"line-20\"></a><span class=\"linenos\">20</span><span class=\"c1\"># summation</span>\n</pre></div>\n</body>\n</html>\n# example\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01//EN\"\n   \"http://www.w3.org/TR/html4/strict.dtd\">\n<!--\ngenerated by Pygments <https://pygments.org/>",
        "type": "code",
        "location": "/microgrid_base/chatgpt_convert_latex_to_python/example_snippet.md:104-119"
    },
    "585": {
        "file_id": 78,
        "content": "This code snippet defines a function that takes in two variables 'a' and 'b', and returns the summation of 'c[a]' from index 1 to 'b'. It utilizes SymPy library for symbolic computation.",
        "type": "comment"
    },
    "586": {
        "file_id": 78,
        "content": "Copyright 2006-2023 by the Pygments team.\nLicensed under the BSD license, see LICENSE for details.\n-->\n<html>\n<head>\n  <title></title>\n  <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\">\n  <style type=\"text/css\">\n/*\ngenerated by Pygments <https://pygments.org/>\nCopyright 2006-2023 by the Pygments team.\nLicensed under the BSD license, see LICENSE for details.\n*/\npre { line-height: 125%; }\ntd.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }\nspan.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }\ntd.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }\nspan.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }\nbody .hll { background-color: #ffffcc }\nbody .c { color: #3D7B7B; font-style: italic } /* Comment */\nbody .err { border: 1px solid #FF0000 } /* Error */\nbody .k { color: #008000; font-weight: bold } /* Keyword */",
        "type": "code",
        "location": "/microgrid_base/chatgpt_convert_latex_to_python/example_snippet.md:120-141"
    },
    "587": {
        "file_id": 78,
        "content": "Code snippet contains CSS styles for formatting code syntax using Pygments, a popular syntax highlighter. It defines styles for keywords, comments, and errors in various programming languages.",
        "type": "comment"
    },
    "588": {
        "file_id": 78,
        "content": "body .o { color: #666666 } /* Operator */\nbody .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */\nbody .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */\nbody .cp { color: #9C6500 } /* Comment.Preproc */\nbody .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */\nbody .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */\nbody .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */\nbody .gd { color: #A00000 } /* Generic.Deleted */\nbody .ge { font-style: italic } /* Generic.Emph */\nbody .gr { color: #E40000 } /* Generic.Error */\nbody .gh { color: #000080; font-weight: bold } /* Generic.Heading */\nbody .gi { color: #008400 } /* Generic.Inserted */\nbody .go { color: #717171 } /* Generic.Output */\nbody .gp { color: #000080; font-weight: bold } /* Generic.Prompt */\nbody .gs { font-weight: bold } /* Generic.Strong */\nbody .gu { color: #800080; font-weight: bold } /* Generic.Subheading */\nbody .gt { color: #0044DD } /* Generic.Traceback */\nbody .kc { color: #008000; font-weight: bold } /* Keyword.Constant */",
        "type": "code",
        "location": "/microgrid_base/chatgpt_convert_latex_to_python/example_snippet.md:142-159"
    },
    "589": {
        "file_id": 78,
        "content": "This code is defining CSS styles for various syntax elements in a text editor. It specifies the colors and font styling for different types of comments, keywords, headings, output, and other generic text elements.",
        "type": "comment"
    },
    "590": {
        "file_id": 78,
        "content": "body .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */\nbody .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */\nbody .kp { color: #008000 } /* Keyword.Pseudo */\nbody .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */\nbody .kt { color: #B00040 } /* Keyword.Type */\nbody .m { color: #666666 } /* Literal.Number */\nbody .s { color: #BA2121 } /* Literal.String */\nbody .na { color: #687822 } /* Name.Attribute */\nbody .nb { color: #008000 } /* Name.Builtin */\nbody .nc { color: #0000FF; font-weight: bold } /* Name.Class */\nbody .no { color: #880000 } /* Name.Constant */\nbody .nd { color: #AA22FF } /* Name.Decorator */\nbody .ni { color: #717171; font-weight: bold } /* Name.Entity */\nbody .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */\nbody .nf { color: #0000FF } /* Name.Function */\nbody .nl { color: #767600 } /* Name.Label */\nbody .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */\nbody .nt { color: #008000; font-weight: bold } /* Name.Tag */",
        "type": "code",
        "location": "/microgrid_base/chatgpt_convert_latex_to_python/example_snippet.md:160-177"
    },
    "591": {
        "file_id": 78,
        "content": "This code defines CSS styles for different types of syntax elements in a programming language. Each selector specifies a color and font style for keywords, literals, names, and other elements to enhance readability and distinction in the source code.",
        "type": "comment"
    },
    "592": {
        "file_id": 78,
        "content": "body .nv { color: #19177C } /* Name.Variable */\nbody .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */\nbody .w { color: #bbbbbb } /* Text.Whitespace */\nbody .mb { color: #666666 } /* Literal.Number.Bin */\nbody .mf { color: #666666 } /* Literal.Number.Float */\nbody .mh { color: #666666 } /* Literal.Number.Hex */\nbody .mi { color: #666666 } /* Literal.Number.Integer */\nbody .mo { color: #666666 } /* Literal.Number.Oct */\nbody .sa { color: #BA2121 } /* Literal.String.Affix */\nbody .sb { color: #BA2121 } /* Literal.String.Backtick */\nbody .sc { color: #BA2121 } /* Literal.String.Char */\nbody .dl { color: #BA2121 } /* Literal.String.Delimiter */\nbody .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */\nbody .s2 { color: #BA2121 } /* Literal.String.Double */\nbody .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */\nbody .sh { color: #BA2121 } /* Literal.String.Heredoc */\nbody .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */\nbody .sx { color: #008000 } /* Literal.String.Other */",
        "type": "code",
        "location": "/microgrid_base/chatgpt_convert_latex_to_python/example_snippet.md:178-195"
    },
    "593": {
        "file_id": 78,
        "content": "This code defines CSS styles for various programming language syntax elements, used to highlight different types of code in an editor or IDE. It categorizes and colors different literals (like strings, numbers), variables, operators, and delimiters.",
        "type": "comment"
    },
    "594": {
        "file_id": 78,
        "content": "body .sr { color: #A45A77 } /* Literal.String.Regex */\nbody .s1 { color: #BA2121 } /* Literal.String.Single */\nbody .ss { color: #19177C } /* Literal.String.Symbol */\nbody .bp { color: #008000 } /* Name.Builtin.Pseudo */\nbody .fm { color: #0000FF } /* Name.Function.Magic */\nbody .vc { color: #19177C } /* Name.Variable.Class */\nbody .vg { color: #19177C } /* Name.Variable.Global */\nbody .vi { color: #19177C } /* Name.Variable.Instance */\nbody .vm { color: #19177C } /* Name.Variable.Magic */\nbody .il { color: #666666 } /* Literal.Number.Integer.Long */\n  </style>\n</head>\n<body>\n<h2></h2>\n<div class=\"highlight\"><pre><span></span><a id=\"line-1\" name=\"line-1\"></a><span class=\"linenos\"> 1</span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;first line&quot;</span><span class=\"p\">)</span>\n<a id=\"line-2\" name=\"line-2\"></a><span class=\"linenos\"> 2</span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&quot;second line&quot;</span><span class=\"p\">)</span>\n<a id=\"line-3\" name=\"line-3\"></a><span class=\"linenos\"> 3</span>",
        "type": "code",
        "location": "/microgrid_base/chatgpt_convert_latex_to_python/example_snippet.md:196-214"
    },
    "595": {
        "file_id": 78,
        "content": "This code snippet contains CSS styles for different programming elements and Python code examples. The CSS classes are used to assign specific colors for different types of literals, variables, functions, etc. The Python code consists of two print statements displaying \"first line\" and \"second line\".",
        "type": "comment"
    },
    "596": {
        "file_id": 78,
        "content": "<a id=\"line-4\" name=\"line-4\"></a><span class=\"linenos\"> 4</span><span class=\"kn\">import</span> <span class=\"nn\">sympy</span>\n<a id=\"line-5\" name=\"line-5\"></a><span class=\"linenos\"> 5</span>\n<a id=\"line-6\" name=\"line-6\"></a><span class=\"linenos\"> 6</span><span class=\"c1\"># ref: https://github.com/sympy/sympy/issues/9861</span>\n<a id=\"line-7\" name=\"line-7\"></a><span class=\"linenos\"> 7</span>\n<a id=\"line-8\" name=\"line-8\"></a><span class=\"linenos\"> 8</span><span class=\"c1\"># a, b= sympy.symbols(&quot;a b&quot;)</span>\n<a id=\"line-9\" name=\"line-9\"></a><span class=\"linenos\"> 9</span><span class=\"c1\"># a, b= sympy.symbols(&quot;a_b b&quot;)</span>\n<a id=\"line-10\" name=\"line-10\"></a><span class=\"linenos\">10</span><span class=\"c1\"># a, b= sympy.symbols(&quot;a^b b&quot;)</span>\n<a id=\"line-11\" name=\"line-11\"></a><span class=\"linenos\">11</span><span class=\"c1\"># r = sympy.Range(1,10)</span>\n<a id=\"line-12\" name=\"line-12\"></a><span class=\"linenos\">12</span><span class=\"n\">b</span> <span class=\"o\">=</span",
        "type": "code",
        "location": "/microgrid_base/chatgpt_convert_latex_to_python/example_snippet.md:215-223"
    },
    "597": {
        "file_id": 78,
        "content": "This code imports the Sympy library and provides comments that suggest using different symbol naming conventions for variables 'a' and 'b'. It also mentions a comment about creating a range of numbers from 1 to 10.",
        "type": "comment"
    },
    "598": {
        "file_id": 78,
        "content": "> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">symbols</span><span class=\"p\">(</span><span class=\"s2\">&quot;b&quot;</span><span class=\"p\">,</span> <span class=\"n\">positive</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">integer</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<a id=\"line-13\" name=\"line-13\"></a><span class=\"linenos\">13</span><span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">IndexedBase</span><span class=\"p\">(</span><span class=\"s2\">&quot;a&quot;</span><span class=\"p\">)</span>\n<a id=\"line-14\" name=\"line-14\"></a><span class=\"linenos\">14</span><span class=\"n\">summation</span> <span class=\"o\">=</span> <span class=\"n\">sympy</span><span class=\"o\">.</span><span class=\"n\">Sum</span><span class=\"p\">(</span>\n<a id=\"line-15\" name=\"line-15\"></a><span class=\"linenos\">15</span>    <span class=\"n\">a</span><span class=\"p\">[</span><span class=\"n\">b</span><span class=\"p\">],</span>",
        "type": "code",
        "location": "/microgrid_base/chatgpt_convert_latex_to_python/example_snippet.md:223-226"
    },
    "599": {
        "file_id": 78,
        "content": "The code creates a SymPy symbol 'b' which is positive and an integer. Then, it defines an IndexedBase 'a' and uses SymPy's Sum function to create a summation expression with index 'b'.",
        "type": "comment"
    }
}