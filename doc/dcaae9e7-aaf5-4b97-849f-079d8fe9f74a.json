{
    "summary": "The code reads configuration files for microgrid simulation, preprocesses data to create an interface set and connection type mapping table. It filters unwhitelisted devices and creates a device library by iterating over a dictionary, identifying specific keys and their types.",
    "details": [
        {
            "comment": "The code reads configuration files and populates necessary data structures for the microgrid simulation. It imports necessary functions and modules, reads JSON files containing translation tables, connection type mapping, device port type mapping, and Jinja parameter base file. The code then processes this information to create a classified set of types based on anchor points or devices and their associated ports.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/param_base.py\":0-38",
            "content": "from log_utils import logger_print\nfrom render_type_utils import (\n    TYPE_UTILS_MICROGRID_PORTS_DATA,\n    TYPE_UTILS_EXTRA_PORTS_DATA,\n)\nimport json\ndef read_json(path):\n    with open(path, \"r\") as f:\n        return json.load(f)\nfrontend_translation_table = read_json(\"frontend_sim_param_translation.json\")\ntype_sys = {\n    \"\u7c7b\u578b\u5206\u7c7b\u8868\": read_json(\"microgrid_v2_all_types_structured.json\"),  # \uff08\u4e0d\u5305\u542b\u8bbe\u5907\u540d\u79f0\uff09\u5206\u7c7b->\u80fd\u6e90->\u7c7b\u578b\n    \"\u8fde\u63a5\u7c7b\u578b\u6620\u5c04\u8868\": read_json(\"microgrid_v2_connectivity_matrix.json\"),  # \"\u7aef\u70b91_\u7aef\u70b92\"->\u751f\u6210\u8fde\u63a5\u7c7b\u578b\n    \"\u8bbe\u5907\u951a\u70b9\u7c7b\u578b\u8868\": read_json(\n        \"microgrid_v2_device_port_type_mapping.json\"\n    ),  # \u8bbe\u5907\u5206\u7c7b->\u8bbe\u5907\u540d\u79f0->\u951a\u70b9\u540d\u79f0->\u951a\u70b9\u7c7b\u578b\n}\ndparam_path = \"microgrid_jinja_param_base.json\"\ndparam = read_json(dparam_path)\n\u7c7b\u578b\u96c6\u5408\u5206\u7c7b = [\n    (mkey.replace(\"\u8bbe\u5907\", \"\u951a\u70b9\"), [e for (k, v) in mdata.items() for e in v])\n    for mkey, mdata in type_sys[\"\u7c7b\u578b\u5206\u7c7b\u8868\"].items()\n]\n\u7c7b\u578b\u96c6\u5408\u5206\u7c7b.append(\n    (\"\u8bbe\u5907\", [dev for cat, devs in type_sys[\"\u8bbe\u5907\u951a\u70b9\u7c7b\u578b\u8868\"].items() for dev in devs.keys()])\n)\n# \u8bbe\u5907\u63a5\u53e3\u96c6\u5408 = {\n#     dev_name: set([(port_name, port_type) for port_name, port_type in ports.items()])"
        },
        {
            "comment": "This code creates a device interface set and a connection type mapping table for microgrid devices. It iterates through the data, filters out unwhitelisted devices, and adds their interfaces to the interface set. The connection type mapping table is built based on a provided dictionary.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/param_base.py\":39-72",
            "content": "#     for cat0, devs in type_sys[\"\u8bbe\u5907\u951a\u70b9\u7c7b\u578b\u8868\"].items()\n#     for dev_name, ports in devs.items()\n# }\n\u8bbe\u5907\u63a5\u53e3\u96c6\u5408 = {}\nfrom device_whitelist import device_whitelist\nfor data_dict in TYPE_UTILS_MICROGRID_PORTS_DATA, TYPE_UTILS_EXTRA_PORTS_DATA:\n    for category, device_dict in data_dict.items():\n        for dev_name, device_data in device_dict.items():\n            if dev_name not in device_whitelist:\n                continue\n            port_set = set()\n            for port_name, port_data in device_data[\"ports\"].items():\n                \u80fd\u6d41\u65b9\u5411 = port_data[\"\u80fd\u6d41\u65b9\u5411\"]\n                port_type = \u80fd\u6d41\u65b9\u5411.replace(\"\u8fdb\", \"\u8f93\u5165\").replace(\"\u51fa\", \"\u8f93\u51fa\")\n                port_set.add((port_name, port_type))\n            \u8bbe\u5907\u63a5\u53e3\u96c6\u5408[dev_name] = port_set\n#########################\n# logger_print(\u8bbe\u5907\u63a5\u53e3\u96c6\u5408)\n# breakpoint()\n#########################\n\u8fde\u63a5\u7c7b\u578b\u6620\u5c04\u8868 = {\n    frozenset((c1, c2)): c\n    for (c1, c2), c in [(k.split(\"_\"), v) for k, v in type_sys[\"\u8fde\u63a5\u7c7b\u578b\u6620\u5c04\u8868\"].items()]\n}\n\u8bbe\u5907\u5e93 = []\nfor super_class, v0 in dparam.items():\n    for class_name, v1 in v0.items():\n        mstrs = []"
        },
        {
            "comment": "The code iterates over `v1` dictionary, checks for specific keys and their types (str, list or dict) within the inner loop. It creates separate lists for each type of item: `mstrs`, `mdigits`, and `mtables`. Finally, it appends these lists along with superclass and class_name to the `\u8bbe\u5907\u5e93` list.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/param_base.py\":73-90",
            "content": "        mdigits = []\n        mtables = []\n        for param_super_class, v2 in v1.items():\n            # if param_super_class == \"\u4eff\u771f\u6a21\u62df\":\n            #     continue\n            for item in v2:\n                if item == \"\u8bbe\u5907\u9009\u578b\":\n                    continue\n                else:\n                    if type(item) == str:\n                        mstrs.append((param_super_class, item))\n                    elif type(item) == list:\n                        mdigits.append((param_super_class, item))\n                    elif type(item) == dict:\n                        main = item[\"MAIN\"]\n                        sub = item[\"SUB\"]\n                        mtables.append((param_super_class, main, sub))\n        \u8bbe\u5907\u5e93.append((super_class, class_name, mstrs, mdigits, mtables))"
        }
    ]
}