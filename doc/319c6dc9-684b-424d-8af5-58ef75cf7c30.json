{
    "summary": "This code imports libraries, defines functions and classes for model factories, generates fake output data, creates planning objects, ensures deterministic behavior with a deterministic random number generator, handles unknown targets, and tests deterministic behavior.",
    "details": [
        {
            "comment": "The code mocks algorithm response and provides a library for generating random seeded responses. It imports necessary classes from various libraries and modules, reads data from a JSON file, and defines functions to modify values if they are numbers or device counts.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/mock_utils.py\":0-49",
            "content": "\"\"\"\nThis library mocks algorithm response.\nHash input parameters for random seeds, if configured.\n\"\"\"\nimport json\nfrom pydantic_factories import ModelFactory\nfrom log_utils import logger_print\nfrom fastapi_datamodel_template import (\n    \u5355\u6b21\u8ba1\u7b97\u7ed3\u679c,\n    CalculationResult,\n    ObjectiveResult,\n    \u89c4\u5212\u7ed3\u679c\u8be6\u60c5_\u7ffb\u8bd1,\n    \u89c4\u5212\u65b9\u6848\u6982\u89c8_\u7ffb\u8bd1,\n    \u8bbe\u5907\u51fa\u529b\u66f2\u7ebf,\n    \u4eff\u771f\u7ed3\u679c,\n    \u51fa\u529b\u66f2\u7ebf,\n    \u66f2\u7ebf,\n    mDict,\n)\nwith open(\"test_output_full_mock_reduced.json\", \"r\") as f:\n    mock_output_data = json.loads(f.read())\n    mock_calculation_result = CalculationResult.parse_obj(mock_output_data)\nfrom config import ies_env\nTHRESHOLD = ies_env.MOCK_DATA_THRESHOLD\ndef decreaseByOneThousand(number, threshold=10):\n    assert number >= 0, f\"invalid number: {repr(number)}\"\n    if number <= threshold:\n        return number\n    ret = number / 10\n    # logger_print(number, ret)\n    return decreaseByOneThousand(ret, threshold=threshold)\nimport pandas\ndef modifyIfIsDeviceCount(location, val):\n    if \"deviceCount\" in location:\n        return random.randint(1, 10)\n    return val\ndef modifyValueIfNumber(location, val):"
        },
        {
            "comment": "This function checks if the input value is either an int or float, ensures it's not null and not zero. It then calculates the absolute value of the input, applies a precision reduction function to it, and returns the modified value. The code also includes several class definitions for model factories and one function that reduces number precision after the decimal point.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/mock_utils.py\":50-87",
            "content": "    # bool is subclass of int\n    # if isinstance(val, Union[float, int]):\n    if type(val) in [float, int]:\n        if not pandas.isnull(val):\n            if val != 0:\n                positive = val > 0\n                val_abs = abs(val)\n                val_abs_modified = decreaseByOneThousand(val_abs, threshold=THRESHOLD)\n                val_modified = (1 if positive else -1) * val_abs_modified\n                val_modified = reduceNumberPrecisionAfterDecimalPoint(val_modified)\n                return val_modified\n    return val\ndef reduceNumberPrecisionAfterDecimalPoint(num, precision=3):\n    factor = 10**precision\n    reduced_num = int(num * factor) / factor\n    return reduced_num\nfrom ies_optim import EnergyFlowGraph\nimport random\nfrom pydantic import BaseModel\nfrom solve_model import targetTypeAsTargetName\nfrom json_utils import jsonApply\nimport hashlib\nclass \u89c4\u5212\u65b9\u6848\u6982\u89c8_\u7ffb\u8bd1_\u5de5\u5382(ModelFactory):\n    __model__ = \u89c4\u5212\u65b9\u6848\u6982\u89c8_\u7ffb\u8bd1\nclass \u89c4\u5212\u7ed3\u679c\u8be6\u60c5_\u7ffb\u8bd1_\u5de5\u5382(ModelFactory):\n    __model__ = \u89c4\u5212\u7ed3\u679c\u8be6\u60c5_\u7ffb\u8bd1\nclass \u4eff\u771f\u7ed3\u679c\u5de5\u5382(ModelFactory):\n    __model__ = \u4eff\u771f\u7ed3\u679c"
        },
        {
            "comment": "The code generates a fake output data by creating an objective result, building planning related objects, and preparing a fake calculation result per device for given input data.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/mock_utils.py\":90-122",
            "content": "def generate_fake_output_data(input_data: EnergyFlowGraph):\n    (\n        firstMDict,\n        curve_elemsize,\n        curve_x_unit,\n        mDictCount,\n        planType,\n    ) = get_fake_output_data_params(input_data)\n    with deterministic_rng_context(input_data):\n        resultList = []\n        for _ in range(mDictCount):\n            obj_r = ObjectiveResult(\n                financialObjective=random.uniform(10, 1000),\n                environmentalObjective=random.uniform(10, 1000),\n            )\n            prt = []\n            ps = \u89c4\u5212\u65b9\u6848\u6982\u89c8_\u7ffb\u8bd1_\u5de5\u5382.build()\n            ps.planType = planType\n            pdl = []\n            srt = []\n            for elem in firstMDict.nodes:\n                if getattr(elem, \"type\") == \"\u8bbe\u5907\":\n                    prepare_fake_calc_result_per_device(\n                        curve_elemsize, curve_x_unit, prt, pdl, srt, elem\n                    )\n                    result = \u5355\u6b21\u8ba1\u7b97\u7ed3\u679c(\n                        objectiveResult=obj_r,\n                        planningResultTable=prt,\n                        planningSummary=ps,"
        },
        {
            "comment": "This code defines a function to prepare fake calculation results per device. It retrieves information from the element and its parameters, such as subtype, device name, manufacturer, model, and power curve data points. The code then generates a power curve x-axis based on the curve_elemsize and curve_x_unit variables. This function is used to create fake calculation results for testing or simulation purposes.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/mock_utils.py\":123-152",
            "content": "                        performanceDataList=pdl,\n                        simulationResultTable=srt,\n                    )\n                    resultList.append(result)\n        cr = CalculationResult(\n            resultList=resultList,\n            residualEquipmentAnnualFactor=random.uniform(0, 5),\n            success=True,\n            error_log=\"\",\n        )\n        # finally, pass to the number manipulation routines.\n        processed_cr = jsonApply(cr.dict(), modifyValueIfNumber, modifyIfIsDeviceCount)\n        pcr_obj = CalculationResult.parse_obj(processed_cr)\n        return pcr_obj\ndef prepare_fake_calc_result_per_device(\n    curve_elemsize, curve_x_unit, prt, pdl, srt, elem\n):\n    subtype = getattr(elem, \"subtype\")\n    # subtype = getattr(elem, \"subtype_hidden\", getattr(elem, 'subtype'))\n    param = getattr(elem, \"param\")\n    \u8bbe\u5907\u540d\u79f0, \u751f\u4ea7\u5382\u5546, \u8bbe\u5907\u578b\u53f7 = (\n        getattr(param, \"\u8bbe\u5907\u540d\u79f0\", \"\u672a\u77e5\"),\n        getattr(param, \"\u751f\u4ea7\u5382\u5546\", \"\u672a\u77e5\"),\n        getattr(param, \"\u8bbe\u5907\u578b\u53f7\", \"\u672a\u77e5\"),\n    )\n    px = [f\"{i}{curve_x_unit}\" for i in range(curve_elemsize)]"
        },
        {
            "comment": "This code is responsible for generating power curve data and creating objects representing planning results, device output curves, and simulation results. It also handles setting up the random number generator to ensure deterministic behavior if necessary. The code uses a deterministic random number generator context manager and seeds several factories with the same seed value to ensure consistent results.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/mock_utils.py\":153-189",
            "content": "    py = [random.uniform(-10, 10) for _ in range(curve_elemsize)]\n    pcurve = \u66f2\u7ebf(x=px, y=py)\n    abbr = \"\u529f\u7387\"\n    pl = [\u51fa\u529b\u66f2\u7ebf(name=f\"{subtype}{abbr}\u66f2\u7ebf\", abbr=abbr, data=pcurve)]\n    pr = \u89c4\u5212\u7ed3\u679c\u8be6\u60c5_\u7ffb\u8bd1_\u5de5\u5382.build()\n    pr.deviceName = \u8bbe\u5907\u540d\u79f0\n    pr.deviceModel = \u8bbe\u5907\u578b\u53f7\n    pd = \u8bbe\u5907\u51fa\u529b\u66f2\u7ebf(name=\u8bbe\u5907\u540d\u79f0, plot_list=pl)\n    sr = \u4eff\u771f\u7ed3\u679c\u5de5\u5382.build()\n    sr.name = \u8bbe\u5907\u540d\u79f0\n    sr.type = \u8bbe\u5907\u578b\u53f7\n    prt.append(pr)\n    pdl.append(pd)\n    srt.append(sr)\nfrom contextlib import contextmanager\nimport os\ndef restore_randomness():\n    trng_seed = lambda: os.urandom(ies_env.ANSWER_TO_THE_UNIVERSE)\n    random.seed(trng_seed())\n    \u89c4\u5212\u65b9\u6848\u6982\u89c8_\u7ffb\u8bd1_\u5de5\u5382.seed_random(trng_seed())\n    \u89c4\u5212\u7ed3\u679c\u8be6\u60c5_\u7ffb\u8bd1_\u5de5\u5382.seed_random(trng_seed())\n    \u4eff\u771f\u7ed3\u679c\u5de5\u5382.seed_random(trng_seed())\n@contextmanager\ndef deterministic_rng_context(input_data: BaseModel):\n    if ies_env.DETERMINISTIC_MOCK:\n        input_hash = get_datamodel_hash(input_data)\n        random.seed(input_hash)\n        \u89c4\u5212\u65b9\u6848\u6982\u89c8_\u7ffb\u8bd1_\u5de5\u5382.seed_random(input_hash)\n        \u89c4\u5212\u7ed3\u679c\u8be6\u60c5_\u7ffb\u8bd1_\u5de5\u5382.seed_random(input_hash)\n        \u4eff\u771f\u7ed3\u679c\u5de5\u5382.seed_random(input_hash)\n    try:"
        },
        {
            "comment": "The code contains functions for generating fake output data, calculating a hash from input data, and determining the number of mDicts based on calculation targets. The get_fake_output_data_params function retrieves specific parameters for generating fake data, while get_fake_data_mdict_count determines the number of mDicts depending on the calculation target. The code also includes exception handling for unknown calculation targets.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/mock_utils.py\":190-226",
            "content": "        yield\n    finally:\n        if ies_env.DETERMINISTIC_MOCK:\n            restore_randomness()\ndef get_datamodel_hash(input_data: BaseModel):\n    input_bytes = input_data.json().encode(\"utf-8\")\n    input_hash = hashlib.sha1(input_bytes).digest()\n    return input_hash\ndef get_fake_output_data_params(input_data: EnergyFlowGraph):\n    firstMDict: mDict = input_data.mDictList[0]\n    calcTarget = firstMDict.graph.\u8ba1\u7b97\u76ee\u6807\n    calcStepSize = firstMDict.graph.\u8ba1\u7b97\u6b65\u957f\n    curve_elemsize, curve_x_unit = get_fake_data_curve_params(calcStepSize)\n    mDictCount = get_fake_data_mdict_count(calcTarget)\n    planType = targetTypeAsTargetName(calcTarget)\n    return firstMDict, curve_elemsize, curve_x_unit, mDictCount, planType\ndef get_fake_data_mdict_count(calcTarget):\n    if calcTarget == \"\u7ecf\u6d4e_\u73af\u4fdd\":\n        mDictCount = 9\n    elif calcTarget in [\"\u7ecf\u6d4e\", \"\u73af\u4fdd\"]:\n        mDictCount = 1\n    else:\n        raise Exception(\"Unknown calculation target: %s\" % calcTarget)\n    return mDictCount\ndef get_fake_data_curve_params(calcStepSize):\n    if calcStepSize == \"\u5c0f\u65f6\":"
        },
        {
            "comment": "The code defines a function that calculates the element size and unit based on the calculation step size. It also includes a determinism assertion function that asserts whether the results are deterministic or non-deterministic, logging accordingly. The code ends with a main function for testing the utility of the defined functions.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/mock_utils.py\":227-254",
            "content": "        curve_elemsize = 8760\n        curve_x_unit = \"\u65f6\"\n    elif calcStepSize == \"\u79d2\":\n        curve_elemsize = 7200\n        curve_x_unit = \"\u79d2\"\n    else:\n        raise Exception(\"Unknown calculation step size: %s\" % calcStepSize)\n    return curve_elemsize, curve_x_unit\ndef determinism_assertation(deterministic, hash1, hash2):\n    expr = lambda a, b: a == b if deterministic else a != b\n    error_msg = (\n        f\"Non-deterministic when configured as deterministic: {hash1} != {hash2}\"\n        if deterministic\n        else f\"Deterministic when configured as non-deterministic: {hash1} == {hash2}\"\n    )\n    assert expr(hash1, hash2), error_msg\n    logger_print(f\"Passed {'' if deterministic else 'non-'}determinism check.\")\nif __name__ == \"__main__\":\n    # test the util.\n    def test_determinism(input_data: EnergyFlowGraph, deterministic: bool):\n        ies_env.DETERMINISTIC_MOCK = deterministic\n        fake_output_data1 = generate_fake_output_data(input_data)\n        fake_output_data2 = generate_fake_output_data(input_data)"
        },
        {
            "comment": "This code generates hashes for two output data sets, performs a determinism assertion check, and then tests the deterministic behavior of an EnergyFlowGraph using two input configurations.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/mock_utils.py\":256-265",
            "content": "        hash1 = get_datamodel_hash(fake_output_data1)\n        hash2 = get_datamodel_hash(fake_output_data2)\n        determinism_assertation(deterministic, hash1, hash2)\n    mock_input = \"mock_data_energy_flow_graph.json\"\n    input_data = EnergyFlowGraph.parse_file(mock_input)\n    for det in [True, False]:\n        test_determinism(input_data, det)"
        }
    ]
}