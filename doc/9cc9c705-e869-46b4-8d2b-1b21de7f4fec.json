{
    "summary": "The code uses DataclassFactory to generate instances, builds EnergyFlowGraphs from JSON files, generates random data, and logs instances for testing. It iterates over nodes, creates device power curves, generates planning and simulation results, logs CalculationResult objects, and manipulates number data.",
    "details": [
        {
            "comment": "Importing necessary modules and defining a Person class with attributes such as ID, name, hobbies, age, and birthday. Creating a PersonFactory to generate instances of the Person class using pydantic_factories. Seeding random number generator for consistent results. Building a Person instance using the factory and logging the result.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/mock_data_test.py\":0-58",
            "content": "from log_utils import logger_print\n# import os\n# import random\n# def urandom_deterministic(__size:int):\n#     return random.randbytes(__size)\n# # override system rng.\n# os.urandom = urandom_deterministic\nfrom datetime import date, datetime\nfrom typing import List, Union\nfrom pydantic import BaseModel, UUID4\nfrom pydantic_factories import ModelFactory\nclass Person(BaseModel):\n    id: UUID4\n    name: str\n    hobbies: List[str]\n    age: Union[float, int]\n    birthday: Union[datetime, date]\nclass PersonFactory(ModelFactory):\n    __model__ = Person\n    # not working!\n    # __random_seed__ = 100\n# not working.\n# import random\n# random.seed(100)\nPersonFactory.seed_random(100)  # working again!\nresult = PersonFactory.build()\nlogger_print(result)\n# exit()\n# random.seed(100)\n# result = PersonFactory.build()\n# logger_print(result)\n##############################################################\nfrom dataclasses import dataclass\n# from random import Random\nfrom polyfactory.factories import DataclassFactory\n@dataclass\nclass Person:\n    name: str"
        },
        {
            "comment": "This code defines a PersonFactory class using the DataclassFactory to create instances of the Person class. The seed_random method is used to ensure deterministic randomness in generating person attributes. The logger_print function prints the created person instance, and the code includes functionality for testing randomization but it's commented out. It also imports various classes and dictionaries from a different module.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/mock_data_test.py\":59-103",
            "content": "    age: float\n    height: float\n    weight: float\nclass PersonFactory(DataclassFactory[Person]):\n    __model__ = Person\n    # __random__ = Random(\n    #     10\n    # )  # this is not really deterministic, unless you manually specify sampling logic\n    # @classmethod\n    # def name(cls) -> str:\n    #     return cls.__random__.choice([\"John\", \"Alice\", \"George\"])\nPersonFactory.seed_random(b\"\\x00\\x01\")\n# PersonFactory.seed_random(100) # working!\np = PersonFactory.build()\nlogger_print(p)\np = PersonFactory.build()\nlogger_print(p)\n# exit()\n# def test_setting_random() -> None:\n#     # the outcome of 'factory.__random__.choice' is deterministic, because Random is configured with a set value.\n#     assert PersonFactory.build().name == \"George\"\n#     assert PersonFactory.build().name == \"John\"\n#     assert PersonFactory.build().name == \"Alice\"\nfrom fastapi_datamodel_template import (\n    \u5355\u6b21\u8ba1\u7b97\u7ed3\u679c,\n    CalculationResult,\n    ObjectiveResult,\n    \u89c4\u5212\u7ed3\u679c\u8be6\u60c5_\u7ffb\u8bd1,\n    \u89c4\u5212\u65b9\u6848\u6982\u89c8_\u7ffb\u8bd1,\n    \u8bbe\u5907\u51fa\u529b\u66f2\u7ebf,\n    \u4eff\u771f\u7ed3\u679c,\n    \u51fa\u529b\u66f2\u7ebf,\n    \u66f2\u7ebf,\n    mDict,\n)\n# not working. but we can do this later."
        },
        {
            "comment": "This code is defining two factories, \u5355\u6b21\u8ba1\u7b97\u7ed3\u679c\u5de5\u5382 and EnergyFlowGraphFactory, which create instances of \u5355\u6b21\u8ba1\u7b97\u7ed3\u679c and EnergyFlowGraph models respectively. It then builds an instance of the EnergyFlowGraph model using input data from a JSON file, \"mock_data_energy_flow_graph.json\". The code checks the calculation step size (\u5c0f\u65f6 or \u79d2) and calculates the curve element size and x-unit accordingly. If the calculation target is \"\u7ecf\u6d4e_\u73af\u4fdd\", it sets mDictCount to 9.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/mock_data_test.py\":104-148",
            "content": "# class \u5355\u6b21\u8ba1\u7b97\u7ed3\u679c\u5de5\u5382(ModelFactory):\n#     __model__ = \u5355\u6b21\u8ba1\u7b97\u7ed3\u679c\n# cr = \u5355\u6b21\u8ba1\u7b97\u7ed3\u679c\u5de5\u5382.build()\n# logger_print(cr)\n# create output based on input.\nfrom ies_optim import EnergyFlowGraph\n# class EnergyFlowGraphFactory(ModelFactory):\n#     __model__ = EnergyFlowGraph\n# input_data = EnergyFlowGraphFactory.build()\n# logger_print(input_data)\n# with open(mock_input:='mock_data_energy_flow_graph.json', 'w+') as f:\n#     f.write(input_data.json())\n# logger_print('write to:', mock_input)\nmock_input = \"mock_data_energy_flow_graph.json\"\ninput_data = EnergyFlowGraph.parse_file(mock_input)\nlogger_print(input_data)\n# seed input\nimport random\nfrom config import ies_env\nfirstMDict: mDict = input_data.mDictList[0]\ncalcTarget = firstMDict.graph.\u8ba1\u7b97\u76ee\u6807\ncalcStepSize = firstMDict.graph.\u8ba1\u7b97\u6b65\u957f\nif calcStepSize == \"\u5c0f\u65f6\":\n    curve_elemsize = 8760\n    curve_x_unit = \"\u65f6\"\nelif calcStepSize == \"\u79d2\":\n    curve_elemsize = 7200\n    curve_x_unit = \"\u79d2\"\nelse:\n    raise Exception(\"Unknown calculation step size: %s\" % calcStepSize)\nif calcTarget == \"\u7ecf\u6d4e_\u73af\u4fdd\":\n    mDictCount = 9"
        },
        {
            "comment": "This code is part of a larger program, and it appears to be generating random results for objective functions based on the \"calculation target\" input. If the calculation target is either \"\u7ecf\u6d4e\" or \"\u73af\u4fdd\", the code generates one result; otherwise, an exception is raised. The code creates factories (classes) for translating planning summaries, planning detail results, and simulation results. If the environment variable DETERMINISTIC_MOCK is set, it seeds random number generators based on input data hash to ensure deterministic mocking. The code then generates a specified number of objective result objects with random financial and environmental objectives.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/mock_data_test.py\":149-190",
            "content": "elif calcTarget in [\"\u7ecf\u6d4e\", \"\u73af\u4fdd\"]:\n    mDictCount = 1\nelse:\n    raise Exception(\"Unknown calculation target: %s\" % calcTarget)\nfrom solve_model import targetTypeAsTargetName\nplanType = targetTypeAsTargetName(calcTarget)\nresultList = []\n# class \u89c4\u5212\u65b9\u6848\u6982\u89c8_\u7ffb\u8bd1_\u5de5\u5382(DataclassFactory[\u89c4\u5212\u65b9\u6848\u6982\u89c8_\u7ffb\u8bd1]):\nclass \u89c4\u5212\u65b9\u6848\u6982\u89c8_\u7ffb\u8bd1_\u5de5\u5382(ModelFactory):\n    __model__ = \u89c4\u5212\u65b9\u6848\u6982\u89c8_\u7ffb\u8bd1\n# class \u89c4\u5212\u7ed3\u679c\u8be6\u60c5_\u7ffb\u8bd1_\u5de5\u5382(DataclassFactory[\u89c4\u5212\u7ed3\u679c\u8be6\u60c5_\u7ffb\u8bd1]):\nclass \u89c4\u5212\u7ed3\u679c\u8be6\u60c5_\u7ffb\u8bd1_\u5de5\u5382(ModelFactory):\n    __model__ = \u89c4\u5212\u7ed3\u679c\u8be6\u60c5_\u7ffb\u8bd1\n# class \u4eff\u771f\u7ed3\u679c\u5de5\u5382(DataclassFactory[\u4eff\u771f\u7ed3\u679c]):\nclass \u4eff\u771f\u7ed3\u679c\u5de5\u5382(ModelFactory):\n    __model__ = \u4eff\u771f\u7ed3\u679c\nif ies_env.DETERMINISTIC_MOCK:\n    import hashlib\n    input_bytes = input_data.json().encode(\"utf-8\")\n    input_hash = hashlib.sha1(input_bytes).digest()\n    random.seed(input_hash)\n    \u89c4\u5212\u65b9\u6848\u6982\u89c8_\u7ffb\u8bd1_\u5de5\u5382.seed_random(input_hash)\n    \u89c4\u5212\u7ed3\u679c\u8be6\u60c5_\u7ffb\u8bd1_\u5de5\u5382.seed_random(input_hash)\n    \u4eff\u771f\u7ed3\u679c\u5de5\u5382.seed_random(input_hash)\nfor _ in range(mDictCount):\n    obj_r = ObjectiveResult(\n        financialObjective=random.uniform(10, 1000),\n        environmentalObjective=random.uniform(10, 1000),\n    )\n    prt = []\n    ps = \u89c4\u5212\u65b9\u6848\u6982\u89c8_\u7ffb\u8bd1_\u5de5\u5382.build()"
        },
        {
            "comment": "This code iterates over the \"firstMDict.nodes\" and creates a device power curve for each device with type \"\u8bbe\u5907\". It extracts the device name, manufacturer, and model from parameters, then generates random data for the power curve. It also builds planning result and simulation results for each device, and appends them to their respective lists.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/mock_data_test.py\":191-219",
            "content": "    ps.planType = planType\n    pdl = []\n    srt = []\n    for elem in firstMDict.nodes:\n        if getattr(elem, \"type\") == \"\u8bbe\u5907\":\n            subtype = getattr(elem, \"subtype\")\n            param = getattr(elem, \"param\")\n            \u8bbe\u5907\u540d\u79f0, \u751f\u4ea7\u5382\u5546, \u8bbe\u5907\u578b\u53f7 = (\n                getattr(param, \"\u8bbe\u5907\u540d\u79f0\", \"\u672a\u77e5\"),\n                getattr(param, \"\u751f\u4ea7\u5382\u5546\", \"\u672a\u77e5\"),\n                getattr(param, \"\u8bbe\u5907\u578b\u53f7\", \"\u672a\u77e5\"),\n            )\n            px = [f\"{i}{curve_x_unit}\" for i in range(curve_elemsize)]\n            py = [random.uniform(-10, 10) for _ in range(curve_elemsize)]\n            pcurve = \u66f2\u7ebf(x=px, y=py)\n            abbr = \"\u529f\u7387\"\n            # abbr = ...\n            pl = [\u51fa\u529b\u66f2\u7ebf(name=f\"{subtype}{abbr}\u66f2\u7ebf\", abbr=abbr, data=pcurve)]\n            pr = \u89c4\u5212\u7ed3\u679c\u8be6\u60c5_\u7ffb\u8bd1_\u5de5\u5382.build()\n            pr.deviceName = \u8bbe\u5907\u540d\u79f0\n            pr.deviceModel = \u8bbe\u5907\u578b\u53f7\n            pd = \u8bbe\u5907\u51fa\u529b\u66f2\u7ebf(name=\u8bbe\u5907\u540d\u79f0, plot_list=pl)\n            sr = \u4eff\u771f\u7ed3\u679c\u5de5\u5382.build()\n            sr.name = \u8bbe\u5907\u540d\u79f0\n            sr.type = \u8bbe\u5907\u578b\u53f7\n            prt.append(pr)\n            pdl.append(pd)\n            srt.append(sr)"
        },
        {
            "comment": "This code creates a CalculationResult object with various attributes and appends it to a result list. It then creates another CalculationResult object, sets its properties, and passes it to number manipulation routines. The modified result is parsed into a new object and logged.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/mock_data_test.py\":221-244",
            "content": "            result = \u5355\u6b21\u8ba1\u7b97\u7ed3\u679c(\n                objectiveResult=obj_r,\n                planningResultTable=prt,\n                planningSummary=ps,\n                performanceDataList=pdl,\n                simulationResultTable=srt,\n            )\n            resultList.append(result)\ncr = CalculationResult(\n    resultList=resultList,\n    residualEquipmentAnnualFactor=random.uniform(0, 5),\n    success=True,\n    error_log=\"\",\n)\n# finally, pass to the number manipulation routines.\nfrom reduce_demo_data_size import modifyValueIfNumber, modifyIfIsDeviceCount\nfrom json_utils import jsonApply\nprocessed_cr = jsonApply(cr.dict(), modifyValueIfNumber, modifyIfIsDeviceCount)\npcr_obj = CalculationResult.parse_obj(processed_cr)\nlogger_print(pcr_obj)"
        }
    ]
}