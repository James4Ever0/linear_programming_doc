{
    "summary": "The code defines functions for energy types, microgrid system logic, and list manipulation in Prolog, focusing on adder port statuses and lists. It creates \"adder\" entities, checks their energy type and port status consistency, and provides functions to determine overall status and all possible statuses for each adder using findall.",
    "details": [
        {
            "comment": "Defines and initializes Prolog entities such as ports, states, devices, and device port mappings using CLP(FD) library.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/prolog_gen.pro.j2\":0-35",
            "content": ":- use_module(library(clpfd)).\n{% set state_to_ports = {\"input\":[], \"output\":[], \"idle\": []}%}\n{% set possible_states = [\"input\", \"output\", \"idle\"] %}\n{% for portName, portPossibleStates in portNameToPortPossibleStates.items()%}\nport({{portName}}).\n    {% for state in possible_states%}\n        {% if state in portPossibleStates%}\n            {% do state_to_ports[state].append(portName)%}\n        {% endif%}\n    {% endfor%}\n{% endfor %}\n{% for state, portNames in state_to_ports.items()%}\n    {% for portName in portNames%}\n{{state}}_port({{portName}}).\n    {% endfor%}\n{% endfor%}\n{% for deviceType in deviceTypes %}\ndevice({{deviceType}}).\n{% endfor %}\ndevice(DEVICE_NAME):- device(DEVICE_TYPE), call(DEVICE_TYPE, DEVICE_NAME).\n{% for deviceType, deviceNames in deviceTypeToDeviceNames.items()%}\n    {% for deviceName in deviceNames%}\n{{deviceType}}({{deviceName}}).\n    {% endfor%}\n{% endfor%}\n{% for deviceName, devicePortNames in deviceNameToPortNames.items()%}\n    {% for devicePortName in devicePortNames%}\nport_mapping({{deviceName}}, {{devicePortName}})."
        },
        {
            "comment": "This code defines functions to handle energy types, ports, and statuses in a microgrid system. It also includes logic for list manipulation and applies lists using a function.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/prolog_gen.pro.j2\":36-71",
            "content": "    {% endfor%}\n{% endfor%}\n{% for energyType in energyTypes%}\nenergy({{energyType}}).\n{% endfor%}\n{% for energyType, portNames in energyTypeToPortNames.items()%}\n    {% for portName in portNames %}\n{{energyType}}({{portName}}).\n    {% endfor%}\n{% endfor%}\nlist_member(X,[X|_]).\nlist_member(X,[_|TAIL]) :- list_member(X, TAIL).\nall_satisfy_constraint([], _).\nall_satisfy_constraint([H|T], Constraint) :-\n    call(Constraint, H),\n    all_satisfy_constraint(T, Constraint).\nall_with_same_type(PORT_LIST, ENERGY_TYPE) :- energy(ENERGY_TYPE), all_satisfy_constraint(PORT_LIST, ENERGY_TYPE).\nport_status(PORT, input) :- input_port(PORT).\nport_status(PORT, output):- output_port(PORT).\nport_status(PORT, idle):- idle_port(PORT).\ninput_status(STATUS) :- STATUS = input.\noutput_status(STATUS) :- STATUS = output.\nidle_status(STATUS) :- STATUS = idle.\napply_list([], [], _).\napply_list([INP], [RET], FUNC) :- call(FUNC, INP, RET).\napply_list([INP|INP_TAIL], [RET|RET_TAIL], FUNC) :- apply_list(INP_TAIL, RET_TAIL, FUNC), call(FUNC, INP, RET)."
        },
        {
            "comment": "The code defines functions related to adder port statuses and lists. It creates an \"adder\" for each set of adder ports, then checks if all ports have the same energy type and are either both input or both output. The \"adder_port_status\" function sets the overall status of the adder based on the individual port statuses. \"adder_port_all_status\" and \"adder_port_status_list\" use findall to gather all possible statuses for each adder.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/prolog_gen.pro.j2\":73-92",
            "content": "port_status_list(PORT, STATUS) :- apply_list(PORT, STATUS, port_status).\n{% for adderName, adderPortNames in adderNameToAdderPortNames.items()%}\nadder({{adderName}}, {{ '[{}]'.format(', '.join(adderPortNames)) }}).\n{% endfor%}\nadder_port_status(ADDER, [ENERGY_TYPE|[STATUS_LIST]]) :- \n    adder(ADDER, PORT_LIST),\n    all_satisfy_constraint(PORT_LIST, port),\n    all_with_same_type(PORT_LIST, ENERGY_TYPE),\n    port_status_list(PORT_LIST, STATUS_LIST),\n    (\n        list_member(STATUS_X, STATUS_LIST), list_member(STATUS_Y, STATUS_LIST),STATUS_X=input, STATUS_Y = output;\n        all_satisfy_constraint(STATUS_LIST, idle_status)\n    ).\nadder_port_all_status(ADDER, ALL_STATUS):-\n    findall(STATUS, adder_port_status(ADDER, STATUS), ALL_STATUS).\nadder_port_status_list(ADDER_LIST, ADDER_STATUS_LIST) :- apply_list(ADDER_LIST, ADDER_STATUS_LIST, adder_port_status)."
        }
    ]
}