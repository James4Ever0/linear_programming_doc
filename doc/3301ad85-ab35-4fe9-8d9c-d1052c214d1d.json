{
    "summary": "The code showcases solving an IES system using CPLEX or SWI-Prolog, discusses diagnosing unsatisfiability issues, and offers time-sliced system building. It skips a miniature system check due to difficulty and lack of direct relation to the model. The code filters state frames based on type, eliminates impossible states, checks loads at maximum state, and verifies using two sets of checks before emitting possible state frames.",
    "details": [
        {
            "comment": "The code provides a demo on how to solve a miniature IES system using CPLEX or SWI-Prolog. It also suggests methods for diagnosing the cause of unsatisfiability in case of failure and discusses building time-sliced systems for easier investigation. However, the miniature system check is skipped as it's hard to build and not directly related to the underlying model.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/solve_miniature_ies_system.py\":0-24",
            "content": "# demo on how to solve a miniatured ies system with cplex, swipl (clpqr) or something else.\n# you can use constant objective in cplex or 'once/1' in prolog to check if model is solveable.\n# bonus: in cplex you can use feasopt to relax port status constraints and diagnose the cause, while in swipl you can only transform it yourself to minimize the violation.\n# in real model you should relax the adder constraints\n# this check is after the isomorphism check. it will not eliminate multiple energy type sets of adders\n# since miniature system is hard to build, and not directly related to underlying model, let's just skip it.\n# we only build time sliced systems at this time, since this is related to the actual model, easier for investigation.\nfpath = \"isomorphic_topo_status.pkl\"\n# 1. miniature system check (skipped)\n#   cplex\n# 2. time sliced system check\n#   cplex\n# 3. build and solve the model\n#   cplex\n# if the final solution has failed, we will perform feasopt to check which case is unsatisfiable, which case is missing and which case does not exist in existing state set."
        },
        {
            "comment": "Code filters state frames based on model type, eliminates impossible states, checks all loads at maximum state, and verifies with two sets of checks before emitting final possible state frames.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/solve_miniature_ies_system.py\":26-56",
            "content": "# to ensure solveability, we elimitate the initial soc limit of lithium battery model. \n# for some model, only output port ranges will be acquired, like load, PV, lithium battery and diesel generator\n# for models like grid, diesel, we make sure any state is valid for them \n# steps:\n# 1. filter state frame list\n#     if state frame has load port at input state, iteratively try to make one load running at maximum rate\n#     if w/o any load port at input state, just enforce the directions (minimum positive/maximum negative value)\n#     eliminate impossible states\n# 2. check on remained state frame list\n#     check if all loads has maximum state, exit if not\n#     check with 2 sets of verifiers again, exit if not passed verification\n# 3. collect result\n#     emit final possible state frames\nimport pickle\nwith open(fpath, \"rb\") as f:\n    data = pickle.load(f)\nprint(\"data:\", data)\n# from pyomo.environ import *\n# solver = SolverFactory('cplex')\n# for state_frame in state_frame_list:\n#     ..."
        }
    ]
}