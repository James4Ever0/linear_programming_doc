{
    "summary": "This code defines microgrid components, energy sources, and functions for checking element existence and verifying device statuses in Prolog.",
    "details": [
        {
            "comment": "This code defines various ports, input/output/idle ports, and devices in a microgrid system. It includes ports for solar PVs, diesel generators, transformers, battery storage, and bidirectional converters. These definitions will be used to represent the components of the microgrid in subsequent code.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/sample_prolog.pro\":1-54",
            "content": "% :- use_module(library(clpfd)).\nport(\u5149\u4f0f\u53d1\u7535_0_\u7535\u63a5\u53e3).\nport(\u5149\u4f0f\u53d1\u7535_2_\u7535\u63a5\u53e3).\nport(\u67f4\u6cb9_4_\u71c3\u6599\u63a5\u53e3).\nport(\u67f4\u6cb9\u53d1\u7535_6_\u7535\u63a5\u53e3).\nport(\u67f4\u6cb9\u53d1\u7535_6_\u71c3\u6599\u63a5\u53e3).\nport(\u53d8\u6d41\u5668_9_\u7535\u8f93\u5165).\nport(\u53d8\u6d41\u5668_9_\u7535\u8f93\u51fa).\nport(\u53d8\u538b\u5668_12_\u7535\u8f93\u5165).\nport(\u53d8\u538b\u5668_12_\u7535\u8f93\u51fa).\nport(\u7535\u8d1f\u8377_15_\u7535\u63a5\u53e3).\nport(\u9502\u7535\u6c60_17_\u7535\u63a5\u53e3).\nport(\u53cc\u5411\u53d8\u6d41\u5668_22_\u7ebf\u8def\u7aef).\nport(\u53cc\u5411\u53d8\u6d41\u5668_22_\u50a8\u80fd\u7aef).\ninput_port(\u67f4\u6cb9\u53d1\u7535_6_\u71c3\u6599\u63a5\u53e3).\ninput_port(\u53d8\u6d41\u5668_9_\u7535\u8f93\u5165).\ninput_port(\u53d8\u538b\u5668_12_\u7535\u8f93\u5165).\ninput_port(\u53d8\u538b\u5668_12_\u7535\u8f93\u51fa).\ninput_port(\u7535\u8d1f\u8377_15_\u7535\u63a5\u53e3).\ninput_port(\u9502\u7535\u6c60_17_\u7535\u63a5\u53e3).\ninput_port(\u53cc\u5411\u53d8\u6d41\u5668_22_\u7ebf\u8def\u7aef).\ninput_port(\u53cc\u5411\u53d8\u6d41\u5668_22_\u50a8\u80fd\u7aef).\noutput_port(\u5149\u4f0f\u53d1\u7535_0_\u7535\u63a5\u53e3).\noutput_port(\u5149\u4f0f\u53d1\u7535_2_\u7535\u63a5\u53e3).\noutput_port(\u67f4\u6cb9_4_\u71c3\u6599\u63a5\u53e3).\noutput_port(\u67f4\u6cb9\u53d1\u7535_6_\u7535\u63a5\u53e3).\noutput_port(\u53d8\u6d41\u5668_9_\u7535\u8f93\u51fa).\noutput_port(\u53d8\u538b\u5668_12_\u7535\u8f93\u5165).\noutput_port(\u53d8\u538b\u5668_12_\u7535\u8f93\u51fa).\noutput_port(\u9502\u7535\u6c60_17_\u7535\u63a5\u53e3).\noutput_port(\u53cc\u5411\u53d8\u6d41\u5668_22_\u7ebf\u8def\u7aef).\noutput_port(\u53cc\u5411\u53d8\u6d41\u5668_22_\u50a8\u80fd\u7aef).\nidle_port(\u5149\u4f0f\u53d1\u7535_0_\u7535\u63a5\u53e3).\nidle_port(\u5149\u4f0f\u53d1\u7535_2_\u7535\u63a5\u53e3).\nidle_port(\u67f4\u6cb9_4_\u71c3\u6599\u63a5\u53e3).\nidle_port(\u67f4\u6cb9\u53d1\u7535_6_\u7535\u63a5\u53e3).\nidle_port(\u67f4\u6cb9\u53d1\u7535_6_\u71c3\u6599\u63a5\u53e3).\nidle_port(\u53d8\u6d41\u5668_9_\u7535\u8f93\u5165).\nidle_port(\u53d8\u6d41\u5668_9_\u7535\u8f93\u51fa).\nidle_port(\u53d8\u538b\u5668_12_\u7535\u8f93\u5165).\nidle_port(\u53d8\u538b\u5668_12_\u7535\u8f93\u51fa).\nidle_port(\u7535\u8d1f\u8377_15_\u7535\u63a5\u53e3).\nidle_port(\u9502\u7535\u6c60_17_\u7535\u63a5\u53e3).\nidle_port(\u53cc\u5411\u53d8\u6d41\u5668_22_\u7ebf\u8def\u7aef).\nidle_port(\u53cc\u5411\u53d8\u6d41\u5668_22_\u50a8\u80fd\u7aef).\ndevice(\u9502\u7535\u6c60).\ndevice(\u53cc\u5411\u53d8\u6d41\u5668).\ndevice(\u5149\u4f0f\u53d1\u7535)."
        },
        {
            "comment": "This code defines devices and their ports, energy sources, and constraints. It includes generators like photovoltaic (\u5149\u4f0f\u53d1\u7535), engines such as diesel (\u67f4\u6cb9), transformers (\u53d8\u538b\u5668), battery (\u9502\u7535\u6c60), bidirectional converter (\u53cc\u5411\u53d8\u6d41\u5668), load (\u7535\u8d1f\u8377), and ports for their interfaces. The code also includes the energy sources for devices like diesel (\u67f4\u6cb9) and electricity (\u7535). Additionally, there is a function to check if an element exists in a list using recursion: list_member/2. Another function all_satisfy_constraint/2 checks if each element in a list satisfies a given constraint.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/sample_prolog.pro\":55-127",
            "content": "device(\u53d8\u6d41\u5668).\ndevice(\u67f4\u6cb9\u53d1\u7535).\ndevice(\u53d8\u538b\u5668).\ndevice(\u67f4\u6cb9).\ndevice(\u7535\u8d1f\u8377).\ndevice(DEVICE_NAME):- device(DEVICE_TYPE), call(DEVICE_TYPE, DEVICE_NAME).\n\u5149\u4f0f\u53d1\u7535(\u5149\u4f0f\u53d1\u7535_0).\n\u5149\u4f0f\u53d1\u7535(\u5149\u4f0f\u53d1\u7535_2).\n\u67f4\u6cb9(\u67f4\u6cb9_4).\n\u67f4\u6cb9\u53d1\u7535(\u67f4\u6cb9\u53d1\u7535_6).\n\u53d8\u6d41\u5668(\u53d8\u6d41\u5668_9).\n\u53d8\u538b\u5668(\u53d8\u538b\u5668_12).\n\u7535\u8d1f\u8377(\u7535\u8d1f\u8377_15).\n\u9502\u7535\u6c60(\u9502\u7535\u6c60_17).\n\u53cc\u5411\u53d8\u6d41\u5668(\u53cc\u5411\u53d8\u6d41\u5668_22).\nport_mapping(\u5149\u4f0f\u53d1\u7535_0, \u5149\u4f0f\u53d1\u7535_0_\u7535\u63a5\u53e3).\nport_mapping(\u5149\u4f0f\u53d1\u7535_2, \u5149\u4f0f\u53d1\u7535_2_\u7535\u63a5\u53e3).\nport_mapping(\u67f4\u6cb9_4, \u67f4\u6cb9_4_\u71c3\u6599\u63a5\u53e3).\nport_mapping(\u67f4\u6cb9\u53d1\u7535_6, \u67f4\u6cb9\u53d1\u7535_6_\u7535\u63a5\u53e3).\nport_mapping(\u67f4\u6cb9\u53d1\u7535_6, \u67f4\u6cb9\u53d1\u7535_6_\u71c3\u6599\u63a5\u53e3).\nport_mapping(\u53d8\u6d41\u5668_9, \u53d8\u6d41\u5668_9_\u7535\u8f93\u5165).\nport_mapping(\u53d8\u6d41\u5668_9, \u53d8\u6d41\u5668_9_\u7535\u8f93\u51fa).\nport_mapping(\u53d8\u538b\u5668_12, \u53d8\u538b\u5668_12_\u7535\u8f93\u5165).\nport_mapping(\u53d8\u538b\u5668_12, \u53d8\u538b\u5668_12_\u7535\u8f93\u51fa).\nport_mapping(\u7535\u8d1f\u8377_15, \u7535\u8d1f\u8377_15_\u7535\u63a5\u53e3).\nport_mapping(\u9502\u7535\u6c60_17, \u9502\u7535\u6c60_17_\u7535\u63a5\u53e3).\nport_mapping(\u53cc\u5411\u53d8\u6d41\u5668_22, \u53cc\u5411\u53d8\u6d41\u5668_22_\u7ebf\u8def\u7aef).\nport_mapping(\u53cc\u5411\u53d8\u6d41\u5668_22, \u53cc\u5411\u53d8\u6d41\u5668_22_\u50a8\u80fd\u7aef).\nenergy(\u67f4\u6cb9).\nenergy(\u7535).\n\u7535(\u5149\u4f0f\u53d1\u7535_0_\u7535\u63a5\u53e3).\n\u7535(\u5149\u4f0f\u53d1\u7535_2_\u7535\u63a5\u53e3).\n\u7535(\u67f4\u6cb9\u53d1\u7535_6_\u7535\u63a5\u53e3).\n\u7535(\u53d8\u6d41\u5668_9_\u7535\u8f93\u5165).\n\u7535(\u53d8\u6d41\u5668_9_\u7535\u8f93\u51fa).\n\u7535(\u53d8\u538b\u5668_12_\u7535\u8f93\u5165).\n\u7535(\u53d8\u538b\u5668_12_\u7535\u8f93\u51fa).\n\u7535(\u7535\u8d1f\u8377_15_\u7535\u63a5\u53e3).\n\u7535(\u9502\u7535\u6c60_17_\u7535\u63a5\u53e3).\n\u7535(\u53cc\u5411\u53d8\u6d41\u5668_22_\u7ebf\u8def\u7aef).\n\u7535(\u53cc\u5411\u53d8\u6d41\u5668_22_\u50a8\u80fd\u7aef).\n\u67f4\u6cb9(\u67f4\u6cb9_4_\u71c3\u6599\u63a5\u53e3).\n\u67f4\u6cb9(\u67f4\u6cb9\u53d1\u7535_6_\u71c3\u6599\u63a5\u53e3).\nlist_member(X,[X|_]).\nlist_member(X,[_|TAIL]) :- list_member(X, TAIL).\nall_satisfy_constraint([], _).\nall_satisfy_constraint([H|T], Constraint) :-"
        },
        {
            "comment": "This code defines various port and adder status functions, using Prolog to apply a list of ports to their respective status. It also includes definitions for different types of adders, each with their associated port lists. The code is likely part of a larger system that involves microgrids, energy management, or electrical systems.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/sample_prolog.pro\":128-154",
            "content": "    call(Constraint, H),\n    all_satisfy_constraint(T, Constraint).\nall_with_same_type(PORT_LIST, ENERGY_TYPE) :- energy(ENERGY_TYPE), all_satisfy_constraint(PORT_LIST, ENERGY_TYPE).\nport_status(PORT, input) :- input_port(PORT).\nport_status(PORT, output):- output_port(PORT).\nport_status(PORT, idle):- idle_port(PORT).\ninput_status(STATUS) :- STATUS = input.\noutput_status(STATUS) :- STATUS = output.\nidle_status(STATUS) :- STATUS = idle.\napply_list([], [], _).\napply_list([INP], [RET], FUNC) :- call(FUNC, INP, RET).\napply_list([INP|INP_TAIL], [RET|RET_TAIL], FUNC) :- apply_list(INP_TAIL, RET_TAIL, FUNC), call(FUNC, INP, RET).\nport_status_list(PORT, STATUS) :- apply_list(PORT, STATUS, port_status).\nadder(adder19, [\u5149\u4f0f\u53d1\u7535_0_\u7535\u63a5\u53e3, \u5149\u4f0f\u53d1\u7535_2_\u7535\u63a5\u53e3, \u67f4\u6cb9\u53d1\u7535_6_\u7535\u63a5\u53e3, \u53d8\u6d41\u5668_9_\u7535\u8f93\u5165]).\nadder(adder21, [\u53d8\u6d41\u5668_9_\u7535\u8f93\u51fa, \u53cc\u5411\u53d8\u6d41\u5668_22_\u7ebf\u8def\u7aef, \u53d8\u538b\u5668_12_\u7535\u8f93\u5165]).\nadder(adder_1, [\u53cc\u5411\u53d8\u6d41\u5668_22_\u50a8\u80fd\u7aef, \u9502\u7535\u6c60_17_\u7535\u63a5\u53e3]).\nadder(adder_2, [\u67f4\u6cb9_4_\u71c3\u6599\u63a5\u53e3, \u67f4\u6cb9\u53d1\u7535_6_\u71c3\u6599\u63a5\u53e3]).\nadder(adder_3, [\u7535\u8d1f\u8377_15_\u7535\u63a5\u53e3, \u53d8\u538b\u5668_12_\u7535\u8f93\u51fa]).\nadder_port_status(ADDER, [ENERGY_TYPE|[STATUS_LIST]]) :- \n    adder(ADDER, PORT_LIST),"
        },
        {
            "comment": "This code defines predicates for checking the status of ports and devices in a microgrid topology. It finds all possible port statuses, generates a list of adder-specific device statuses, and proves that each device is okay in every adder combination to ensure a valid topology.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/sample_prolog.pro\":155-174",
            "content": "    all_satisfy_constraint(PORT_LIST, port),\n    all_with_same_type(PORT_LIST, ENERGY_TYPE),\n    port_status_list(PORT_LIST, STATUS_LIST),\n    (\n        list_member(STATUS_X, STATUS_LIST), list_member(STATUS_Y, STATUS_LIST),STATUS_X=input, STATUS_Y = output;\n        all_satisfy_constraint(STATUS_LIST, idle_status)\n    ).\nadder_port_all_status(ADDER, ALL_STATUS):-\n    findall(STATUS, adder_port_status(ADDER, STATUS), ALL_STATUS).\nadder_port_status_list(ADDER_LIST, ADDER_STATUS_LIST) :- apply_list(ADDER_LIST, ADDER_STATUS_LIST, adder_port_status).\n% to prove a topology is ok:\n% prove every device is ok in which adder combination\n% prove device in relation is ok in which adder combination\n% prove that there exists and only exists one such adder combination\n% adder_type_combination, device_1_ok(adder_type_combination), device_2_ok(adder_type_combination),...\n% device_1_and_2_ok(adder_type_combination)..."
        }
    ]
}