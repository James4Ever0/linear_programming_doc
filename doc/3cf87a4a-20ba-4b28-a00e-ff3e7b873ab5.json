{
    "summary": "The code imports modules, defines a function for unit conversion using pint's UnitRegistry, includes error checking and logging of units and powers. It also defines standard units, creates translation tables, checks compatibility, and logs information. The unitParserWrapper function is defined to clean and parse values with units, converting inputs into Pint Quantities, performing multiplication, and returning results as VAL_WITH_UNIT. The code finally converts the unit of result to a string and returns both magnitude and unit representation as a tuple.",
    "details": [
        {
            "comment": "This code imports necessary modules and defines a function to parse and convert values between different units. It uses a UnitRegistry object from the pint package, specifying a path for unit definitions, and defines a function to calculate conversion factors for given units. The code also performs some error checking and logging of the units and powers encountered in the calculations.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/unit_utils.py\":0-37",
            "content": "from log_utils import logger_print\nimport pint\nfrom os.path import abspath, dirname, join\nunit_def_path = f\"{join(dirname(abspath(__file__)), '../merged_units.txt')}\"\n# unit_def_path = \"../merged_units.txt\"\nureg = pint.UnitRegistry(unit_def_path)\nimport parse\ndef unitParser(val):\n    return parse.parse(\"{val_name}({val_unit})\", val)\ndef unitFactorCalculator(\n    ureg: pint.UnitRegistry, standard_units: frozenset, old_unit_name: str\n):  # like \"\u5143/kWh\"\n    assert old_unit_name != \"\"\n    assert type(old_unit_name) == str\n    ## now, the classic test?\n    standard_units_mapping = {\n        ureg.get_compatible_units(unit): unit for unit in standard_units\n    }\n    try:\n        quantity = ureg.Quantity(1, old_unit_name)  # one, undoubtable.\n    except:\n        raise Exception(\"Unknown unit name:\", old_unit_name)\n    # quantity = ureg.Quantity(1, ureg.\u5143/ureg.kWh)\n    magnitude, units = quantity.to_tuple()\n    new_units_list = []\n    for unit, power in units:\n        # if type(unit)!=str:\n        logger_print(\"UNIT?\", unit, \"POWER?\", power)"
        },
        {
            "comment": "Code snippet converts a given quantity to a standard unit. It first checks for compatible units, then converts the unit if necessary using ureg library, and finally returns the magnitude of the new quantity in standard units. The code also includes logging print statements for visibility.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/unit_utils.py\":38-76",
            "content": "        compat_units = ureg.get_compatible_units(\n            unit\n        )  # the frozen set, as the token for exchange.\n        target_unit = standard_units_mapping.get(compat_units, None)\n        if target_unit:\n            # ready to convert?\n            unit = str(target_unit)\n        else:\n            raise Exception(\"No common units for:\", unit)\n        new_units_list.append((unit, power))\n    logger_print(\"NEW UNITS LIST:\", new_units_list)\n    new_unit = ureg.UnitsContainer(tuple(new_units_list))\n    new_quantity = quantity.to(new_unit)\n    logger_print(\"OLD QUANTITY:\", quantity)\n    logger_print(\"NEW QUANTITY:\", new_quantity)\n    # get the magnitude?\n    new_magnitude = new_quantity.magnitude  # you multiply that.\n    logger_print(\"MAGNITUDE TO STANDARD:\", new_magnitude)\n    new_unit_name = str(new_unit)\n    logger_print(\"STANDARD:\", new_unit_name)\n    return new_magnitude, new_unit_name\nstandard_units_name_list = [\n    \"\u4e07\u5143\",\n    \"kWh\",\n    \"km\",\n    \"kW\",\n    \"\u5e74\",\n    \"MPa\",\n    \"V\",\n    \"Hz\",\n    \"ohm\",\n    \"one\","
        },
        {
            "comment": "This code defines standard units and creates unit translation tables. It also includes a function to convert values based on the default unit provided. The BASE_UNIT_TRANSLATION_TABLE contains various unit abbreviations for different units, and UNIT_TRANSLATION_TABLE is its reverse version. The getSingleUnitConverted function takes in a default unit and a value unit, if none is given it defaults to the default unit, then uses compatible units for conversion.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/unit_utils.py\":77-124",
            "content": "    # \"percent\"\n    \"\u53f0\",\n    \"m2\",\n    \"m3\",\n    # \"stere\",\n    # TODO: make \"kelvin\" into standard unit, not celsius.\n    \"celsius\",\n    \"metric_ton\",  # this is weight.\n    # \"p_u_\",\n    \"dimensionless\",\n]\nstandard_units = frozenset(\n    [ureg.Unit(unit_name) for unit_name in standard_units_name_list]\n)\nBASE_UNIT_TRANSLATION_TABLE = {\n    \"percent\": [\"%\"],\n    \"m2\": [\"m\u00b2\"],\n    \"mm2\": [\"mm\u00b2\"],\n    \"/hour\": [\n        \"/h\",\n    ],\n    \"m3\": [\"m\u00b3\", \"Nm3\", \"Nm\u00b3\"],\n    \"mm3\": [\"mm\u00b3\"],\n    \"p_u_\": [\n        \"p.u.\",\n    ],\n    # \"\u6b21\": [\"one\"],\n}\ndef revert_dict(mdict: dict):\n    result = {e: k for k, v in mdict.items() for e in v}\n    return result\nUNIT_TRANSLATION_TABLE = revert_dict(BASE_UNIT_TRANSLATION_TABLE)\ndef getSingleUnitConverted(default_unit, val_unit):\n    logger_print(\"DEFAULT UNIT:\", default_unit)\n    default_unit_real = ureg.Unit(default_unit)\n    default_unit_compatible = ureg.get_compatible_units(default_unit_real)\n    # logger_print(\"TRANS {} -> {}\".format(val_name, base_class)) # [PS]\n    if val_unit is None:\n        val_unit = default_unit"
        },
        {
            "comment": "The code defines a function that takes in a unit and checks if it's compatible with the default unit. It logs information about the units, raises exceptions if no compatible units are found, and returns whether any exception occurred or not along with the cleaned-up unit string. The translateUnit() function replaces source units in a given unit string with target units according to a predefined translation table, while the unitCleaner() function cleans up certain special characters in the unit string.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/unit_utils.py\":125-155",
            "content": "        logger_print(\"USING DEFAULT UNIT\")\n    logger_print(\"UNIT\", val_unit)\n    unit = ureg.Unit(val_unit)\n    compatible_units = ureg.get_compatible_units(unit)\n    # logger_print(\"COMPATIBLE UNITS\", compatible_units)\n    if default_unit_compatible == frozenset():\n        raise Exception(\"Compatible units are zero for default unit:\", default_unit)\n    if compatible_units == frozenset():\n        raise Exception(\"Compatible units are zero for value unit:\", val_unit)\n    if not default_unit_compatible == compatible_units:\n        has_exception = True\n        logger_print(\n            \"Unit {} not compatible with default unit {}\".format(val_unit, default_unit)\n        )\n    else:\n        has_exception = False\n    return has_exception, val_unit\ndef translateUnit(_val_unit):\n    for (\n        trans_source_unit,\n        trans_target_unit,\n    ) in UNIT_TRANSLATION_TABLE.items():\n        _val_unit = _val_unit.replace(trans_source_unit, trans_target_unit)\n    return _val_unit\ndef unitCleaner(val):\n    val = (\n        val.replace(\"\uff08\", \"(\")"
        },
        {
            "comment": "The function unitParserWrapper takes a string input and cleans it by removing specific characters before parsing the value and unit using another function unitParser. If successful, the parsed value and unit are returned as a tuple. The code also defines VAL_WITH_UNIT as a type alias for a tuple containing a number (float or int) and a string representing a unit. The functions valueWithUnitToQuantity and multiplyWithUnit utilize these types to convert the input values into Pint Quantities, perform multiplication, and return the result as VAL_WITH_UNIT.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/unit_utils.py\":156-198",
            "content": "        .replace(\"\uff09\", \")\")\n        .replace(\" \", \"\")\n        .replace(\";\", \"\")\n        .replace(\"\uff1b\", \"\")\n    )\n    val = val.strip(\"*\").strip(\":\").strip(\"\uff1a\").strip()\n    return val\nfrom typing import Tuple, Union\ndef unitParserWrapper(val: str) -> Tuple[str, Union[str, None]]:\n    val = unitCleaner(val)\n    if parsed_val := unitParser(val):\n        return (parsed_val[\"val_name\"], parsed_val[\"val_unit\"])\n    return (val, None)\ntry:\n    from typing import TypeAlias\nexcept:\n    from typing_extensions import TypeAlias\nVAL_WITH_UNIT: TypeAlias = Tuple[Union[float, int], str]\nimport beartype\n@beartype.beartype\ndef valueWithUnitToQuantity(val_with_unit: VAL_WITH_UNIT) -> pint.Quantity:\n    quantity = val_with_unit[0] * ureg.Unit(val_with_unit[1])\n    return quantity\n@beartype.beartype\ndef multiplyWithUnit(\n    val_with_unit_0: VAL_WITH_UNIT, val_with_unit_1: VAL_WITH_UNIT\n) -> VAL_WITH_UNIT:\n    q0 = valueWithUnitToQuantity(val_with_unit_0)\n    q1 = valueWithUnitToQuantity(val_with_unit_1)\n    q_result = q0 * q1\n    magnitude = q_result.magnitude"
        },
        {
            "comment": "This code converts the unit of a result (q_result.u) to a string and returns both the magnitude and the string representation of the unit as a tuple.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/unit_utils.py\":199-200",
            "content": "    unit_str = str(q_result.u)\n    return (magnitude, unit_str)"
        }
    ]
}