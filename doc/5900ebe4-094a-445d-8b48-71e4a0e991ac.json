{
    "summary": "The code loads an Excel file, extracts device parameters, and creates a JSON structure containing BCD and other information. It handles empty values and processes the data before writing it to a file for further use.",
    "details": [
        {
            "comment": "Code imports openpyxl library, loads an Excel file, selects the \"Sheet1\" worksheet, and checks if it's of type Worksheet. The code then retrieves row and column dimensions, defines a function to get column range per row, and initializes an empty dictionary named uniqs.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/parse_device_parameters_excel_v2.py\":0-32",
            "content": "import openpyxl\nfilepath = \"device_parameters_v3.3.xlsx\"\nexcel_file = openpyxl.load_workbook(filename=filepath)\n# print(excel_file.sheetnames) # ['Sheet1']\nfrom openpyxl.worksheet.worksheet import Worksheet\n# from openpyxl.cell.cell import Cell, MergedCell\nsheet1 = excel_file[\"Sheet1\"]\nif type(sheet1) == Worksheet:\n    # order: category; name (unit), example, delete or not\n    # you need to scan through all cells to find some cell with specific color.\n    # and with some example.\n    # COL: A;B,C,D;F,G,H for all data need to export\n    # after (partial) serialization, you can do something more interesting with it.\n    dims = sheet1.row_dimensions, sheet1.column_dimensions\n    # print(dims)\n    # breakpoint()\n    # print(sheet1)\n    # print(type(sheet1))\n    # breakpoint()\n    # print(dir(sheet1))\n    # breakpoint()\n    uniqs = {}\n    def getColumnRangePerRow(start, end):\n        flag = True\n        for index, row in enumerate(sheet1.rows):\n            if flag:\n                flag = False\n                continue"
        },
        {
            "comment": "This code is parsing device parameters from an Excel file. It extracts column headers, checks for empty values, and creates a target JSON structure. The code defines functions to get column ranges per row, check if a value is empty, and processes BCD (Basic Configuration Data). It prints the head maps, handles empty values, and displays a line break when all values are None or empty strings.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/parse_device_parameters_excel_v2.py\":33-70",
            "content": "            yield index, [col.value for col in row[start:end]]\n    heads = getColumnRangePerRow(0, 1)\n    # cursor = None\n    headMaps = {}\n    prevHead = None\n    mHeads = []\n    for index, [head] in heads:\n        print(index, head)\n        if head:\n            # print(type(head))\n            prevHead = head\n            mHeads.append(head)\n        if prevHead:\n            headMaps.update({index: prevHead})\n    import rich\n    rich.print(headMaps)\n    BCD = getColumnRangePerRow(1, 4)\n    FGH = getColumnRangePerRow(5, 8)\n    def checkEmpty(val):\n        if type(val) == str:\n            if val.strip() == \"\":\n                return None\n        return val\n    target_json = {h: {} for h in mHeads}\n    def processBCD(_BCD):\n        device_name = None\n        for index, [b, c, d] in _BCD:\n            head = headMaps[index]\n            b, c, d = checkEmpty(b), checkEmpty(c), checkEmpty(d)\n            # print(b,c,d) # value can be None or \"\"\n            if all([elem is None for elem in [b, c, d]]):\n                print(\"LINE BREAK\")"
        },
        {
            "comment": "This code appears to be parsing device parameters from an Excel file. It creates a target_json dictionary, where the key is the device name and the value is a list containing tuples of BCD, FGH, and some additional information. The code then writes this target_json dictionary into a \"device_params_intermediate.json\" file for further use.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/parse_device_parameters_excel_v2.py\":71-89",
            "content": "                device_name = None\n            else:\n                if device_name is None:\n                    device_name = b\n                    target_json[head].update({device_name: []})\n                else:\n                    target_json[head][device_name].append((b, c, d))\n                print(\"DEVICE NAME?\", device_name)\n    processBCD(BCD)\n    processBCD(FGH)\n    rich.print(target_json)\n    import json\n    output_path = \"device_params_intermediate.json\"\n    with open(output_path, \"w+\") as f:\n        f.write(json.dumps(target_json, indent=4, ensure_ascii=False))\n    print(\"WRITE TO:\", output_path)"
        }
    ]
}