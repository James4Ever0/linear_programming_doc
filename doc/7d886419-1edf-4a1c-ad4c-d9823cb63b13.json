{
    "summary": "The code reads a directory, extracts Python modules using ast and os. It searches for \"MAKEFILE\" assignments, executes its source code, updates MAKEFILE, removes duplicates, appends to python_files and renders generate_path without formatting.",
    "details": [
        {
            "comment": "This code reads a directory, identifies Python files, and extracts the imported modules from each file. It stores the module names in a list called mymodules. The code uses the ast module to parse the Python code and ast.walk to traverse the Abstract Syntax Tree (AST). It also utilizes the os module for file operations and the TypedDict class for defining the MakefileDict data structure.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/generate_makefile.py\":0-41",
            "content": "from log_utils import logger_print\nimport os\nimport sys\nassert (generate_path := sys.argv[-1]).endswith(\".tmp\")\n# generate_path = \"Makefile.tmp\"\nimport ast\nimport astor\nfrom typing import TypedDict, List\nclass MakefileDict(TypedDict):\n    inputs: List[str]\n    outputs: List[str]\n    args: List[str]\n    fname: str\ndef read_file(fname):\n    with open(fname, \"r\") as f:\n        content = f.read()\n        return content\npython_files = []\nfor fname in (fnames := os.listdir(\".\")):\n    if fname.endswith(\".py\"):\n        content = read_file(fname)\n        tree = ast.parse(content)\n        # you shall walk over this. see if it imports any python file in the same directory.\n        mymodules = []\n        for it in ast.walk(tree):\n            if isinstance(it, ast.Import):\n                modules = [alias.name for alias in it.names]\n                mymodules.extend(modules)\n            elif isinstance(it, ast.ImportFrom):\n                module = it.module\n                mymodules.append(module)\n        mymodules = set(mymodules)"
        },
        {
            "comment": "Code searches for an assignment with target \"MAKEFILE\", extracts the tree up to that line, converts it into source code and executes it. It then prints the MAKEFILE entry in a centered format and checks if required arguments are present in the MAKEFILE dictionary.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/generate_makefile.py\":42-63",
            "content": "        mymodules = [f\"{m}.py\" for m in mymodules]\n        required_pyfiles = [f for f in mymodules if f != fname and f in fnames]\n        myindex = -1\n        for index, elem in enumerate(tree.body):  # shall be an assignment.\n            if isinstance(elem, ast.Assign):\n                targets = elem.targets\n                if len(targets) == 1:\n                    if isinstance(targets[0], ast.Name) and targets[0].id == \"MAKEFILE\":\n                        # this will be our last line.\n                        myindex = index\n                        break\n        if myindex != -1:\n            MAKEFILE: MakefileDict\n            tree.body = tree.body[: myindex + 1]\n            source_code = astor.to_source(tree)\n            exec(source_code)\n            logger_print((\"MAKEFILE ENTRY: %s\" % fname).center(60, \"=\"))\n            logger_print(MAKEFILE)  # type: ignore\n            for argname in [\"inputs\", \"outputs\", \"args\"]:\n                assert (\n                    argname in MAKEFILE.keys()\n                ), f\"{argname} not in {MAKEFILE.keys()}\"  # type:ignore"
        },
        {
            "comment": "Updates the MAKEFILE with fname, extends \"outputs\" with required_pyfiles, removes duplicates from \"outputs\", appends a copy of MAKEFILE to python_files, and renders generate_path without formatting using load_render_and_format.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/generate_makefile.py\":64-80",
            "content": "            MAKEFILE.update(fname=fname)  # type: ignore\n            MAKEFILE[\"outputs\"].extend(required_pyfiles)\n            MAKEFILE[\"outputs\"] = list(set(MAKEFILE[\"outputs\"]))\n            python_files.append(MAKEFILE.copy())  # type: ignore\n            logger_print()\nfrom jinja_utils import load_render_and_format\n# logger_print(python_files)\n# breakpoint()\nload_render_and_format(\n    generate_path.split(\".\")[0] + \".j2\",\n    generate_path,\n    render_params=dict(python_files=python_files),\n    banner=\"MAKEFILE TMP RENDER\",\n    needFormat=False,\n)"
        }
    ]
}