{
    "summary": "This code reads and parses a file for optimizer constraints in a microgrid's codebase, identifies related class and function definitions, and logs their types and names as hints. It also checks \"compute\" functions to print their defined constraints.",
    "details": [
        {
            "comment": "This code reads the content of a file (ies_optim.py), parses it using ast, and then walks through each element to check for constraint functions. If found, the function name is logged along with its type. The logger_print function is used for logging, and there's an option to break at any point during execution.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/parse_optim_constraints.py\":0-38",
            "content": "from log_utils import logger_print\nfilepath = \"ies_optim.py\"\noutput_path = \"constraints.log\"\nMAKEFILE = dict(inputs=[filepath], outputs=[output_path], args=[\">\", output_path])\nwith open(filepath, \"r\") as f:\n    content = f.read()\nimport ast\nmfile = ast.parse(content)\n# logger_print(mfile, dir(mfile))\n# breakpoint()\nimport astor\nTS = lambda ast_tree: astor.code_gen.to_source(ast_tree)\ndef printTypeAndNameHint(TYPE: str, NAME: str, indent: int = 0):\n    logger_print()\n    logger_print(f\"{' '*indent}[{TYPE}]========================[{NAME}]\")\ndef walkElemAndPrintConstraint(\n    elem: ast.AST, TYPE: str, NAME: str, trial=True, indent=0\n):\n    if not trial:\n        printTypeAndNameHint(TYPE, NAME, indent=indent)\n    hasCode = False\n    for w in ast.walk(elem):\n        if type(w) == ast.Call:\n            callName = astor.to_source(w.func).strip()\n            if \"constraint\" in callName.lower() and \"register\" not in callName:\n                callCode = (\n                    astor.to_source(w)\n                    .strip()"
        },
        {
            "comment": "This code is parsing optimizer constraints from a microgrid's codebase. It identifies specific class and function definitions related to optimization and prints their types and names as hints. It also checks for \"compute\" functions within these classes and walks through their elements to print the constraints they define.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/parse_optim_constraints.py\":39-65",
            "content": "                    .replace(callName, callName.split(\".\")[-1])\n                )\n                hasCode = True\n                if not trial:\n                    logger_print(\" \" * (indent + 4) + callCode)\n    if trial:\n        if hasCode:\n            walkElemAndPrintConstraint(elem, TYPE, NAME, trial=False, indent=indent)\n    return hasCode\nfor elem in mfile.body:\n    if type(elem) == ast.ClassDef:\n        cname = elem.name\n        # logger_print(cname)\n        if cname.endswith(\"\u6a21\u578b\"):\n            if cname == \"\u8bbe\u5907\u6a21\u578b\":\n                printTypeAndNameHint(\"CLASS\", cname)\n                for e in elem.body:\n                    if type(e) == ast.FunctionDef:\n                        walkElemAndPrintConstraint(e, \"FUNC\", e.name, indent=4)\n            else:\n                walkElemAndPrintConstraint(elem, \"CLASS\", cname)\n    elif type(elem) == ast.FunctionDef:\n        funcName = elem.name\n        if funcName == \"compute\":\n            walkElemAndPrintConstraint(elem, \"FUNC\", funcName)"
        }
    ]
}