{
    "summary": "This code approximates sin(x) using Taylor series expansion and piecewise power calculations with numpy and scipy's interp1d. It compares the approximation to the actual value of sin(2).",
    "details": [
        {
            "comment": "The code calculates the Taylor series expansion and performs piecewise approximation of a nonlinear function. It defines lower and upper bounds for interpolated values, then uses numpy and scipy's interp1d to create an interpolation function based on input (x) and output (y) arrays.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/taylor_series_expansion_approximation_nonlinear_function_piecewise.py\":0-43",
            "content": "# z = x*sin(y)\n# sin(y) ~= y-y^3/3!+y^5/5!\n# y_3 = y^3\n# y_5 = y^5\n# z = x*y - x*y_3/3! + x*y_5/5!\n# i_0 = (x+y)/2, i_1 = (x-y)/2\n# i_2 = (x+y_3)/2, i_3 = (x-y_3)/2\n# i_4 = (x+y_5)/2, i_5 = (x-y_5)/2\n# z = i_0^2-i_1^2 - (i_2^2-i_3^2)/3!+(i_4^2-i_5^2)/5!\nfrom linearization_config import *\npow_3_lb = y_3_lb = y_lb**3\npow_3_ub = y_3_ub = y_ub**3\npow_5_lb = y_5_lb = y_lb**5\npow_5_ub = y_5_ub = y_ub**5\ni_0_lb = (x_lb + y_lb) / 2\ni_0_ub = (x_ub + y_ub) / 2\ni_1_lb = (x_lb - y_ub) / 2\ni_1_ub = (x_ub - y_lb) / 2\ni_2_lb = (x_lb + y_3_lb) / 2\ni_2_ub = (x_ub + y_3_ub) / 2\ni_3_lb = (x_lb - y_3_ub) / 2\ni_3_ub = (x_ub - y_3_lb) / 2\ni_4_lb = (x_lb + y_5_lb) / 2\ni_4_ub = (x_ub + y_5_ub) / 2\ni_5_lb = (x_lb - y_5_ub) / 2\ni_5_ub = (x_ub - y_5_lb) / 2\npow_2_lb = min(i_0_lb, i_1_lb, i_2_lb, i_3_lb, i_4_lb, i_5_lb)\npow_2_ub = max(i_0_ub, i_1_ub, i_2_ub, i_3_ub, i_4_ub, i_5_ub)\nimport numpy as np\nfrom scipy.interpolate import interp1d\n# # \u5b9a\u4e49\u8f93\u5165\u548c\u8f93\u51fa\u6570\u7ec4\n# x = np.array([0, 1, 2, 3, 4, 5])\n# y = np.array([0, 1, 4, 9, 16, 25])\ndef interpolate_from_input_and_output_array(x, y):"
        },
        {
            "comment": "Code snippet defines a function `get_piecewise_function` that takes lower bound, upper bound, sample size, and function as input. It creates an array of evenly spaced points between the bounds using `np.linspace`, computes output values for the input function, and uses `interpolate_from_input_and_output_array` to create a piecewise function. The code then defines three piecewise functions (`piecewise_pow_2`, `piecewise_pow_3`, `piecewise_pow_5`) using this function. Finally, it defines `z_func_approx` which takes x and y as input, asserts certain conditions on them, converts to numpy arrays, and returns the result of applying the piecewise cubic power function (`piecewise_pow_3`) on y.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/taylor_series_expansion_approximation_nonlinear_function_piecewise.py\":44-87",
            "content": "    # \u4f7f\u7528interp1d\u51fd\u6570\u5c06\u8f93\u5165\u548c\u8f93\u51fa\u6570\u7ec4\u8f6c\u5316\u4e3a\u5206\u6bb5\u51fd\u6570\n    f = interp1d(x, y, kind=\"linear\")  # put np.ndarray here\n    return f\n# # \u4f7f\u7528\u5206\u6bb5\u51fd\u6570\u8ba1\u7b97\u65b0\u7684\u8f93\u51fa\u503c\n# x_new = np.array([1.5, 3.5])\n# y_new = f(x_new)\n# # \u6253\u5370\u65b0\u7684\u8f93\u51fa\u503c\n# print(y_new)\ndef get_piecewise_function(lb, ub, sample_size, func):\n    print(\"LB:\",lb, \"UB:\",ub)\n    input_array = np.linspace(lb, ub, sample_size)\n    output_array = func(input_array)\n    piecewise_func = interpolate_from_input_and_output_array(input_array, output_array)\n    return piecewise_func\npiecewise_sample_size = 100000\npiecewise_pow_2 = get_piecewise_function(\n    pow_2_lb, pow_2_ub, piecewise_sample_size, lambda x: x**2\n)\npiecewise_pow_3 = get_piecewise_function(\n    pow_3_lb, pow_3_ub, piecewise_sample_size, lambda x: x**3\n)\npiecewise_pow_5 = get_piecewise_function(\n    pow_5_lb, pow_5_ub, piecewise_sample_size, lambda x: x**5\n)\nimport math\ndef z_func_approx(x: float, y: float):\n    assert x > x_lb\n    assert x < x_ub\n    assert y > y_lb\n    assert y < y_ub\n    y = np.array([y])\n    x = np.array([x])\n    y_3 = piecewise_pow_3(y)"
        },
        {
            "comment": "This code approximates the nonlinear function sin(x) using a Taylor series expansion. It performs piecewise power calculations for i_0 to i_5, then applies mathematical operations on these values to obtain z_approx as an approximation of z = sin(2). Finally, it prints z_approx and the actual value of sin(2) for comparison.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/taylor_series_expansion_approximation_nonlinear_function_piecewise.py\":88-115",
            "content": "    y_5 = piecewise_pow_5(y)\n    # breakpoint()\n    i_0 = (x + y) / 2\n    i_1 = (x - y) / 2\n    i_2 = (x + y_3) / 2\n    i_3 = (x - y_3) / 2\n    i_4 = (x + y_5) / 2\n    i_5 = (x - y_5) / 2\n    pow_2_i_0 = piecewise_pow_2(i_0)\n    pow_2_i_1 = piecewise_pow_2(i_1)\n    pow_2_i_2 = piecewise_pow_2(i_2)\n    pow_2_i_3 = piecewise_pow_2(i_3)\n    # print(\"I_4:\",i_4)\n    pow_2_i_4 = piecewise_pow_2(i_4)\n    pow_2_i_5 = piecewise_pow_2(i_5)\n    z_approx = (\n        (pow_2_i_0 - pow_2_i_1)\n        - (pow_2_i_2 - pow_2_i_3) / math.factorial(3)\n        + (pow_2_i_4 - pow_2_i_5) / math.factorial(5)\n    )\n    return z_approx\nprint(z_func_approx(1, 2), np.sin(2))"
        }
    ]
}