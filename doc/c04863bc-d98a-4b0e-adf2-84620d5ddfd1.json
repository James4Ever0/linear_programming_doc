{
    "summary": "This code calculates MD5 checksums, handles exceptions using `better_exceptions`, modifies sys.excepthook for Git commits on Windows and Unix systems, counts modifications, verifies hooks, sets up gptcommit, and manages commit times.",
    "details": [
        {
            "comment": "This code defines a function for calculating the MD5 checksum of a file and imports necessary modules. It also mentions starting a command in the background without waiting for it to finish.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/commit.py\":0-32",
            "content": "# this file shall be identical anywhere else.\n# TODO: fallback to default commit message when git commit failed (just add another line `git commit -m 'update'` right after `git commit --noedit`\nimport pytz\nimport datetime\nimport os\nimport shutil\nfrom easyprocess import EasyProcess\nimport traceback\nimport filelock\nfrom hashlib import md5\n# this is equivalent to commandline 'md5sum' command\ndef md5sum(filename, buf_size=8192):\n    m = md5()\n    # the with statement makes sure the file will be closed\n    with open(filename, 'rb') as f:\n        # We read the file in small chunk until EOF\n        data = f.read(buf_size)\n        while data:\n            # We had data to the md5 hash\n            m.update(data)\n            data = f.read(buf_size)\n    # We return the md5 hash in hexadecimal format\n    return m.hexdigest()\n# from easyprocess import EasyProcessError, log\n# from typing import Any\n# import tempfile\n# import subprocess\n# def start(self) -> \"EasyProcess\":\n#     \"\"\"start command in background and does not wait for it."
        },
        {
            "comment": "The code is initializing a process by first checking if it has already been started. If not, it sets the stdout and stderr to temporary files or PIPEs depending on the use_temp_files setting. It then creates a Popen object using the cmd, cwd, env, and shell parameters. If an OSError occurs during process startup, it logs the error and raises EasyProcessError. Finally, it sets is_started to True and logs the process pid.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/commit.py\":34-67",
            "content": "#     :rtype: self\n#     \"\"\"\n#     if self.is_started:\n#         raise EasyProcessError(self, \"process was started twice!\")\n#     stdout: Any = None\n#     stderr: Any = None\n#     if self.use_temp_files:\n#         self._stdout_file = tempfile.TemporaryFile(prefix=\"stdout_\")\n#         self._stderr_file = tempfile.TemporaryFile(prefix=\"stderr_\")\n#         stdout = self._stdout_file\n#         stderr = self._stderr_file\n#     else:\n#         stdout = subprocess.PIPE\n#         stderr = subprocess.PIPE\n#     # cmd = list(map(uniencode, self.cmd))\n#     try:\n#         self.popen = subprocess.Popen(\n#             self.cmd,\n#             stdout=stdout,\n#             stderr=stderr,\n#             cwd=self.cwd,\n#             env=self.env,\n#             shell=True,  # override shell support.\n#         )\n#     except OSError as oserror:\n#         log.debug(\"OSError exception: %s\", oserror)\n#         self.oserror = oserror\n#         raise EasyProcessError(self, \"start error\")\n#     self.is_started = True\n#     log.debug(\"process was started (pid=%s)\", self.pid)"
        },
        {
            "comment": "Code handles exception raising for commit process, checks if executable is in system path, and prints stdout and stderr for debugging purposes.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/commit.py\":68-104",
            "content": "#     return self\n# EasyProcess.start = start\n# on windows nt, alert us (using tkinter or native api?) if commit has failed.\n# on other platforms, please improvise.\nbase_repo = os.path.basename(os.curdir)\nrepo_basedir = os.path.abspath(\".\")\nos_name = os.name\nimport platform\nplatform_name = platform.system()\ntoast_title = f\"commit error at '{base_repo}'\"\ndef raise_exception(msg):\n    raise Exception(msg)\ndef check_proc_exit_status_base(proc: EasyProcess, action: str, printer):\n    if proc.return_code != 0:\n        printer(f\"Abnormal exit code {proc.return_code} during {action}.\")\ndef run_and_check_proc_base(cmd, action, printer=raise_exception):\n    proc = EasyProcess(cmd).call()\n    print(f\"Stdout:\\n{proc.stdout}\\nStderr:\\n{proc.stderr}\")\n    check_proc_exit_status_base(proc, action, printer)\ndef check_if_executable_in_path(\n    executable: str, extra_info=\"\", raise_exception: bool = True\n):\n    lookup_result = shutil.which(executable)\n    if lookup_result:\n        print(\"executable {} found in path: {}\".format(executable, lookup_result))"
        },
        {
            "comment": "This code handles showing toast notifications on different operating systems. If the executable is found in the path, it returns True. If raise_exception is set and the executable is not found, it raises an Exception. For Windows, it uses win10toast to show a toast notification. For macOS, it uses terminal-notifier. For Linux, it uses notify-send. If an unsupported OS is detected, it raises an Exception.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/commit.py\":105-139",
            "content": "        return True\n    elif raise_exception:\n        base_exc = \"executable {} not found in path.\".format(executable)\n        if extra_info:\n            base_exc = \"\\n\".join([base_exc, extra_info])\n        raise Exception(base_exc)\n    return False\nif platform_name == \"Windows\":\n    from win10toast import ToastNotifier\n    toaster = ToastNotifier()\n    def show_toast(msg):\n        toaster.show_toast(title=toast_title, msg=msg)\nelif platform_name == \"Darwin\":\n    notifier_exec = \"terminal-notifier\"\n    check_if_executable_in_path(notifier_exec)\n    def show_toast(msg):\n        cmd = [notifier_exec, \"-title\", toast_title, \"-message\", msg]\n        run_and_check_proc_base(cmd, \"sending macos toast\")\nelif platform_name == \"Linux\":\n    notifier_exec = \"notify-send\"\n    check_if_executable_in_path(notifier_exec)\n    def show_toast(msg):\n        cmd = [notifier_exec, toast_title, msg]\n        run_and_check_proc_base(cmd, \"sending linux toast\")\nelse:\n    raise Exception(f\"\\nunable to show toast message due to unknown os: {platform_name}\")"
        },
        {
            "comment": "This code defines a custom exception handling process using the `better_exceptions` library. It modifies the global `sys.excepthook`, which is called whenever an unhandled Python exception occurs. When an exception happens, it formats the traceback and writes it to a file named \".last_failed_commit\" in the repo directory. This is specifically designed for handling exceptions in Git commit operations, as it searches for directories containing a \".git\" folder. The code also provides different script execution commands for Windows (cmd) and Unix-based systems (bash).",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/commit.py\":142-178",
            "content": "def emit_message_and_raise_exception(exc_info: str):\n    show_toast(exc_info)\n    raise Exception(exc_info)\nimport sys\nimport better_exceptions\ndef excepthook(exc_type, exc_value, tb):\n    better_exceptions.SUPPORTS_COLOR = False\n    formatted = \"\".join(better_exceptions.format_exception(exc_type, exc_value, tb))\n    formatted_exc = [\"<TOPLEVEL EXCEPTION>\", formatted]\n    msg = \"\\n\".join(formatted_exc)\n    with open(os.path.join(repo_basedir, \".last_failed_commit\"), \"w+\") as f:\n        f.write(msg)\n    better_exceptions.SUPPORTS_COLOR = True\n    better_exceptions.excepthook(exc_type, exc_value, tb)\nsys.excepthook = excepthook\n# currently only enable gitcommit support for each (sub)repo. no recursive commit support yet.\nrepodirs = []\nfor path, dirpath, filepath in os.walk(\".\"):\n    if \".git\" in dirpath:\n        repodirs.append(path)\ndef get_script_path_and_exec_cmd(script_prefix):\n    if os.name == \"nt\":\n        script_suffix = \"cmd\"\n        exec_prefix = \"cmd /C\"\n    else:\n        script_suffix = \"sh\"\n        exec_prefix = \"bash\""
        },
        {
            "comment": "This code retrieves the path and command for a script named \"commit\" and checks if it exists. It then asserts that the current directory is a git repo root, obtaining the base repository name and location. The code defines functions to check process exit status and run commands while handling exceptions. It creates a list of repository directories excluding any with names from the reserved_repos list.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/commit.py\":179-214",
            "content": "    script_path = f\"{script_prefix}.{script_suffix}\"\n    cmd = f\"{exec_prefix} {script_path}\"\n    try:\n        assert os.path.exists(script_path)\n        return script_path, cmd\n    except:\n        emit_message_and_raise_exception(\n            \"script {} not found in path.\".format(script_path)\n        )\n_, COMMIT_EXEC = get_script_path_and_exec_cmd(\"commit\")\ntry:\n    assert \".\" in repodirs\nexcept:\n    emit_message_and_raise_exception(\n        f\"current directory is not a git repo root dir!\\nLocation: {repo_basedir}\"\n    )\nbase_repo_name_and_location = f\"repo {base_repo}\\nLocation: {repo_basedir}\"\n# CHECK_GPTCOMMIT_KEYS = \"gptcommit config keys\"\n# check_if_exist_keylist = [\"openai.apibase\", \"openai.api_key\"]\ndef check_proc_exit_status(proc, action):\n    check_proc_exit_status_base(proc, action, emit_message_and_raise_exception)\ndef run_and_check_proc(cmd, action):\n    run_and_check_proc_base(cmd, action, emit_message_and_raise_exception)\nreserved_repos = ['.git_backup']\nrepo_absdirs = [os.path.abspath(p) for p in repodirs if os.path.basename(p) not in reserved_repos]"
        },
        {
            "comment": "This code checks if the \"gptcommit\" executable is installed and then iterates through a list of repository directories. For each directory, it changes to that directory, runs \"git status -s\" to determine if there are any untracked or modified files, and counts the modifications. If there are any modifications, it continues; otherwise, it skips that directory. It also checks for the presence of a file called \".last_commit_time\".",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/commit.py\":216-244",
            "content": "check_if_executable_in_path(\n    \"gptcommit\", \"please install by running `cargo install --locked gptcommit`.\"\n)\nlast_commit_time_filepath = \".last_commit_time\"\n# import pathlib\n# GPTCOMMIT_HOOKED = \".gptcommit_hooked\"\nGPTCOMMIT_HOOK_MD5SUM = '69de652c2f76f0c3a209363c4943821c'\nGPTCOMMIT_HOOK_PATH = '.git/hooks/prepare-commit-msg'\ntotal_modification = 0\nrepo_absdir_to_modification = {}\nfor repo_absdir in repo_absdirs:  # is there anything needed to commit?\n    os.chdir(repo_absdir)\n    proc = EasyProcess(\"git status -s\").call()\n    check_proc_exit_status(proc, \"checking git status at %s\" % repo_absdir)\n    git_status_lines = proc.stdout.split(\"\\n\")\n    modification = 0\n    for line in git_status_lines:\n        line = line.strip()\n        if last_commit_time_filepath == line.split(\" \")[-1].strip():\n            continue\n        else:\n            modification += 1\n    print(\"Location:\", repo_absdir)\n    repo_reldir = os.path.basename(repo_absdir)\n    # proc = EasyProcess(CHECK_GPTCOMMIT_KEYS).call()\n    # check_proc_exit_status(proc, \"checking gptcommit config keys\")"
        },
        {
            "comment": "This code checks if the 'prepare-commit-msg' hook exists at the specified location and verifies its MD5 sum. If it does not exist or has a mismatched MD5 sum, it will set up 'gptcommmit' locally at the repo's absolute directory.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/commit.py\":246-271",
            "content": "    repo_name_and_location = f\"repo {repo_reldir}\\nLocation: {repo_absdir}\"\n    # if any([k for k in check_if_exist_keylist if k not in proc.stdout]):\n    repo_absdir_to_modification[repo_absdir] = modification\n    total_modification += modification\n    # TODO: checksum the '.git/hooks/prepare-commit-msg' file if exists\n    # if not os.path.exists(GPTCOMMIT_HOOKED):\n    hooked = False\n    if os.path.exists(GPTCOMMIT_HOOK_PATH):\n        if md5sum(GPTCOMMIT_HOOK_PATH) == GPTCOMMIT_HOOK_MD5SUM:\n            hooked = True\n        else:\n            print(\"WARNING: md5sum mismatch.\")\n            print(\"Installing the hook will overwrite the existing hook.\")\n    else:\n        print(\"Could not find the hook.\")\n    if not hooked:\n        print(\n            f\"setting up gptcommmit locally at repo {repo_reldir}.\\nLocation: {repo_absdir}\"\n        )\n        setup_file, SETUP_GPTCOMMIT = get_script_path_and_exec_cmd(\"setup_gptcommit\")\n        if not os.path.exists(setup_file):\n            emit_message_and_raise_exception("
        },
        {
            "comment": "The code checks if the setup file for gptcommit exists in the given repository. If it does not exist, it proceeds to set up gptcommit and records its location. If the setup file already exists, it assumes gptcommit is already set up. If there are no modifications to be committed, the script exits without any action. The code then changes directory to the repository's base directory and sets the timezone to Shanghai. It defines a function to get the current time in this timezone and another to retrieve the last commit time from a file (if it exists) or initializes it to zero. If a last commit time is found, it uses ISO format, ensuring easy conversion back to datetime object when needed.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/commit.py\":272-310",
            "content": "                f\"setup file '{setup_file}' does not exist in {repo_name_and_location}\"\n            )\n        run_and_check_proc(SETUP_GPTCOMMIT, \"setting up gptcommit\")\n        # pathlib.Path(GPTCOMMIT_HOOKED).touch()\n    else:\n        print(f\"assume gptcommit already setup at repo {repo_reldir}.\\nLocation: {repo_absdir}\")\nif total_modification == 0:\n    print(\"no modification, no need to commit\")\n    exit(0)\n# exit()\nos.chdir(repo_basedir)\n# setup timezone as Shanghai\ntimezone_str = \"Asia/Shanghai\"\ntimezone = pytz.timezone(timezone_str)\nprint(\"using timezone:\", timezone)\ndef get_time_now():\n    return datetime.datetime.now(tz=timezone)\ncommit_min_interval = datetime.timedelta(minutes=30)\ndef get_last_commit_time():\n    read_from_file = False\n    last_commit_time = datetime.datetime.fromtimestamp(0, tz=timezone)\n    if os.path.exists(last_commit_time_filepath):\n        with open(last_commit_time_filepath, \"r\") as f:\n            content = f.read()\n        try:\n            last_commit_time = datetime.datetime.fromisoformat(content)"
        },
        {
            "comment": "The code defines functions to check if a commit can be made based on the last commit time, and to execute the commit command if it's possible. It also handles printing error messages and exceptions for debugging purposes.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/commit.py\":311-343",
            "content": "            print(\"last commit time:\", last_commit_time)\n            read_from_file = True\n        except:\n            traceback.print_exc()\n    if not read_from_file:\n        print(\"using default last commit time:\", last_commit_time)\n    return last_commit_time\ndef check_if_commitable():\n    last_commit_time = get_last_commit_time()\n    time_now = get_time_now()\n    commitable = False\n    await_interval = last_commit_time + commit_min_interval - time_now\n    if await_interval.total_seconds() < 0:\n        print(\"able to commit.\")\n        commitable = True\n    else:\n        print(\n            f\"need to wait for {await_interval.total_seconds() // 60} minutes till next commit.\"\n        )\n    return commitable\ndef commit():\n    if check_if_commitable():\n        with filelock.FileLock(f\".commit_lock{'_nt' if os.name == 'nt' else ''}\" , timeout=1):\n            exit_code = os.system(COMMIT_EXEC)\n            if exit_code != 0:\n                emit_message_and_raise_exception(\n                    f\"commit changes at {base_repo_name_and_location}\""
        },
        {
            "comment": "This code snippet saves the current time as the last commit time in a file. The `get_time_now()` function retrieves the current time, which is then formatted using `isoformat()`. The content is written to the file at the specified path (`last_commit_time_filepath`) and the success message is printed to the console.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/commit.py\":344-354",
            "content": "                )\n            with open(last_commit_time_filepath, \"w+\") as f:\n                time_now = get_time_now()\n                print(f\"successfully commited at: {time_now}\\nLocation: {repo_basedir}\")\n                content = time_now.isoformat()\n                f.write(content)\nif __name__ == \"__main__\":\n    commit()"
        }
    ]
}