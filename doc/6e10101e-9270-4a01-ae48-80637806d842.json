{
    "summary": "This code manages network topology, defines node types and device handling, and includes classes for microgrid topology graphs and network analysis. It checks connectivity, creates subgraphs, and stores properties in a \"ports\" dictionary.",
    "details": [
        {
            "comment": "The code defines functions for getting main and sub types, main type, and constructs an adder dictionary. It also imports necessary modules, sets when to check topology, and defines a NodeStruct class. The code is related to network topology management, data processing, and handling device types and interfaces.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/topo_check_v2.py.j2\":0-48",
            "content": "from log_utils import logger_print\nfrom log_utils import logger_traceback\nfrom type_utils import dynamic_verify_topo_object\nimport networkx\nfrom networkx.readwrite import json_graph\nfrom config import ies_env\nfrom pydantic import BaseModel\nfrom typing import List, Dict, Literal\n# when to check topology:\n# \t1.  Building topology <- which the frontend does the job\n# \t2.  Importing topology <- where algorithm kicks in\n# so here we only check topo when importing. we don't check validity during topo construction.\n# \u6bcd\u7ebf\u6700\u591a99\u4e2a\u5bf9\u63a5\u7684\u63a5\u53e3\ndef getMainAndSubType(data):\n    logger_print(\"DATA:\", data)\n    return data[\"type\"], data[\"subtype\"]\ndef getMainType(data):\n    logger_print(\"DATA:\", data)\n    return data[\"type\"]\n# better use some template.\n# \u8bbe\u5907\u3001\u6bcd\u7ebf\u3001\u8fde\u63a5\u7ebf\u3001\u5408\u5e76\u7ebf\n\u8bbe\u5907\u7c7b\u578b = {{\u8bbe\u5907\u7c7b\u578b}}\n\u8bbe\u5907\u63a5\u53e3\u540d\u79f0\u96c6\u5408 = {{\u8bbe\u5907\u63a5\u53e3\u540d\u79f0\u96c6\u5408}}\ndirectionLookupTable = {{directionLookupTable}}\nclass NodeStruct(BaseModel):\n    id:int\n    type:str\n    subtype:str\n    direction:Literal[None, \"\u8f93\u5165\u8f93\u51fa\", \"\u8f93\u5165\", \"\u8f93\u51fa\"] = None\ndef constructAdder() -> Dict[str,List[int]]:\n    return {\"input\": [], \"output\": [], \"IO\": []}"
        },
        {
            "comment": "This code defines three functions: `parse_node_struct_and_update_adder`, `get_node_struct_from_node_id_and_node_data`, and `lookup_port_direction`. The first function updates a dictionary with node IDs based on their direction, the second function creates a `NodeStruct` object from node data, and the third function looks up the direction for a device and node combination.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/topo_check_v2.py.j2\":50-75",
            "content": "def parse_node_struct_and_update_adder(node:NodeStruct, adder:Dict[str,List[int]]):\n    # this is the main reason you cannot make subtype passed from frontend.\n    # TODO: resolve direction from rules\n    direction = node.direction\n    if direction == \"\u8f93\u5165\u8f93\u51fa\":\n        adder[\"IO\"].append(node.id)\n    elif direction == \"\u8f93\u5165\":\n        adder[\"output\"].append(node.id)\n    elif direction == \"\u8f93\u51fa\":\n        adder[\"input\"].append(node.id)\n    elif direction is None:\n        raise Exception(\"direction is not specified in node struct:\", node)\n    else:\n        raise Exception(\"Unknown direction for node:\", node)\ndef get_node_struct_from_node_id_and_node_data(node_id, node_data):\n    _type = node_data[\"type\"]\n    subtype = node_data[\"subtype\"]\n    direction = node_data.get('direction', None)\n    node_struct = NodeStruct(id = node_id, type= _type, subtype=subtype, direction = direction)\n    return node_struct\ndef lookup_port_direction(device_name, node_name):\n    direction = directionLookupTable[device_name][node_name]\n    return direction"
        },
        {
            "comment": "The code defines a class \"\u62d3\u6251\u56fe\" that represents a topology graph. It initializes the node count, creates a networkx graph object, and maintains a list of merged feeder IDs. The class has two methods: \"get_direction_from_node_id\" retrieves the direction from a node ID by looking up the port name and device subtype, and \"get_node_struct_from_node_id\" gets the node structure for a given node ID and its data. If the direction is not None, it adds the direction to the node data before returning the node structure using another function.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/topo_check_v2.py.j2\":77-104",
            "content": "class \u62d3\u6251\u56fe:\n    def __init__(self, **kwargs):\n        self.node_count = 0\n        self.G = networkx.Graph(**kwargs)\n        self.\u5408\u5e76\u6bcd\u7ebfID\u96c6\u5408\u5217\u8868 = []\n        self.is_valid = ies_env.FAILSAFE\n    def get_direction_from_node_id(self, node_id):\n        direction = None\n        node_data = self.G.nodes[node_id]\n        if node_data['type'] == '\u951a\u70b9':\n            node_name = node_data['port_name']\n            for neighbor_id in self.G.neighbors(node_id):\n                neighbor_data = self.G.nodes[neighbor_id]\n                if neighbor_data['type'] == '\u8bbe\u5907':\n                    device_name = neighbor_data['subtype']\n                    direction = lookup_port_direction(device_name, node_name)\n        return direction\n    def get_node_struct_from_node_id(self, node_id):\n        node_data = self.G.nodes[node_id]\n        direction = self.get_direction_from_node_id(node_id)\n        if direction is not None:\n            node_data['direction'] = direction\n        node_struct = get_node_struct_from_node_id_and_node_data(node_id, node_data)"
        },
        {
            "comment": "This code is related to a microgrid, specifically for topology checking. It includes functions for getting the left and right node structures from a connector node index, getting all devices in the network, and creating a dictionary of adders using merged line IDs. The merged line ID set is used to map adder IDs and create an input-output-IO structure for the adders.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/topo_check_v2.py.j2\":105-129",
            "content": "        return node_struct\n    def get_left_and_right_node_struct_from_connector_node_index(self, node_index):\n        left_id, right_id = self.G.neighbors(node_index)\n        left_node_struct, right_node_struct = self.get_node_struct_from_node_id(left_id), self.get_node_struct_from_node_id(right_id)\n        return left_node_struct, right_node_struct\n    def get_all_devices(self) -> list:\n        devs = []\n        for node_index, node_data in self.G.nodes.items():\n            node_type = node_data[\"type\"]\n            node_data[\"id\"] = node_index\n            if node_type == \"\u8bbe\u5907\":\n                devs.append(node_data)\n        return devs\n    def get_all_adders(self) -> dict:  # don't care about types here.\n        # use adder ids. adder starts with -1\n        adders = {\n            min(s): constructAdder() for s in self.\u5408\u5e76\u6bcd\u7ebfID\u96c6\u5408\u5217\u8868\n        }  # \u7528\u5230\uff1a\u5408\u5e76\u6bcd\u7ebfID\u96c6\u5408\u5217\u8868\n        adder_id = -1\n        \u6bcd\u7ebfID\u6620\u5c04\u8868 = {e: min(s) for s in self.\u5408\u5e76\u6bcd\u7ebfID\u96c6\u5408\u5217\u8868 for e in s}\n        # format: {\"input\":input_ids, \"output\": output_ids, \"IO\": IO_ids}"
        },
        {
            "comment": "Iterates through each node in the graph and checks if it is a \"\u8fde\u63a5\u7ebf\". If both adjacent nodes are \"\u6bcd\u7ebf\" and \"\u951a\u70b9\", it creates an adder. If one is a \"\u951a\u70b9\" and the other is a \"\u6bcd\u7ebf\", it uses the existing adder for the \"\u6bcd\u7ebf\". Updates the adders dictionary as needed.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/topo_check_v2.py.j2\":130-153",
            "content": "        for node_index, node_data in self.G.nodes.items():\n            node = get_node_struct_from_node_id_and_node_data(node_index, node_data)\n            {# node.type = node_data[\"type\"] #}\n            if node.type == \"\u8fde\u63a5\u7ebf\":\n                #  \u68c0\u67e5\u8fde\u63a5\u7ebf\u4e24\u7aef\n                left, right = self.get_left_and_right_node_struct_from_connector_node_index(node_index)\n                if left.type == \"\u6bcd\u7ebf\" and right.type == \"\u951a\u70b9\": # swap\n                    right, left = left, right\n                if left.type == \"\u951a\u70b9\" and right.type == \"\u951a\u70b9\":\n                    adder = constructAdder()\n                    parse_node_struct_and_update_adder(left, adder)\n                    parse_node_struct_and_update_adder(right, adder)\n                    adders[adder_id] = adder\n                    adder_id -= 1\n                elif left.type == \"\u951a\u70b9\" and right.type == \"\u6bcd\u7ebf\":\n                    madder_id = \u6bcd\u7ebfID\u6620\u5c04\u8868[right.id]\n                    adder = adders[madder_id]\n                    parse_node_struct_and_update_adder(left, adder)"
        },
        {
            "comment": "This code appears to define a class for microgrid network analysis, including functions to add nodes, check consistency, and retrieve neighboring nodes. The class utilizes a graph data structure and includes methods to access and manipulate the network topology. It also has error handling in place to identify unreasonable connection lines.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/topo_check_v2.py.j2\":155-187",
            "content": "                else:\n                    raise Exception(\n                        f\"\u4e0d\u5408\u7406\u7684\u8fde\u63a5\u7ebf\u4e24\u7aef\uff1a{left.type}[{left.subtype}]-{right.type}[{right.subtype}]\"\n                    )\n        return adders\n    def get_graph_data(self) -> dict:  # primary data. shall be found somewhere.\n        graph_data = self.G.graph\n        return graph_data\n    def add_node(self, **kwargs):\n        self.G.add_node(self.node_count, **kwargs)\n        node_id = self.node_count\n        self.node_count += 1\n        return node_id\n    def get_neighbors_by_node_id(self, node_id):\n        neighbors = list(self.G.neighbors(node_id))\n        logger_print(f\"NEIGHBORS FOR NODE #{node_id}:\", neighbors)\n        for n in neighbors:\n            logger_print(self.G.nodes[n])\n        return neighbors\n    # monotonically adding a node.\n    def _check_consistency(self):  # return nothing.\n        #  use subgraph\n        # \u63d0\u53d6\u6240\u6709\u6bcd\u7ebfID\n        \u6bcd\u7ebfID\u5217\u8868 = []\n        \u5408\u5e76\u7ebfID\u5217\u8868 = []\n        for node_id, node_data in self.G.nodes.items():\n            node = get_node_struct_from_node_id_and_node_data(node_id, node_data)"
        },
        {
            "comment": "This code checks the type and subtype of a node, retrieves its neighbors, and asserts that it has no more than 99 connections. If the node is a \"\u6bcd\u7ebf\", it adds its ID to a list and further checks if all neighbors are of valid types. For \"\u8bbe\u5907\" nodes, it checks if their subtype exists in the \"\u8bbe\u5907\u7c7b\u578b\" list. The code also handles exceptions for invalid neighbor types and non-existing device types.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/topo_check_v2.py.j2\":189-216",
            "content": "            logger_print(\"NODE TYPE:\", node.type)\n            logger_print(\"NODE SUBTYPE:\", node.subtype)\n            neighbors = self.get_neighbors_by_node_id(node.id)\n            neighbors_count = len(neighbors)\n            logger_print(\"=\" * 40)\n            if node.type == \"\u6bcd\u7ebf\":\n                \u6bcd\u7ebfID\u5217\u8868.append(node.id)\n                assert (\n                   neighbors_count <= 99\n                ), f\"\u8282\u70b9 #{node.id} \u6bcd\u7ebf\u8fde\u63a5\u6570\u8d85\u8fc799: {neighbors_count}\"\n                for n in neighbors:\n                    ne_data = self.G.nodes[n]\n                    ne_type, ne_subtype = getMainAndSubType(ne_data)\n                    if ne_type in [\"\u5408\u5e76\u7ebf\", \"\u8fde\u63a5\u7ebf\"]:\n                        pass\n                    else:\n                        raise Exception(f\"\u8282\u70b9 #{n} {node.subtype}\u8fde\u63a5\u975e\u6cd5\u7c7b\u578b\u8282\u70b9\uff1a\", ne_type)\n            elif node.type == \"\u8bbe\u5907\":\n                try:\n                    assert node.subtype in \u8bbe\u5907\u7c7b\u578b, f\"\u8282\u70b9 #{node.id} \u4e0d\u5b58\u5728\u7684\u8bbe\u5907\u7c7b\u578b: {node.subtype}\"\n                    port_name_set = set()\n                    for n in neighbors:"
        },
        {
            "comment": "This code is part of a network topology checking function. It checks if a node has the correct type, two neighbors, and if its port name matches expected values. If any errors occur, an assertion error is thrown. If exceptions are ignored due to specific environment settings, they will be logged.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/topo_check_v2.py.j2\":217-234",
            "content": "                        ne_data = self.G.nodes[n]\n                        ne_type, ne_subtype = getMainAndSubType(ne_data)\n                        port_name = ne_data[\"port_name\"]\n                        assert ne_type == \"\u951a\u70b9\", f\"\u8282\u70b9 #{n} \u9519\u8bef\u7684\u8282\u70b9\u7c7b\u578b: {ne_type}\"\n                        assert (\n                            len(list(self.G.neighbors(n))) == 2\n                        ), f\"\u8282\u70b9 #{n} \u76f8\u90bb\u8282\u70b9\u6570\u9519\u8bef: {len(list(self.G.neighbors(n)))} \u76f8\u90bb\u8282\u70b9: {(list(self.G.neighbors(n)))}\"\n                        port_name_set.add(port_name)\n                        {# port_set.add((port_name, ne_subtype)) #}\n                    assert (\n                        port_name_set == \u8bbe\u5907\u63a5\u53e3\u540d\u79f0\u96c6\u5408[node.subtype]\n                    ), f\"\u8282\u70b9 #{node.id}  PORT SET: {port_name_set} TARGET: {\u8bbe\u5907\u63a5\u53e3\u540d\u79f0\u96c6\u5408[node.subtype]}\"\n                except Exception as e:\n                    if ies_env.FAILSAFE or ies_env.IGNORE_ANCHOR_EXCEPTIONS:\n                        logger_print(\"Ignoring exception in device type:\", node.subtype)\n                        logger_traceback(e)"
        },
        {
            "comment": "This code is validating the connectivity of nodes in a network. It checks if the node type is \"\u8fde\u63a5\u7ebf\" and ensures that it has exactly 2 neighbors, raising an error if not. It then asserts that the neighbors have valid subtypes and that there are no self-connections. The code also attempts to verify the connection type based on the subtypes of the connected nodes.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/topo_check_v2.py.j2\":235-259",
            "content": "                    else:\n                        raise e\n            elif node.type == \"\u8fde\u63a5\u7ebf\":\n                {# assert node.subtype in \u8fde\u63a5\u7ebf\u7c7b\u578b, f\"\u8282\u70b9 #{node.id} \u4e0d\u5408\u7406\u8fde\u63a5\u7ebf\u7c7b\u578b\uff1a {node.subtype}\" #}\n                assert (\n                    len(neighbors) == 2\n                ), f\"\u8282\u70b9 #{node.id} \u4e0d\u5408\u7406\u8fde\u63a5\u7ebf\u76f8\u90bb\u8282\u70b9\u6570: {len(neighbors)} \u76f8\u90bb\u8282\u70b9: {neighbors}\"\n                dev_ids = set()\n                subtypes = []\n                for n in neighbors:\n                    ne_data = self.G.nodes[n]\n                    ne_type, ne_subtype = getMainAndSubType(ne_data)\n                    assert ne_type in [\"\u951a\u70b9\", \"\u6bcd\u7ebf\"]\n                    {# subtypes.append(ne_subtype) #}\n                    if ne_type == \"\u951a\u70b9\":\n                        dev_ids.add(ne_data[\"device_id\"])\n                    else:\n                        dev_ids.add(n)\n                assert (\n                    len(dev_ids) == 2\n                ), f\"\u8282\u70b9 #{node.id} invalid dev_ids: {dev_ids}\"  # no self-connection.\n                {# try:\n                    assert \u8fde\u63a5\u7c7b\u578b\u6620\u5c04\u8868[frozenset(subtypes)] == node.subtype"
        },
        {
            "comment": "Except block handles unknown connection combinations, raising an exception with node ID and details. For merge nodes, it checks if the subtype is valid and if the node has exactly 2 neighbors. It also ensures that the neighbors are of type \"mother cable\" and that the total number of node IDs for the merge node is 2. If a node type is unknown, an exception is raised with the type.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/topo_check_v2.py.j2\":260-284",
            "content": "                except:\n                    raise Exception(\n                        f\"\u8282\u70b9 #{node.id} \u672a\u77e5\u8fde\u63a5\u7ec4\u5408: (\u4e24\u7aef: {subtypes} \u8fde\u63a5\u7ebf: {node.subtype})\"\n                    ) #}\n            elif node.type == \"\u5408\u5e76\u7ebf\":\n                \u5408\u5e76\u7ebfID\u5217\u8868.append(node.id)\n                {# assert node.subtype in \u5408\u5e76\u7ebf\u7c7b\u578b, f\"\u8282\u70b9 #{node.id} \u672a\u77e5\u5408\u5e76\u7ebf\u7c7b\u578b: {node.subtype}\" #}\n                assert (\n                    len(neighbors) == 2\n                ), f\"\u8282\u70b9 #{node.id} \u4e0d\u5408\u7406\u76f8\u90bb\u8282\u70b9\u6570: {len(neighbors)} \u76f8\u90bb\u8282\u70b9: {len(neighbors)}\"\n                node_ids = set()\n                for n in neighbors:\n                    ne_data = self.G.nodes[n]\n                    ne_type, ne_subtype = getMainAndSubType(ne_data)\n                    assert ne_type == \"\u6bcd\u7ebf\", f\"\u8282\u70b9 #{n} \u4e0d\u5408\u7406\u7c7b\u578b: {ne_type}\"\n                    node_ids.add(n)\n                assert (\n                    len(node_ids) == 2\n                ), f\"\u8282\u70b9 #{node.id} \u4e0d\u5408\u7406\u5408\u5e76\u7ebf\u603b\u8282\u70b9\u6570\uff1a{len(node_ids)} \u8282\u70b9\u5217\u8868: {node_ids}\"\n            elif node.type == \"\u951a\u70b9\":\n                continue\n            else:\n                raise Exception(\"unknown node type:\", node.type)"
        },
        {
            "comment": "The code is creating a subgraph of the network using bus and branch IDs, checking if the subgraph is consistent, and then converting the graph to JSON format. The code also performs dynamic verification for consistency and raises an exception if it fails. Finally, it sets the is_valid flag to True if all checks pass.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/topo_check_v2.py.j2\":285-313",
            "content": "        subgraph = self.G.subgraph(\u6bcd\u7ebfID\u5217\u8868 + \u5408\u5e76\u7ebfID\u5217\u8868)  # check again.\n        logger_print(\"\u6bcd\u7ebfID\u5217\u8868:\", \u6bcd\u7ebfID\u5217\u8868)\n        self.\u5408\u5e76\u6bcd\u7ebfID\u96c6\u5408\u5217\u8868 = list(networkx.connected_components(subgraph))\n        self.\u5408\u5e76\u6bcd\u7ebfID\u96c6\u5408\u5217\u8868 = [\n            set([i for i in e if i not in \u5408\u5e76\u7ebfID\u5217\u8868]) for e in self.\u5408\u5e76\u6bcd\u7ebfID\u96c6\u5408\u5217\u8868\n        ]\n        logger_print(\"\u5408\u5e76\u6bcd\u7ebfID\u96c6\u5408\u5217\u8868:\", self.\u5408\u5e76\u6bcd\u7ebfID\u96c6\u5408\u5217\u8868)\n    def check_consistency(self):\n        self._check_consistency()\n        verified = False\n        isomorphic_topo_status = None\n        if ies_env.DYNAMIC_TYPE_VERIFICATION:\n            verified, isomorphic_topo_status = dynamic_verify_topo_object(self)\n        else:\n            logger_print(\"skipping dynamic verification\")\n            verified = True\n        if not verified:\n            raise Exception(\"Dynamical verification failed.\")\n        self.is_valid = True\n        return verified, isomorphic_topo_status\n    def to_json(self) -> dict:\n        data = json_graph.node_link_data(self.G)\n        return data\n    @staticmethod\n    def from_json(data):\n        # load data to graph"
        },
        {
            "comment": "This code defines a topology class and two node classes, Busbar and Device. The topology class is created from a graph using the json_graph library and contains a graph G as an attribute. The Node class initializes with a topology object and additional keyword arguments, adding a node to the graph using the add_node method. The Busbar class extends the Node class and is specifically for mother lines. The Device class also extends the Node class, and takes in device type and port definition as parameters while checking if the device type is one of the common types.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/topo_check_v2.py.j2\":314-353",
            "content": "        G = json_graph.node_link_graph(data)\n        kwargs = G.graph\n        topo = \u62d3\u6251\u56fe(**kwargs)\n        topo.G = G\n        try:\n            topo.check_consistency()\n        except Exception as e:\n            if not ies_env.FAILSAFE:\n                raise e\n            else:\n                logger_traceback(e)\n                logger_print(\"\u68c0\u6d4b\u5230\u62d3\u6251\u56fe\u4e0d\u5408\u6cd5\uff0c\u4f46\u4ecd\u7136\u7ee7\u7eed\u8fd0\u884c\")\n        return topo\n    # with checking.\n    # iterate through all nodes.\n# \u4e0b\u9762\u7684\u90fd\u9700\u8981\u4f20\u62d3\u6251\u56fe\u8fdb\u6765\nclass \u8282\u70b9:\n    def __init__(self, topo: \u62d3\u6251\u56fe, **kwargs):\n        self.topo = topo\n        self.kwargs = kwargs\n        self.id = self.topo.add_node(**kwargs)\nclass \u6bcd\u7ebf(\u8282\u70b9):\n    def __init__(self, topo: \u62d3\u6251\u56fe, subtype: str, **kwargs):\n        super().__init__(topo, type=\"\u6bcd\u7ebf\", subtype=subtype, conn=[], **kwargs)\n        # infinite ports.\nclass \u8bbe\u5907(\u8282\u70b9):\n    def __init__(\n        self, topo: \u62d3\u6251\u56fe, device_type: str, port_definition, **kwargs  # iterable.\n    ):\n        # check if device type is one of the common types.\n        super().__init__(topo, type=\"\u8bbe\u5907\", subtype=device_type, ports={}, **kwargs)"
        },
        {
            "comment": "This code defines a class for anchor nodes and connection nodes in a microgrid topology. Anchor nodes are added to the topology, and their properties such as subtype and ID are stored in the \"ports\" dictionary. Connection nodes are initialized with a given type, subtype, and connected nodes. If the connected node is a cable, its \"conn\" list is updated with the connection's subtype.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/topo_check_v2.py.j2\":354-381",
            "content": "        self.ports = {}\n        for port_name in port_definition:\n            subtype = 'unknown'\n            port_node_id = self.topo.add_node(\n                type=\"\u951a\u70b9\", port_name=port_name, subtype=subtype, device_id=self.id\n            )\n            self.ports.update({port_name: {\"subtype\": subtype, \"id\": port_node_id}})\n            self.topo.G.add_edge(self.id, port_node_id)\n        self.topo.G.nodes[self.id][\"ports\"] = self.ports\nclass \u8fde\u63a5\u8282\u70b9(\u8282\u70b9):\n    def __init__(\n        self,\n        topo: \u62d3\u6251\u56fe,\n        _type: str,\n        subtype: str,\n        conn_start_id: int,\n        conn_end_id: int,\n        **kwargs,\n    ):\n        super().__init__(topo, type=_type, subtype=subtype, **kwargs)\n        self.topo.G.add_edge(conn_start_id, self.id)\n        self.topo.G.add_edge(self.id, conn_end_id)\n        if self.topo.G.nodes[conn_start_id][\"type\"] == \"\u6bcd\u7ebf\":\n            self.topo.G.nodes[conn_start_id][\"conn\"].append(subtype)\n        if self.topo.G.nodes[conn_end_id][\"type\"] == \"\u6bcd\u7ebf\":\n            self.topo.G.nodes[conn_end_id][\"conn\"].append(subtype)"
        },
        {
            "comment": "This code is defining classes for connection nodes (such as \"\u8fde\u63a5\u7ebf\" and \"\u5408\u5e76\u7ebf\") and devices using macro functions. It creates instances of these classes based on provided names and port definitions, initializing them with a given topology graph. The for loop iterates through the device name-port definition pairs from a collection called \u8bbe\u5907\u63a5\u53e3\u540d\u79f0\u96c6\u5408 to create instances of each device class.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/topo_check_v2.py.j2\":383-410",
            "content": "{% macro makeConnNodeInstance(className) %}\nclass {{className}}(\u8fde\u63a5\u8282\u70b9):\n    def __init__(self, topo:\u62d3\u6251\u56fe, subtype:str, conn_start_id:int, conn_end_id:int, **kwargs):\n        super().__init__(topo, _type=\"{{className}}\", subtype = subtype, conn_start_id= conn_start_id, conn_end_id=conn_end_id, **kwargs)\n{% endmacro %}\n{{ makeConnNodeInstance(\"\u8fde\u63a5\u7ebf\") }}\n{{ makeConnNodeInstance(\"\u5408\u5e76\u7ebf\") }}\n{% macro makeDevice(device_name, port_definition) %}\nclass {{device_name}}(\u8bbe\u5907):\n    def __init__(self, topo:\u62d3\u6251\u56fe, **kwargs):\n        super().__init__(topo=topo, device_type=\"{{device_name}}\",  port_definition={{port_definition}}, **kwargs)\n        {% for port_name in port_definition %}\n        {# {% for port_name, port_type in port_definition %} #}\n        self.{{ port_name }} = self.ports[\"{{port_name}}\"]['id']\n        {% endfor %}\n{% endmacro %}\n{% for device_name, port_definition in \u8bbe\u5907\u63a5\u53e3\u540d\u79f0\u96c6\u5408.items() %}\n{{makeDevice(device_name, port_definition)}}\n{% endfor %}"
        }
    ]
}