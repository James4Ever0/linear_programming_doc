{
    "summary": "The code simplifies subexpressions using regular expressions and SymPy library, offering two approaches to evaluate symbolic expressions and logging the length of found arrays.",
    "details": [
        {
            "comment": "This code snippet imports necessary libraries, defines a function find_parentheses to search for parentheses pairs in a given string, and uses a progress bar. The function utilizes a stack to record the positions of left parentheses and retrieves corresponding right parentheses when finding the pair.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/expr_utils.py\":0-40",
            "content": "# lineno = 45381\n# with open(\"error.log\", 'r') as f:\n#     for index, line in enumerate(f.readlines()):\n#         if index == lineno-1:\n#             with open(\"test_data.log\", 'w+') as f1:\n#                 f1.write(line)\n#                 break\nimport sys\nfrom sympy import sympify\n# import sympy\nfrom progressbar import progressbar\nfrom log_utils import logger_print\ntry:\n    from typing import Literal\nexcept:\n    from typing_extensions import Literal\n# shall you simplify expressions in some way.\ndef find_parentheses(s):\n    \"\"\"\n    Find all parentheses pairs in the given string.\n    Parameters:\n    - s (str): The input string to search for parentheses pairs.\n    Returns:\n    - result (List[str]): A list of all parentheses pairs found in the string.\n    \"\"\"\n    stack = []\n    result = []  # EIPList\n    for i, c in enumerate(progressbar(s)):\n        if c == \"(\":\n            stack.append(i)  # \u8bb0\u5f55\u5de6\u62ec\u53f7\u7684\u4f4d\u7f6e\n        elif c == \")\":\n            if stack:  # \u5982\u679c\u6808\u4e0d\u4e3a\u7a7a\n                start = stack.pop()  # \u5f39\u51fa\u6700\u8fd1\u7684\u5de6\u62ec\u53f7\u4f4d\u7f6e\n                if not stack:  # \u5982\u679c\u6808\u4e3a\u7a7a\uff0c\u8bf4\u660e\u627e\u5230\u4e86\u4e00\u4e2a\u6700\u5916\u5c42\u7684\u62ec\u53f7\u5bf9"
        },
        {
            "comment": "This code defines a `RecursionContext` class that allows setting and restoring the Python recursion limit, which can be useful for deep nested function calls. The `getExprStrParsedToExprList()` function parses an input expression string into a list of simplified subexpressions using either approach 1 or 2 (default is approach 1).",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/expr_utils.py\":41-76",
            "content": "                    result.append(s[start : i + 1])  # \u5c06\u62ec\u53f7\u5bf9\u52a0\u5165\u7ed3\u679c\u5217\u8868\n    return result\nimport re\nfrom typing import ContextManager\nclass RecursionContext(ContextManager):\n    def __init__(self, recursion_limit=10**9):\n        self.recursion_limit = recursion_limit\n        self.sys_recursion_limit = sys.getrecursionlimit()\n    def __enter__(self):\n        \"\"\"\n        Set recursion_limit to desired limit.\n        Return `self` upon entering the runtime context.\n        \"\"\"\n        sys.setrecursionlimit(self.recursion_limit)\n        return self\n    def __exit__(self, exc_type, exc_value, traceback):\n        \"\"\"\n        Restore recursion_limit to previous limit.\n        Raise any exception triggered within the runtime context.\n        \"\"\"\n        sys.setrecursionlimit(self.sys_recursion_limit)\n        return None\ndef getExprStrParsedToExprList(data: str, approach: Literal[1, 2] = 1):\n    \"\"\"\n    Parses a string representing an expression and returns a list of simplified subexpressions.\n    Args:\n        data (str): The string representation of the expression."
        },
        {
            "comment": "This code defines a function for simplifying subexpressions in a given expression. It uses regular expressions to find arrays within the data and then applies two different approaches (1 and 2) for simplification, with approach 1 being faster. The function also logs the length of found arrays using logger_print.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/expr_utils.py\":77-115",
            "content": "        approach (Literal[1, 2], optional): The approach to use for simplification. Defaults to 1.\n    Returns:\n        list: A list of simplified subexpressions.\n    Raises:\n        AssertionError: If the approach is not 1 or 2.\n    \"\"\"\n    regex = re.compile(r\"(\\[\\d+\\])\")\n    subs = regex.findall(data)\n    logger_print(len(subs))\n    # for sub in set(subs):\n    #     data = data.replace(sub,\"_Array\")\n    data = regex.sub(\"_Array\", data)\n    #######################\n    # EXPR SIMPLIFICATION #\n    #######################\n    \"\"\"\n    APP1: subexpr (-> full_expr)\n    APP2: full_expr -> subexpr\n    APP1 is faster than APP2.\n    \"\"\"\n    import time\n    starting_time = time.time()\n    if approach == 1:\n        #####################APPROACH 1#####################\n        \"\"\"\n        parse and substitude terms.\n        \"\"\"\n        regex2 = re.compile(r\"(((?P<term>\\w+_Array) \\+ )+((?P=term)))\")\n        summation = [(e[0], e[2]) for e in regex2.findall(data)]\n        summation.sort(key=lambda x: -len(x[0]))\n        # logger_print(len(summation))"
        },
        {
            "comment": "This code is modifying and simplifying a mathematical expression using SymPy library. It replaces symbols with specific codes, identifies expressions within parentheses, and applies recursion to simplify each subexpression. The resulting simplified expressions are then processed by Poly class from the sympy.polys.polytools module.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/expr_utils.py\":116-146",
            "content": "        # summation = set(summation)\n        # expr = \"\"\n        # breakpoint()\n        for e0, e2 in summation:\n            suffix = f\"_SUM_OF_{e0.count('+')+1}\"\n            data = data.replace(e0, e2 + suffix)\n        # logger_print(data)\n        expr_repr = data\n        from sympy.polys.polytools import Poly\n        # recursion error!\n        # expr = sympify(data)\n        EIPList = find_parentheses(data)\n        elems_in_parentheses = set(EIPList)\n        EIPMAP = {e: f\"EIP_{i}\" for i, e in enumerate(elems_in_parentheses)}\n        EIPMAP_REV = {v: k for k, v in EIPMAP.items()}\n        for EIP, EIP_CODE in EIPMAP.items():\n            expr_repr = expr_repr.replace(EIP, EIP_CODE)\n        subexpr_strs = expr_repr.replace(\"-\", \"+ -\").split(\"+\")\n        expr_list = []\n        with RecursionContext() as RC:\n            for subexpr in subexpr_strs:\n                # logger_print()\n                sympify_expr = sympify(subexpr)\n                sympify_expr = sympify_expr.simplify()\n                _p = Poly(sympify_expr)"
        },
        {
            "comment": "Code segment loops through free symbols in an expression, substitutes the corresponding EIP (expression intercept point) values for each symbol, and stores the resulting expressions in a list. Final sum of all expressions is calculated and returned. Additionally, it logs various messages during execution for debugging purposes. Two approaches are provided, with timing measurement for Approach 1.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/expr_utils.py\":147-170",
            "content": "                fs = _p.free_symbols\n                logger_print(f\"FS: {fs}\")\n                # logger_print()\n                for s in fs:\n                    sname = str(s)\n                    if sname in EIPMAP_REV.keys():\n                        eip = EIPMAP_REV[sname]\n                        eip_expr = sympify(eip)\n                        eip_expr = eip_expr.simplify()\n                        logger_print(f\"{sname} = {eip_expr}\")\n                        sympify_expr = sympify_expr.subs(sympify(sname), eip_expr)\n                logger_print(\"TERM EXPR:\", sympify_expr)\n                expr_list.append(sympify_expr)\n        # breakpoint()\n        final_expr = sum(expr_list)\n        logger_print(\"FINAL EXPR:\")\n        logger_print(final_expr)\n        #####################APPROACH 1#####################\n        endtime = time.time()\n        logger_print(\"APP1_TIME:\", endtime - starting_time)\n        return expr_list\n        # APP1_TIME: 4.300285339355469\n        # APP1_TIME: 4.084861993789673\n    elif approach == 2:"
        },
        {
            "comment": "This code uses regular expressions to extract words from a given data string, then generates SymPy symbolic expressions for those words and stores them in a list of code lines. It executes these code lines and simplifies the resulting expression using SymPy's simplification capabilities.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/expr_utils.py\":171-201",
            "content": "        #####################APPROACH 2#####################\n        \"\"\"\n        use template to generate symbols and code.\n        \"\"\"\n        # import sys\n        # sys.setrecursionlimit(10*100000)\n        # sys.getrecursionlimit()\n        regex = re.compile(r\"\\w+\")\n        words = regex.findall(data)\n        words = set(words)\n        # mwords = []\n        codeLines = []\n        # codeLines.append(\"import sympy\")\n        for word in words:  # do not use progressbar in here!\n            try:\n                float(word)\n            except:\n                codeLines.append(f'{word} = sympify(\"{word}\")')\n                # mwords.append(word)\n        # exec(code)\n        # codeLines.append(f\"sympy_expr = {data}\")\n        for line in codeLines:\n            logger_print(\n                \"EXCECUTING: \", line[:200] + (\"\" if len(line) < 200 else \"...\")\n            )\n            exec(line)\n        logger_print(\"GETTING EXPR\")\n        with RecursionContext() as RC:\n            sympy_expr = eval(data)\n            logger_print(\"SIMPLIFYING EXPR\")"
        },
        {
            "comment": "This code simplifies a SymPy expression, logs it, then applies approach 2 by extracting terms from the expression, logging them, and returning the term list. It also measures the time taken for this process. If an invalid approach is used, it throws an assertion error. The code is part of a larger program that may use \"test_data.log\" for input data.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/expr_utils.py\":202-226",
            "content": "            sympy_expr = sympy_expr.simplify()\n            # logger_print()\n            logger_print(sympy_expr)\n        #####################APPROACH 2#####################\n        logger_print(\"FINAL EXPR:\")\n        logger_print(sympy_expr)\n        terms = sympy_expr.as_terms()\n        termlist = []\n        for t in terms:\n            term = t[0]\n            termlist.append(term)\n        endtime = time.time()\n        logger_print(\"APP2_TIME:\", endtime - starting_time)\n        # APP2_TIME: 12.695726156234741\n        # APP2_TIME: 11.072844982147217\n        return termlist\n    else:\n        assert False, f\"Bad approach: {approach}\"\nif __name__ == \"__main__\":\n    data = open(\"test_data.log\", \"r\").read()  # entry: for test"
        }
    ]
}