{
    "summary": "The code creates a Prolog environment for a microgrid system, verifies topology statuses and conditions, logs errors, validates using Python scripts, and checks if the program can proceed based on energy types and topology status.",
    "details": [
        {
            "comment": "This code is importing functions from other modules and defining a function to check the validity of topology rules. It also includes a method to transform port names according to a specific format and lists of deviceTypes and energyTypes. The code uses string formatting for readability, but it's not clear which parts are placeholders or static values.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_utils.py.j2\":0-30",
            "content": "from log_utils import logger_print\nfrom type_def import *\nimport os\nfrom constants import UNKNOWN\n{# import parse #}\n\"\"\"static & dynamic topology type checking\"\"\"\ndef logFailedRule(passed:bool, banner:str):\n    if not passed:\n        logger_print(f\"Rule {banner} failed.\")\n    return passed\n{# PORT_NAME_FORMAT = \"{deviceSubtype}_{deviceIndex}_{portName}\" #}\ndef portNameTransformer(port_name):\n    result = port_name.split(\"_\")\n    {# result = parse.parse(PORT_NAME_FORMAT, port_name) #}\n    result_length = len(result)\n    if result_length == 3:\n        transformed_port_name = f\"{result[0]}_{result[2]}\"\n        {# transformed_port_name = f\"{result['deviceSubtype']}_{result['portName']}\" #}\n    else:\n        raise Exception(f'Failed to parse port name \"{port_name}\" (mismatched splited size: {result_length})')\n        {# raise Exception(f'Failed to parse port name \"{port_name}\" with format \"{PORT_NAME_FORMAT}\"') #}\n    return transformed_port_name\ndeviceTypes = {{deviceTypes}}\nenergyTypes = {{energyTypes}}\ndeviceTypeToTypeInfo = {"
        },
        {
            "comment": "The code defines lookup tables for port verifier, conjugate port verifier constructor, and creates empty dictionaries to store data for topology conversion. It uses sets and dictionaries to keep track of device types, possible energy types, port states, device names, port names, and adder names.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_utils.py.j2\":31-63",
            "content": "{% for deviceType, requiredPortFrontendNameToPortPossibleStates,requiredPortFrontendNameToEnergyTypes in deviceTypeTriplets %}\n    {{repr(deviceType)}}: {\n        \"requiredPortFrontendNameToPortPossibleStates\": {{requiredPortFrontendNameToPortPossibleStates}},\n        \"requiredPortFrontendNameToEnergyTypes\": {{requiredPortFrontendNameToEnergyTypes}}\n    },\n{% endfor %}\n}\nport_verifier_lookup_table = {\n{% for k, v in port_verifier_lookup_table.items() %}\n    {{repr(k)}}: {\n    {% for v_k, v_v in v.items() %}\n        {{repr(v_k)}}: {{v_v}},\n    {% endfor %}\n    },\n{% endfor %}\n}\nconjugate_port_verifier_constructor_lookup_table = {\n{% for k, v in conjugate_port_verifier_constructor_lookup_table.items() %}\n    {{repr(k)}}: {{v}},\n{% endfor %}\n}\ndef convert_topo_to_prolog_render_params_and_verification_params(topo):\n    possibleEnergyTypes = set()\n    possibleDeviceTypes = set()\n    portNameToPortPossibleStates = {} #\n    deviceTypeToDeviceNames = {} #\n    deviceNameToPortNames = {} #\n    energyTypeToPortNames = {} #\n    adderNameToAdderPortNames = {} #"
        },
        {
            "comment": "This code initializes various dictionaries for storing device names, port names, and their properties. It also adds device subtypes to a set of possible device types. The code iterates through the topology's devices and ports, organizing the information into these dictionaries. Conjugate port verifiers are also supposed to be parsed from the topo object in the future.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_utils.py.j2\":65-90",
            "content": "    port_name_lookup_table = {}\n    adders = topo.get_all_adders()\n    adder_index_to_adder_name = {}\n    port_verifiers = {}\n    conjugate_port_verifiers = {} # TODO: parse additional conjugate port verifiers from topo object.\n    for devInfo in topo.get_all_devices():\n        node_id = devInfo['id']\n        node_subtype = devInfo['subtype']\n        possibleDeviceTypes.add(node_subtype)\n        devName = f\"{node_subtype}_{node_id}\"\n        deviceNameToPortNames[devName] = []\n        if node_subtype not in deviceTypeToDeviceNames.keys():\n            deviceTypeToDeviceNames[node_subtype] = []\n        deviceTypeToDeviceNames[node_subtype].append(devName)\n        ports = devInfo['ports']\n        typeInfo = deviceTypeToTypeInfo[node_subtype]\n        requiredPortFrontendNameToPortPossibleStates = typeInfo['requiredPortFrontendNameToPortPossibleStates']\n        requiredPortFrontendNameToEnergyTypes = typeInfo['requiredPortFrontendNameToEnergyTypes']\n        port_kind_to_port_name = {}\n        for port_kind, port_info in ports.items():"
        },
        {
            "comment": "The code is setting up port information for a microgrid system. It retrieves the possible states and energy types for a given port kind, updates the list of possible energy types, creates a unique name for each port based on its device and type, adds the port verifier if it exists, stores information in lookup tables for quick access, and finally organizes the port names by their associated energy types.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_utils.py.j2\":91-112",
            "content": "            portPossibleStates = requiredPortFrontendNameToPortPossibleStates[port_kind]\n            portPossibleEnergyTypes = requiredPortFrontendNameToEnergyTypes[port_kind]\n            possibleEnergyTypes.update(portPossibleEnergyTypes)\n            port_name = f\"{devName}_{port_kind}\"\n            port_kind_to_port_name[port_kind] = port_name\n            verifier = port_verifier_lookup_table.get(node_subtype, {}).get(port_kind, None)\n            if verifier:\n                port_verifiers[port_name] = verifier\n            deviceNameToPortNames[devName].append(port_name)\n            port_id = port_info['id']\n            port_name_lookup_table[port_id] = port_name\n            portNameToPortPossibleStates[port_name] = portPossibleStates\n            for energyType in portPossibleEnergyTypes:\n                if energyType not in energyTypeToPortNames.keys():\n                    energyTypeToPortNames[energyType] = []\n                energyTypeToPortNames[energyType].append(port_name)\n        conjugate_ver"
        },
        {
            "comment": "The code creates a dictionary of port verifiers, updates with additional conjugate verifiers, adds adder information for index and name lookup, populates an adderNameToAdderPortNames dictionary, and prepares render parameters including port states, device types, device names, and energy types.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_utils.py.j2\":112-132",
            "content": "ifiers_constructor = conjugate_port_verifier_constructor_lookup_table.get(node_subtype, lambda d: {})\n        conjugate_verifiers = conjugate_verifiers_constructor(port_kind_to_port_name)\n        conjugate_port_verifiers.update(conjugate_verifiers)\n    for adder_index, adder_def in adders.items():\n        index = str(adder_index).replace('-','_')\n        adder_name = f'adder{index}'\n        adder_index_to_adder_name[adder_index] = adder_name\n        port_name_list = []\n        for _, port_index_list in adder_def.items():\n            for port_index in port_index_list:\n                port_name = port_name_lookup_table[port_index]\n                port_name_list.append(port_name)\n        adderNameToAdderPortNames[adder_name] = port_name_list\n    render_params = dict(\n        portNameToPortPossibleStates=portNameToPortPossibleStates,\n        deviceTypes=list(possibleDeviceTypes),\n        deviceTypeToDeviceNames=deviceTypeToDeviceNames,\n        deviceNameToPortNames=deviceNameToPortNames,\n        energyTypes=list(possibleEnergyTypes),"
        },
        {
            "comment": "Code sets up a lookup table for port names and adder indexes based on the provided energy types and adder names. It then generates an absolute path to the template file, sets an environment variable to disable Python type checking, imports a module, opens the template file, and assigns its contents to a variable.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_utils.py.j2\":133-161",
            "content": "        energyTypeToPortNames=energyTypeToPortNames,\n        adderNameToAdderPortNames=adderNameToAdderPortNames,\n    )\n    port_index_lookup_table = {v:k for k, v in port_name_lookup_table.items()}\n    adder_name_to_adder_index = {v:k for k, v in adder_index_to_adder_name.items()}\n    adder_index_to_port_name = {}\n    for adderName, adderPortNames in adderNameToAdderPortNames.items():\n        {# adderPortNames #}\n        port_index_to_port_name = {port_index_lookup_table[portName]:portName for portName in adderPortNames}\n        adder_index = adder_name_to_adder_index[adderName]\n        adder_index_to_port_name[adder_index] = port_index_to_port_name\n    verification_params = (adder_index_to_port_name, port_verifiers, conjugate_port_verifiers)\n    return render_params, verification_params\nbasepath = os.path.dirname(__file__)\ntemplate_path = \"prolog_gen.pro.j2\"\ntemplate_abs_path = os.path.join(basepath, template_path)\nos.environ['NO_PYTHON_TYPECHECK'] = 'True'\nfrom jinja_utils import load_template_text\nwith open(template_abs_path, 'r') as f:"
        },
        {
            "comment": "This code snippet contains functions for rendering Prolog code and performing dynamic topology verification. The `render_prolog_code` function renders the template Prolog code, while `dynamic_verify_topo_object` converts a topology to render parameters and verification params. If using Prolog code, it executes the script and checks if can proceed; otherwise, it executes Python code. The result is either a can_proceed boolean and isomorphic_topo_status.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_utils.py.j2\":162-184",
            "content": "    template_content = f.read()\n    template_obj = load_template_text(template_content)\ndef render_prolog_code(render_params):\n    prolog_code = template_obj.render(**render_params)\n    logger_print(\"prolog code:\", prolog_code)\n    return prolog_code\ndef dynamic_verify_topo_object(topo):\n    render_params, verification_params = convert_topo_to_prolog_render_params_and_verification_params(topo)\n    adder_index_to_port_name, port_verifiers, conjugate_port_verifiers = verification_params\n    adderNameToAdderPortNames = render_params[\"adderNameToAdderPortNames\"]\n    if ies_env.USE_PROLOG_CODE:\n        prolog_script_content = render_prolog_code(render_params)\n        can_proceed, isomorphic_topo_status = execute_prolog_script_and_check_if_can_proceed(prolog_script_content, adder_index_to_port_name, port_verifiers, conjugate_port_verifiers, adderNameToAdderPortNames)\n    else:\n        can_proceed, isomorphic_topo_status = execute_python_code_and_check_if_can_proceed(render_params, adder_index_to_port_name, port_verifiers, conjugate_port_verifiers, adderNameToAdderPortNames)"
        },
        {
            "comment": "The code is defining functions for querying a prolog script using the Swipl server, setting table and stack limits from configs, and handling temporary directories. It uses various imports such as `PrologMQI`, `PrologThread` and utilities like `chdir_context` and `tempfile`. The code is part of a larger system that likely involves complex queries using Prolog scripts.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_utils.py.j2\":186-218",
            "content": "    return can_proceed, isomorphic_topo_status\n##############################################\nfrom error_utils import ErrorManager\nfrom failsafe_utils import chdir_context\n##############################################\nfrom swiplserver import PrologMQI, PrologThread\nfrom pydantic import BaseModel\nfrom typing import List, Dict\n# from HashableDict.HashableDict import HashDict\nfrom frozendict import frozendict\nimport rich\nimport os\nimport tempfile\nfrom config import ies_env\nbanner = lambda title: logger_print(title.center(60, \"-\"))\n{# PROLOG_STACK_LIMIT = 8 #}\n{# PROLOG_STACK_LIMIT = 4 # in GB #}\nPROLOG_STACK_LIMIT = ies_env.PROLOG_STACK_LIMIT\nPROLOG_SHARED_TABLE_LIMIT = ies_env.PROLOG_SHARED_TABLE_LIMIT\nPROLOG_TABLE_SIZE_LIMIT = ies_env.PROLOG_TABLE_SIZE_LIMIT\ndef query_result_from_prolog(prolog_script_content: str, adder_index_to_port_name, adderNameToAdderPortNames):\n    banner(\"querying\")\n    topology_status_dict = {}\n    with tempfile.TemporaryDirectory() as temp_dir:\n        with chdir_context(temp_dir):\n            prolog_file_path = \"prolog_script.pro\""
        },
        {
            "comment": "This code sets up a Prolog environment by creating a Prolog script file, then initializes a PrologMQI object with optional stack limit, shared table space limit, and table size limit arguments. It opens the script file in write mode, writes the prolog_script_content to it, then creates a Prolog thread using the PrologMQI object. Finally, it calls query_prolog_in_context function passing necessary parameters for execution.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_utils.py.j2\":219-236",
            "content": "            prolog_file_path_abs = os.path.join(prolog_file_path)\n            prolog_path_args = []\n            if PROLOG_STACK_LIMIT is not None:\n                prolog_path_args.append(f\"--stack-limit={PROLOG_STACK_LIMIT}G\")\n            if PROLOG_SHARED_TABLE_LIMIT is not None:\n                prolog_path_args.append(f\"--shared-table-space={PROLOG_SHARED_TABLE_LIMIT}G\")\n            if PROLOG_TABLE_SIZE_LIMIT is not None:\n                prolog_path_args.append(f\"--table-space={PROLOG_TABLE_SIZE_LIMIT}G\")\n            with open(prolog_file_path_abs, \"w+\") as f:\n                f.write(prolog_script_content)\n            with PrologMQI(prolog_path_args = prolog_path_args) as mqi:\n                with mqi.create_thread() as prolog_thread:\n                    topology_status_dict = query_prolog_in_context(\n                        topology_status_dict,\n                        prolog_file_path,\n                        prolog_thread,\n                        adder_index_to_port_name,\n                        adderNameToAdderPortNames"
        },
        {
            "comment": "This code defines a function `get_all_combinations` which takes three inputs: `portNameToPortPossibleStates`, `energyTypeToPortNames`, and `adderNameToAdderPortNames`. It generates all possible combinations of ports and adapters for energy types and returns them. The code also defines some other functions like `construct_query_result_iterator` and utilities such as `progressbar`, `hashlib`, and `itertools`.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_utils.py.j2\":237-271",
            "content": "                    )\n    return topology_status_dict\ndef construct_query_result_iterator(thread, query):\n    thread.query_async(query, find_all=False)\n    while True:\n        it = thread.query_async_result()\n        if it is not None:\n            yield it\n        else:\n            break\nimport progressbar\nimport hashlib\nimport itertools\ndef get_all_combinations(portNameToPortPossibleStates, energyTypeToPortNames, adderNameToAdderPortNames):\n    port_name_to_possible_energy_types = {}\n    for k,vlist in energyTypeToPortNames.items():\n        for v in vlist:\n            if v not in port_name_to_possible_energy_types.keys():\n                port_name_to_possible_energy_types[v] = [k]\n            port_name_to_possible_energy_types[v].append(k)\n    adder_name_list = list(adderNameToAdderPortNames.keys())\n    possible_simutaneous_adder_energy_types = set()\n    adder_name_to_possible_adder_energy_types = {}\n    for adder_name, _port_name_list in adderNameToAdderPortNames.items():\n        paet = set()\n        for pn in _port_name_list:"
        },
        {
            "comment": "Code snippet handles possible energy types for ports and adders in a microgrid configuration. It updates port energy type sets, adds exclusive rules for all ports, and generates combinations of possible adder energy types. It also checks if `possible_adder_energy_types` can be retrieved from Prolog.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_utils.py.j2\":272-291",
            "content": "            {# ets = [et for et in port_name_to_possible_energy_types[pn] if et != UNKNOWN] #}\n            {# if we do that then the energy type will just be undetermined #}\n            {# so we would rather assign all possible energy types to the disjunctive device or the directed line device #}\n            {# and add some exclusive rules for all ports #}\n            {# these devices might not be defined in the excel #}\n            ets = port_name_to_possible_energy_types[pn]\n            paet.update(ets)\n        adder_name_to_possible_adder_energy_types[adder_name] = paet\n    possible_simutaneous_adder_energy_types = []\n    possible_simutaneous_adder_energy_types = list(itertools.product(*adder_name_to_possible_adder_energy_types.values()))\n    result = []\n    # get `possible_adder_energy_types` from prolog?\n    for simutaneous_adder_energy_types in possible_simutaneous_adder_energy_types:\n        simutaneous_state = []\n        # all idle, otherwise at least one input one output\n        aet_to_ps_l = []"
        },
        {
            "comment": "The code iterates through energy types for simultaneous adders, checks the possible states and energy types for each port name, creates a list of valid state combinations for each adder, generates all possible state combinations from these lists, filters out invalid combinations, and appends the final list of combinations to result. The macro defines functions for initializing adder name list and index mapping based on adder index to port name query.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_utils.py.j2\":292-317",
            "content": "        for adder_index, aet in enumerate(simutaneous_adder_energy_types):\n            sasp = []\n            adder_name = adder_name_list[adder_index]\n            _port_name_list = adderNameToAdderPortNames[adder_name]\n            psl = []\n            for pn in _port_name_list:\n                ppet = port_name_to_possible_energy_types[pn]\n                pps = portNameToPortPossibleStates[pn]\n                if aet in ppet:\n                    ps = pps\n                else:\n                    assert 'idle' in pps\n                    ps = ['idle']\n                psl.append(ps)\n            for elem in itertools.product(*psl):\n                if all([e == 'idle' for e in elem]) or ('input' in elem and 'output' in elem):\n                    sasp.append([aet, elem])\n            aet_to_ps_l.append(sasp)\n        for elem in itertools.product(*aet_to_ps_l):\n            simutaneous_state.append(elem)\n        result.extend(simutaneous_state)\n    return result\n{% macro query_result_mixin()%}\n    adder_name_list, adder_index_mapping = query_init(adder_index_to_port_name)"
        },
        {
            "comment": "This code defines a function `query_result_from_python` that calls `query_result_mixin()` macro and uses another helper function `parse_status_list`. The `query_result_from_python` function retrieves a list of possible status combinations based on input parameters, then the `parse_status_list` function processes these combinations to create a dictionary representing the status of each port in the topology. The code also includes progress bar functionality for tracking progress during processing.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_utils.py.j2\":319-341",
            "content": "{{caller()}}\n    logger_print(\"parsing result\")\n    topology_status_dict = parse_status_list(STATUS_LIST, adder_index_mapping, adder_index_to_port_name, adderNameToAdderPortNames)\n    logger_print('result parsed')\n    return topology_status_dict\n{% endmacro%}\ndef query_result_from_python(render_params, adder_index_to_port_name, adderNameToAdderPortNames):\n{% call query_result_mixin()%}\n    STATUS_LIST = get_all_combinations(render_params['portNameToPortPossibleStates'], render_params['energyTypeToPortNames'], render_params['adderNameToAdderPortNames'])\n{% endcall%}\ndef parse_status_list(STATUS_LIST, adder_index_mapping, adder_index_to_port_name, adderNameToAdderPortNames):\n    topology_status_dict = {}\n    for simutaneous_status in progressbar.progressbar(STATUS_LIST):\n        adder_status_dict = {}\n        port_status_dict = {}\n        for _index, adder_simutaneous_status in enumerate(simutaneous_status):\n            adder_index = adder_index_mapping[_index]\n            adder_name = \"adder{}\".format(str(adder_index).replace('-','_'))"
        },
        {
            "comment": "This function generates the status dictionary for an adder, logging its energy type and port statuses, then updates a larger topology status dictionary.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_utils.py.j2\":342-359",
            "content": "            adder_energy_type, adder_port_status = adder_simutaneous_status\n            adder_status_dict[adder_index] = adder_energy_type\n            {# logger_print(f\"adder #{adder_index}\")\n            logger_print(f\"\\tenergy type: {adder_energy_type}\")\n            logger_print(f\"\\tport_status:\") #}\n            port_index_to_port_name = adder_index_to_port_name[adder_index]\n            for _port_index, port_status in enumerate(adder_port_status):\n                port_name = adderNameToAdderPortNames[adder_name][_port_index]\n                {# port_name = port_index_to_port_name[adder_port_index] #}\n                port_status_dict[port_name] = port_status\n                {# logger_print(f\"\\t\\t{port_name}: {port_status}\") #}\n        key = frozendict(adder_status_dict)\n        value = frozendict(port_status_dict)\n        if key not in topology_status_dict.keys():\n            topology_status_dict[key] = set()\n        topology_status_dict[key].add(value)\n        {# logger_print(\"-\" * 60) #}\n    return topology_status_dict"
        },
        {
            "comment": "The code defines two functions: `query_prolog_common` and `query_init`. The `query_prolog_common` function takes a list of adder names, a Prolog file path, and a Prolog thread. It queries the Prolog database using the provided file path and adder names to retrieve the status of each adder. It then filters and returns the unique statuses in a list. The `query_init` function generates a list of adder names from an index-to-port-name dictionary and creates an index mapping for later reference.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_utils.py.j2\":361-389",
            "content": "def query_prolog_common(adder_name_list, prolog_file_path, prolog_thread):\n    adder_names = \", \".join(adder_name_list)\n    logger_print('adder_names: ',adder_names)\n    prolog_thread.query(f'[\"{prolog_file_path}\"].')\n    logger_print(\"retrieving result\")\n    query = f\"adder_port_status_list([{adder_names}], STATUS)\"\n    _iterator = construct_query_result_iterator(prolog_thread, query)\n    STATUS_LIST = []\n    hashset = set()\n    for result in progressbar.progressbar(_iterator):\n        STATUS = result[0][\"STATUS\"]\n        status_hash = hashlib.md5(str(STATUS).encode()).hexdigest()\n        if status_hash not in hashset:\n            hashset.add(status_hash)\n            STATUS_LIST.append(STATUS)\n    return STATUS_LIST\ndef query_init(adder_index_to_port_name):\n    adder_name_list = []\n    adder_index_mapping = {}\n    for i, k in enumerate(adder_index_to_port_name.keys()):\n        adder_name_list.append(\"adder{}\".format(str(k).replace('-','_')))\n        adder_index_mapping[i] = k\n    return adder_name_list, adder_index_mapping"
        },
        {
            "comment": "The function `query_prolog_in_context` takes in a dictionary, path to prolog file, thread for querying prolog, and two dictionaries mapping indexes to port names. It returns the list of status values from a common prolog query function. The `verify_topology_status_dict` function prints a banner, logs the unverified topology status dictionary, then verifies each entry in the dictionary by iterating over its items and creating a new verified dictionary. This function utilizes two other dictionaries to map indexes to port names and store cached verifiers for efficiency.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_utils.py.j2\":391-427",
            "content": "def query_prolog_in_context(\n    topology_status_dict, prolog_file_path, prolog_thread, adder_index_to_port_name, adderNameToAdderPortNames\n):\n{% call query_result_mixin()%}\n    STATUS_LIST = query_prolog_common(adder_name_list, prolog_file_path, prolog_thread)\n{% endcall%}\ndef verify_topology_status_dict(\n    topology_status_dict,\n    port_verifiers,\n    conjugate_port_verifiers,\n    adder_index_to_port_name,\n):\n    banner(\"unverified topo status\")\n    logger_print(topology_status_dict)\n    banner(\"verifying\")\n    verified_topology_status_dict = {}\n    cached_conjugate_verifiers = {}\n    cached_port_verifiers = {}\n    for topo_status_index, (adder_status, topo_status) in enumerate(\n        topology_status_dict.items()\n    ):\n        topo_status_frame_flatten = {}\n        port_verified = {}\n        conjugate_port_verified = {}\n        port_name_to_energy_type = {\n            v_v: adder_status[k]\n            for k, v in adder_index_to_port_name.items()\n            for v_k, v_v in v.items()\n        }\n        for topo_status_frame in topo_status:"
        },
        {
            "comment": "Iterates over a dictionary of port names and their statuses, flattening the resulting data structure as needed. Ensures each port name exists in the flattened dictionary and initializes necessary variables for error management. The code then iterates over pairs of conjugate ports and verifiers, checking conditions for each port to determine if it has been found or is idle.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_utils.py.j2\":428-448",
            "content": "            for topo_status_frame_index, (port_name, port_status) in enumerate(\n                topo_status_frame.items()\n            ):\n                # breakpoint()\n                if port_name not in topo_status_frame_flatten.keys():\n                    topo_status_frame_flatten[port_name] = set()\n                _conjugate_verified = True\n                cached_quit = False\n                with ErrorManager(suppress_error=True) as em:\n                    for (\n                        conjugate_ports,\n                        conjugate_verifier,\n                    ) in conjugate_port_verifiers.items():\n                        # if not found, then skip this port or idle?\n                        conds = [\n                            topo_status_frame.get(port_name, UNKNOWN)\n                            for port_name in conjugate_ports\n                        ]\n                        energytypes = [\n                            port_name_to_energy_type.get(port_name, UNKNOWN)\n                            for port_name in conjugate_ports"
        },
        {
            "comment": "This code checks if the cache_key of conjugate ports, conditions, and energy types is in the dictionary of cached conjugate verifiers. If it exists, it retrieves the conjugate verification result from the cache; otherwise, it calculates the result using the conjugate verifier function and adds it to the cache for future use.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_utils.py.j2\":449-464",
            "content": "                        ]\n                        cache_key = (tuple([portNameTransformer(cp) for cp in conjugate_ports]), tuple(conds), tuple(energytypes))\n                        {# cache_key = (tuple(conjugate_ports), tuple(conds), tuple(energytypes)) #}\n                        cached = False\n                        if cache_key in cached_conjugate_verifiers.keys():\n                            cached = True\n                            conjugate_verified = cached_conjugate_verifiers[cache_key]\n                        else:\n                            conjugate_verified = conjugate_verifier(*conds, *energytypes)\n                            cached_conjugate_verifiers[cache_key] = conjugate_verified\n                        # conjugate_verified = conjugate_verifier(*conds)\n                        if not conjugate_verified:\n                            if not cached:\n                                em.append('-'*60)\n                                em.append(\n                                    f\"conjugat"
        },
        {
            "comment": "The code checks the verification of conjugate ports in a topo status frame and appends relevant information to 'em'. If verification fails, it skips the topo status frame. This helps save processing power by not processing frames with failed conjugate port verification. The code also logs why the frame is being skipped if necessary.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_utils.py.j2\":464-480",
            "content": "e verification failed for conjugate ports '{conjugate_ports}' at topo status frame #{topo_status_frame_index} (calculated)\"\n                                )\n                                em.append(\"conds: \"+repr(conds))\n                                em.append(\"energy types: \"+repr(energytypes))\n                                {# em.append(f\"topo status frame: {topo_status_frame}\") #}\n                            if not cached_quit:\n                                cached_quit = True\n                            if _conjugate_verified:\n                                _conjugate_verified = False\n                                break # to save processing power\n                if _conjugate_verified:\n                    topo_status_frame_flatten[port_name].add(port_status)\n                else:\n                    if not cached_quit:\n                        logger_print(\n                        f\"skipping topo status frame #{topo_status_frame_index} due to failed conjugate ports verification\"\n                    )"
        },
        {
            "comment": "The code is iterating through port verifiers and their corresponding names. It checks if a cache key, formed by the port name and conditions, already exists in the cached_port_verifiers dictionary. If it does, the verified status is retrieved from the cache; otherwise, the verifier function is called with the conditions to determine the verified status. If any verifier fails, a log message is printed. Finally, it checks if all ports and their conjugates are verified and stores the topology verification status in the topo_verified variable.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_utils.py.j2\":481-501",
            "content": "        for port_name, verifier in port_verifiers.items():\n            conds = topo_status_frame_flatten.get(port_name, [UNKNOWN])\n            {# conds = topo_status_frame_flatten[port_name] #}\n            cached = False\n            cache_key = (portNameTransformer(port_name), tuple(conds))\n            {# cache_key = (port_name, tuple(conds)) #}\n            if cache_key in cached_port_verifiers.keys():\n                verified = cached_port_verifiers[cache_key]\n                cached = True\n            else:\n                verified = verifier(conds)\n                cached_port_verifiers[cache_key] = verified\n            port_verified[port_name] = verified\n            if not verified:\n                logger_print(f\"verifier failed for port '{port_name}', conds: {repr(conds)} (calculated)\")\n        all_ports_verified = all(port_verified.values())\n        all_conjugate_ports_verified = all(conjugate_port_verified.values())\n        topo_verified = all_ports_verified and all_conjugate_ports_verified\n        if not all_ports_verified:"
        },
        {
            "comment": "This code verifies the validity of port configurations and topology statuses. It checks if all ports are valid, if conjugate ports match, and performs topology verification for each status in the given dictionary. If any validation fails, it logs an error message. Otherwise, it updates a dictionary with the verified topology statuses and returns them.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_utils.py.j2\":502-526",
            "content": "            logger_print(\"not all port vaildations have passed\")\n        if not all_conjugate_ports_verified:\n            logger_print(\"not all conjugate port vaildations have passed\")\n        if not topo_verified:\n            logger_print(f\"topo verification failed for topo status #{topo_status_index}\")\n        else:\n            if len(topo_status) > 0:\n                verified_topology_status_dict[adder_status] = topo_status\n            else:\n                logger_print(\"skipping due to empty topo status\")\n        banner(f\"processed topo status #{topo_status_index}\")\n    banner(\"verified topo status\")\n    # if you want verbosity...\n    {# logger_print(verified_topology_status_dict) #}\n    return verified_topology_status_dict\ndef isomorphicTopologyStatusCombinator(topology_status_dict: dict):\n    topo_status_to_adder_status_dict: Dict[frozenset, set] = {}\n    for adder_index_to_energy_type, topo_status in topology_status_dict.items():\n        topo_status_frozen = frozenset(topo_status)\n        if topo_status_frozen not in topo_status_to_adder_status_dict.keys():"
        },
        {
            "comment": "This function creates a dictionary mapping topology status \"frozen\" to the energy type adder indexes. It then checks if there is an isomorphic topology for a given verified topology status dictionary, returning True or False accordingly. The function also prints information about the possible adder energy type set counts and isomorphic topology status counts using logger_print statements.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_utils.py.j2\":527-553",
            "content": "            topo_status_to_adder_status_dict[topo_status_frozen] = set()\n        topo_status_to_adder_status_dict[topo_status_frozen].add(\n            adder_index_to_energy_type\n        )\n    return topo_status_to_adder_status_dict\ndef check_if_can_proceed(verified_topology_status_dict):\n    isomorphic_topo_status = None\n    possible_adder_energy_type_set_counts = len(verified_topology_status_dict)\n    logger_print(\n        \"possible adder energy type set counts:\", possible_adder_energy_type_set_counts\n    )\n    isomorphic_topo_status = isomorphicTopologyStatusCombinator(\n        verified_topology_status_dict\n    )\n    banner(\"isomorphic topo status (converted)\")\n    for k,v in isomorphic_topo_status.items():\n        logger_print('key:',*[f'\\t{str(e_k)}' for e_k in k], 'value:', f'\\t{v}')\n    isomorphic_topo_status_counts = len(isomorphic_topo_status.keys())\n    logger_print(\"isomorphic topo status counts:\", isomorphic_topo_status_counts)\n    can_proceed = False\n    if isomorphic_topo_status_counts == 0:\n        logger_print(\"no adder energy type set\")"
        },
        {
            "comment": "Code is a part of a microgrid base program. The \"check_if_can_proceed\" function checks if the topology status has multiple adder energy type sets, and returns whether it can proceed or not along with the isomorphic topology status. The \"check_if_can_proceed_common\" function verifies the topology status dictionary and calls check_if_can_proceed function. The \"execute_python_code_and_check_if_can_proceed\" function queries the result from a Python script, then calls \"check_if_can_proceed_common\" to perform the main functionality.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_utils.py.j2\":554-574",
            "content": "    elif isomorphic_topo_status_counts > 1:\n        logger_print(\"multiple adder energy type sets found\")\n    else:\n        can_proceed = True\n    if not can_proceed:\n        logger_print(\"cannot proceed\")\n    else:\n        logger_print(\"clear to proceed\")\n    return can_proceed, isomorphic_topo_status\ndef check_if_can_proceed_common(topology_status_dict, port_verifiers, conjugate_port_verifiers, adder_index_to_port_name):\n    verified_topology_status_dict = verify_topology_status_dict(\n        topology_status_dict, port_verifiers, conjugate_port_verifiers, adder_index_to_port_name\n    )\n    can_proceed, isomorphic_topo_status = check_if_can_proceed(verified_topology_status_dict)\n    return can_proceed, isomorphic_topo_status\ndef execute_python_code_and_check_if_can_proceed(render_params, adder_index_to_port_name, port_verifiers, conjugate_port_verifiers, adderNameToAdderPortNames):\n    topology_status_dict = query_result_from_python(render_params, adder_index_to_port_name, adderNameToAdderPortNames)\n "
        },
        {
            "comment": "This code includes two functions, `execute_prolog_script_and_check_if_can_proceed` and `weak_type_check`, with the latter potentially being unnecessary due to changes in approach. The execute function queries the Prolog script using provided parameters and returns the result of a common check function.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_utils.py.j2\":574-591",
            "content": "   return check_if_can_proceed_common(topology_status_dict, port_verifiers, conjugate_port_verifiers, adder_index_to_port_name)\ndef execute_prolog_script_and_check_if_can_proceed(\n    prolog_script_content,\n    adder_index_to_port_name,\n    port_verifiers,\n    conjugate_port_verifiers,\n    adderNameToAdderPortNames\n):\n    topology_status_dict = query_result_from_prolog(\n        prolog_script_content, adder_index_to_port_name, adderNameToAdderPortNames\n    )\n    return check_if_can_proceed_common(topology_status_dict, port_verifiers, conjugate_port_verifiers, adder_index_to_port_name)\ndef weak_type_check():...\n    {# this time we might not need prolog #}\n    {# or could you rewrite the prolog with something else? #}\n    {# or just do everything within prolog #}"
        }
    ]
}