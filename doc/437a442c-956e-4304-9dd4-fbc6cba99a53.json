{
    "summary": "This code tests failsafe methods in microgrid_base, creating a directory for logs, defining functions for infeasible power values, loading data from a JSON file, and saving an infeasible model. The test function runs for each failsafe method and parameter combination, storing results in a report.",
    "details": [
        {
            "comment": "This code tests the failsafe mechanism by setting a True value in the FAILSAFE environment variable. It creates a directory for failsafe solver logs, if it doesn't already exist, and defines functions to get infeasible power values and load data from a JSON file.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/test/test_failsafe.py\":0-40",
            "content": "# test if failsafe mechanism is working.\nimport os\nos.environ[\"FAILSAFE\"] = \"True\"\nfrom common_fixtures import *\n# import pytest\nif not os.path.exists(failsafe_logdir := \"failsafe_solver_logs\"):\n    os.mkdir(failsafe_logdir)\nfailsafe_logdir = os.path.abspath(failsafe_logdir)\nimport json\n# import pickle\nimport copy\ndef get_infeasible_mw():\n    input_params = copy.deepcopy(infeasible_input)\n    efg = EnergyFlowGraph.parse_obj(input_params)\n    mDictList = efg.dict()[\"mDictList\"]\n    calcParamList = mDictListToCalcParamList(mDictList)\n    firstParam_graphparam = calcParamList[0][2]\n    \u5178\u578b\u65e5 = firstParam_graphparam[\"\u5178\u578b\u65e5\"]\n    \u8ba1\u7b97\u6b65\u957f = firstParam_graphparam[\"\u8ba1\u7b97\u6b65\u957f\"]\n    \u8ba1\u7b97\u7c7b\u578b = firstParam_graphparam[\"\u8ba1\u7b97\u7c7b\u578b\"]\n    calcTarget = \u8ba1\u7b97\u76ee\u6807 = firstParam_graphparam[\"\u8ba1\u7b97\u76ee\u6807\"]\n    mw = ModelWrapper()\n    ret = getCalcStruct(mw, calcParamList, \u5178\u578b\u65e5, \u8ba1\u7b97\u6b65\u957f, \u8ba1\u7b97\u7c7b\u578b)\n    obj_expr = ret.calcTargetLUT[calcTarget]\n    sense = minimize\n    OBJ = mw.Objective(expr=obj_expr, sense=sense)\n    return mw\ninfeasible_model_input_path = \"sample_data/input_abnormal.json\""
        },
        {
            "comment": "This code is loading or creating an infeasible model and then saving it as \"infeasible_model.lp\". The code also defines multiple parameters for different solvers, some of which may get stuck during execution.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/test/test_failsafe.py\":41-71",
            "content": "# infeasible_pickle = \"sample_data/infeasible_abnormal.pickle\"\n# if os.path.exists(infeasible_pickle):\n#     with open(infeasible_pickle, 'rb') as f:\n#         infeasible_model= pickle.load(f)\n# else:\nwith open(infeasible_model_input_path, \"r\") as f:\n    infeasible_input = json.load(f)\ninfeasible_mw = get_infeasible_mw()\ninfeasible_mw.model.write(\"infeasible_model.lp\")\n# infeasible_model = infeasible_mw.model\n# with open(infeasible_pickle, 'wb') as f:\n#     pickle.dump(infeasible_model, f)\n# @pytest.fixture\n# def infeasible_modelwrapper():\n#     return infeasible_mw\n#     # mw = ModelWrapper()\n#     # mw.model = infeasible_model\n#     # # mw.model = infeasible_mw.model.clone() # taking eternal.\n#     # return mw\n# sometimes these will stuck\n# but i think ipopt may always stuck.\nparams = [\n    # [feasopt_with_optimization, \"feasopt_with_optimization\"],\n    # [feasopt_only, \"feasopt_only\"],\n    [scip_minuc, \"scip_minuc\"],\n    # [ipopt_no_presolve, \"ipopt_no_presolve\"],\n    [random_value_assignment, \"random_value_assignment\"],"
        },
        {
            "comment": "This code defines a test function for failsafe methods in microgrid_base, which checks if the failsafe method can solve an infeasible model. It prints whether the failsafe method has succeeded or failed and returns the solution status and logfile existence. The code runs these tests for each failsafe method and parameter combination in 'params' list, storing results in a report for later display.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/test/test_failsafe.py\":72-96",
            "content": "]\n# @pytest.mark.parametrize(\"failsafe_method, method_name\",params)\n# def test_failsafe_method(infeasible_modelwrapper,failsafe_method, method_name):\n#     _test_failsafe_method(infeasible_modelwrapper, failsafe_method, method_name)\ndef _test_failsafe_method(infeasible_modelwrapper, failsafe_method, method_name):\n    solved, logfile = failsafe_method(infeasible_modelwrapper, failsafe_logdir)\n    # breakpoint()\n    if not solved:\n        print(f\"failsafe method <{method_name}> has failed.\")\n    else:\n        print(f\"failsafe method <{method_name}> has succeeded.\")\n    return solved, logfile\nif __name__ == \"__main__\":\n    report = []\n    for failsafe_method, method_name in params:\n        print(\"running:\", method_name)\n        r, l = _test_failsafe_method(infeasible_mw, failsafe_method, method_name)\n        report.append((method_name, r, os.path.exists(l)))\n    for n, r, l_exists in report:\n        print(f\"{n}:\\t{r}\\t(logfile exists? {l_exists})\")"
        }
    ]
}