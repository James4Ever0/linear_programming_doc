{
    "summary": "Python code processes JSON files for cloud-based simulation and optimization in electrical devices, using DataFrames, handling pin definitions, and translating parameter names into multiple languages.",
    "details": [
        {
            "comment": "This Python code defines two parameter format strings for simulation and optimization inputs in a cloud-based software. The simulation input includes basic, modeling, and optimization parameters for electrical devices, while the optimization input provides detailed information on group parameters, calculation parameters, and load settings.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/cloudpss_config_curl_get.py\":0-67",
            "content": "sources_curl_get = dict(simu=\"cloudpss_simu.mjson\",optim=\"cloudpss_optim.mjson\", )\n# almost the same as `cloudpss_config2.py`, with slight alternation.\n# choice = \"optim\"\nchoices = sources_curl_get.keys()\nparam_translate_maps = dict(\n    simu=dict(\n        \u53c2\u6570\u5206\u7c7b=[],\n        \u4e2d\u6587\u540d\u79f0=[],  # create it later. join with \"/\"\n        \u6709\u5173\u8bbe\u5907=[],  # join with \", \"\n    ),\n    optim=dict(\u53c2\u6570\u5206\u7c7b=[], \u4e2d\u6587\u540d\u79f0=[], \u6709\u5173\u8bbe\u5907=[]),\n)\nprelude = \"\"\"\n# \u5efa\u6a21\u4eff\u771f\u548c\u89c4\u5212\u8bbe\u8ba1\u7684\u8f93\u5165\u53c2\u6570\u548c\u533a\u522b\n\u89c4\u5212\u8bbe\u8ba1\u5728\u8bbe\u5907\u4fe1\u606f\u5e93\u5185\u6dfb\u52a0\u4e86\u7ecf\u6d4e\u6027\u53c2\u6570\uff0c\u800c\u5efa\u6a21\u4eff\u771f\u5bf9\u67d0\u4e9b\u8bbe\u5907\u5c06\u989d\u5b9a\u5de5\u51b5\u53d8\u4e3a\u4e86\u591a\u5de5\u51b5\u7684\u8f93\u5165\u3002\n<br><br>\u6839\u636e\u5e03\u5c14\u8868\u8fbe\u5f0f\uff0c\u6709\u7684\u8f93\u5165\u9879\u6240\u586b\u5199\u7684\u503c\u51b3\u5b9a\u5176\u4ed6\u53c2\u6570\u662f\u5426\u80fd\u591f\u586b\u5199\u3002\n<br><br>\u4e0b\u9762\u4ecb\u7ecd\u5728\u80fd\u6d41\u62d3\u6251\u56fe\u4e2d\u4e24\u79cd\u6a21\u5f0f\u7684\u8f93\u5165\u9879\u533a\u522b\uff1a\n\"\"\"\nprint(prelude)\nsimu_format_string = \"\"\"\n## \u5efa\u6a21\u4eff\u771f\u53c2\u6570\n### \u53c2\u6570\u5206\u7c7b\n{table}\n#### \u57fa\u7840\u53c2\u6570\n\u8981\u6307\u5b9a\u8bbe\u5907\u53f0\u6570\n#### \u4eff\u771f\u53c2\u6570\n\u914d\u7535\u4f20\u8f93\u8bbe\u5907\u9664\u6a21\u5757\u5316\u591a\u7535\u5e73\u53d8\u6d41\u5668\u90fd\u4e0d\u5177\u5907\u4eff\u771f\u53c2\u6570\uff0c\u53ca\u7ba1\u9053\u3001\u91c7\u6696\u5236\u51b7\u8d1f\u8377\u3001\u7535\u8d1f\u8377\u90fd\u4e0d\u5177\u5907\n#### \u4f18\u5316\u53c2\u6570\n\u5177\u5907\u4f18\u5316\u53c2\u6570\u7684\u8bbe\u5907\u53ef\u9009\u662f\u5426\u4f18\u5316\uff0c\u90e8\u5206\u8bbe\u5907\u4f18\u5316\u53c2\u6570\u5177\u6709\u5176\u4ed6\u53c2\u6570\uff0c\u4f8b\u5982\u67d4\u6027\u7535\u8d1f\u8377\u7684\u6700\u5927\u8d1f\u8377\n#### \u8fd0\u884c\u7ea6\u675f\n\u91c7\u6696\u5236\u51b7\u8d1f\u8377\u5177\u5907\u8fd0\u884c\u7ea6\u675f\uff0c\u4f9b\u70ed/\u5236\u51b7\u6700\u5927\u3001\u6700\u5c0f\u51fa\u53e3\u6e29\u5ea6\u3002\n### \u8be6\u7ec6\u8bf4\u660e\n{detail}\n\"\"\"\noptim_format_string = \"\"\"\n## \u89c4\u5212\u8bbe\u8ba1\u53c2\u6570\n{table}\n### \u673a\u7ec4\u53c2\u6570\n\u5728\u6ca1\u6709\u9009\u62e9\u5177\u4f53\u8bbe\u5907\u65f6\uff0c\u4e0d\u80fd\u6307\u5b9a\u8bbe\u5907\u53f0\u6570\uff0c\u4f46\u53ef\u4ee5\u6307\u5b9a\u8bbe\u5907\u989d\u5b9a\u8fd0\u884c\u53c2\u6570\u3002\u6307\u5b9a\u4e86\u8bbe\u5907\u7c7b\u578b\u65f6\uff0c\u53ef\u4ee5\u6307\u5b9a\u8bbe\u5907\u53f0\u6570\uff0c\u4f46\u662f\u4e0d\u80fd\u6307\u5b9a\u989d\u5b9a\u8fd0\u884c\u53c2\u6570\u3002\n\u90e8\u5206\u53c2\u6570\n### \u8fd0\u884c\u53c2\u6570\u7ec4\n\u4e0d\u80fd\u6307\u5b9a\u90e8\u5206\u53c2\u6570\uff0c\u6216\u8005\u53ef\u9009\u6307\u5b9a\u90e8\u5206\u53c2\u6570\n### \u8ba1\u7b97\u53c2\u6570\u7ec4\n\u6709\u7684\u8bbe\u5907\u6ca1\u6709\u8ba1\u7b97\u53c2\u6570\u7ec4\uff0c\u4f8b\u5982\u5438\u6536\u5f0f\u5236\u51b7\u673a\uff0c\u4f59\u70ed\u9505\u7089\n### \u8d1f\u8377\u8bbe\u7f6e\n\u8d1f\u8377\u5143\u4ef6\u7279\u6709\u7684\u8bbe\u7f6e\n### \u8be6\u7ec6\u8bf4\u660e\n{detail}\n\"\"\"\nformat_strings = {\"simu\": simu_format_string,\"optim\": optim_format_string, }"
        },
        {
            "comment": "Code reads a JSON file and converts its contents into a markdown table, with appropriate headings. It also keeps track of existing keys to avoid repetition.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/cloudpss_config_curl_get.py\":70-111",
            "content": "import json\nimport pandas as pd\nprint_list = []\ndef append_candidate(*args):\n    global print_list\n    if len(args) == 0:\n        print_list.append(\"\")\n    else:\n        print_list.append(\" \".join(args))\nfor choice in choices:\n    mjson_path = sources_curl_get[choice]\n    # question: convert pandas dataframe to markdown table.\n    headliner = lambda level: \"#\" * level\n    with open(mjson_path, \"r\", encoding=\"utf-8\") as f:\n        lines = f.readlines()\n    level_shift = 1\n    param_class_name_dict = {}\n    existing_keys = []\n    for line in lines:\n        try:\n            data = json.loads(line.strip())\n            param = data[\"ele\"][\"param\"]\n            key_prefix = name = param[\"name\"]\n        except:\n            # obviously we've hit something hard.\n            continue\n        if key_prefix not in existing_keys:\n            existing_keys.append(key_prefix)\n            append_candidate()\n            append_candidate(headliner(level_shift + 2), key_prefix)\n            append_candidate()\n            append_candidate(headliner(level_shift + 3), \"\u8bbe\u5907\u4fe1\u606f\")"
        },
        {
            "comment": "This code is appending various data to a candidate, including information about the classname, name, type, and other parameters. It then creates a DataFrame for pin definitions and another for parameter filling, iterating through keys and creating headlines with appropriate level shifts. The code also handles conditional pins and connection types.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/cloudpss_config_curl_get.py\":112-141",
            "content": "            append_candidate()\n            info_keys = [\n                \"classname\",\n                \"name\",\n                \"type\",\n                \"thutype\",\n                \"ver\",\n                \"id\",\n                \"sym\",\n            ]\n            info_markdown = pd.DataFrame([{k: param[k] for k in info_keys}]).to_html()\n            append_candidate(info_markdown)\n            append_candidate()\n            pin = [v for _, v in param[\"pin\"].items()]  # iterate through keys.\n            pin_df = pd.DataFrame(pin)\n            append_candidate(headliner(level_shift + 3), \"\u9488\u811a\u5b9a\u4e49\")\n            append_candidate()\n            append_candidate(pin_df.to_html())\n            # you can also get conditional pins and connection types.\n            existing_keys = []\n            append_candidate()\n            append_candidate(headliner(level_shift + 3), \"\u53c2\u6570\u586b\u5199\")\n            # shall create this table for every device.\n            params = param[\"param\"]\n            input_types = list(params.keys())\n            for input_type in input_types:"
        },
        {
            "comment": "This code snippet adds input parameters to a dictionary and generates a DataFrame. The dictionary stores \"chinese_names\" and \"related_devices\" for each input type, which are added with their descriptions as well as the related key prefix. Finally, the DataFrame is converted to HTML format before being appended for further processing.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/cloudpss_config_curl_get.py\":142-165",
            "content": "                if input_type not in param_class_name_dict.keys():\n                    param_class_name_dict[input_type] = {\n                        \"chinese_names\": set(),\n                        \"related_devices\": [],\n                    }\n                component_info = []\n                input_data = params[input_type]\n                param_class_name_dict[input_type][\"chinese_names\"].add(\n                    input_data[\"desc\"]\n                )\n                param_class_name_dict[input_type][\"related_devices\"].append(key_prefix)\n                for k, v in input_data[\"params\"].items():\n                    valDict = {\"ID\": k}\n                    valDict.update({k0: v0 for k0, v0 in v.items()})\n                    component_info.append(valDict)\n                df = pd.DataFrame(component_info)\n                append_candidate()\n                append_candidate(headliner(level_shift + 4), input_type)\n                append_candidate()\n                markdown_table = df.to_html(index=False)\n                append_candidate(markdown_table)"
        },
        {
            "comment": "This code is part of a larger program that seems to involve translating parameter names into multiple languages. The specific chunk of code continues the iteration over a set of choices, populates the \"param_translate_maps\" dictionary with information about each choice, formats this data as a table and additional details, and then prints the result.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/cloudpss_config_curl_get.py\":166-187",
            "content": "        else:\n            continue\n        append_candidate()\n    param_translate_maps[choice][\"\u53c2\u6570\u5206\u7c7b\"] = list(param_class_name_dict.keys())\n    param_translate_maps[choice][\"\u4e2d\u6587\u540d\u79f0\"] = [\n        \", \".join(param_class_name_dict[k][\"chinese_names\"])\n        for k in param_translate_maps[choice][\"\u53c2\u6570\u5206\u7c7b\"]\n    ]\n    param_translate_maps[choice][\"\u6709\u5173\u8bbe\u5907\"] = [\n        \", \".join(param_class_name_dict[k][\"related_devices\"])\n        for k in param_translate_maps[choice][\"\u53c2\u6570\u5206\u7c7b\"]\n    ]\n    table = pd.DataFrame(param_translate_maps[choice]).to_html(index=False)\n    detail = \"\\n\".join(print_list)\n    formatted_string = format_strings[choice].format(table=table, detail=detail)\n    print(formatted_string)\n    print_list = []"
        }
    ]
}