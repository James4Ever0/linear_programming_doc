{
    "summary": "This code utilizes Pyomo, LogUtils, and Pydantic to check variable and constraint bounds in a microgrid system. It identifies violations and aims to handle piecewise constraints in future work. It introduces classes like PiecewiseBaseInfo, PiecewiseInfo, MagicList, and ViolationInfo for analysis using ModelScanner on ConcreteModel constraints.",
    "details": [
        {
            "comment": "The code defines a function to check for variable or constraint bounds violations and creates a class for Violation detection. It also includes functions to moderate violation tolerances and calculate lower bound violations. The code uses the Pyomo, LogUtils, and Pydantic libraries, and might involve sorting out further implementation details.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/violation_utils.py\":0-40",
            "content": "from log_utils import logger_print\n# assign invalid values to var and constraints.\n# see if the system can detect bounds/constraint violations\nfrom pyomo_environ import *\n# you might need to sort it out. check how much further it goes.\n# from pyomo.util.infeasible import log_infeasible_constraints,\nfrom pydantic import BaseModel\nfrom typing import Union, Literal, List\ndef get_var_or_constraint_bounds(var: Var):\n    lb, ub = None, None\n    if var.has_lb():\n        lb = value(var.lower, exception=False)\n    if var.has_ub():\n        ub = value(var.upper, exception=False)\n    return lb, ub\nclass VarViolation(BaseModel):\n    bound_violation: float\n    vartype_violation: float\n    @property\n    def has_violation(self):\n        return any([v > 0 for v in [self.bound_violation, self.vartype_violation]])\ndef moderate_violation(violation, tol):\n    assert tol >= 0, f\"violation tolerance must be non-negative\\npassed: {tol}\"\n    violation = abs(violation)\n    if violation <= tol:\n        violation = 0\n    return violation\ndef get_lower_bound_violation(val: float, lower_bound: Union[float, None], tol: float):"
        },
        {
            "comment": "The code consists of several utility functions for checking the validity and bounds of values. The \"get_bounds_violation\" function calculates a violation if both lower and upper bounds are provided, and checks that the lower bound is not greater than the upper bound. It then calls \"get_lower_bound_violation\" for both lower and upper bounds, and returns the first non-zero result. The \"get_boolean_or_integer_violation\" function calculates a violation based on the difference between an integer or boolean value and 0.5. The \"checker\" function constructs a checker function using a domain name and its bounds, and checks the validity of a variable against those bounds within a specified tolerance.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/violation_utils.py\":41-74",
            "content": "    violation = 0\n    if any([v is None for v in [val, lower_bound]]):\n        return violation\n    if val < lower_bound:\n        violation = moderate_violation(lower_bound - val, tol)\n    return violation\ndef get_bounds_violation(\n    val: float,\n    lower_bound: Union[float, None],\n    upper_bound: Union[float, None],\n    tol: float,\n):\n    if all([bound is not None for bound in [lower_bound, upper_bound]]):\n        assert (\n            lower_bound <= upper_bound\n        ), \"invalid bound ({lower_bound}, {upper_bound})\\nlower bound shall not be greater than upper bound.\"\n    violation = get_lower_bound_violation(val, lower_bound, tol)\n    if violation == 0:\n        violation = get_lower_bound_violation(upper_bound, val, tol)\n    return violation\ndef get_boolean_or_integer_violation(val: float, tol: float):\n    violation = val % 1\n    if violation != 0:\n        violation = min([violation, 1 - violation])\n    return moderate_violation(violation, tol)\ndef constructVarChecker(domainName: str, domainBounds):\n    def checker(var: Var, tol: float):"
        },
        {
            "comment": "This function checks if a variable's value violates its bounds or the allowed data type. It first calculates bound and datatype violations, and if a specific domain (Integers, Booleans, Binary) is detected, it further calculates the violation for that particular type. The function then returns the calculated violations along with the variable's bounds. The code also includes a function getVarCheckers() that defines checkers for different types of variables using lru_cache decorator to improve performance by caching results.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/violation_utils.py\":75-111",
            "content": "        val = value(var)\n        var_bounds = get_var_or_constraint_bounds(var)\n        bounds_violation = get_bounds_violation(val, *var_bounds, tol)\n        vartype_violation = get_bounds_violation(val, *domainBounds, tol)\n        if vartype_violation == 0:\n            if \"Integers\" in domainName or domainName in [\"Boolean\", \"Binary\"]:\n                vartype_violation = get_boolean_or_integer_violation(val, tol)\n        varViolation = VarViolation(\n            bound_violation=bounds_violation, vartype_violation=vartype_violation\n        )\n        return (varViolation, *var_bounds)\n    return checker\nfrom functools import lru_cache\n@lru_cache(maxsize=1)\ndef getVarCheckers():\n    varDomainObjs = [\n        Reals,\n        PositiveReals,\n        NonPositiveReals,\n        NegativeReals,\n        NonNegativeReals,\n        Integers,\n        PositiveIntegers,\n        NonPositiveIntegers,\n        NegativeIntegers,\n        NonNegativeIntegers,\n        Boolean,\n        Binary,\n    ]\n    checkers = {}\n    for varDomainObj in varDomainObjs:"
        },
        {
            "comment": "This code defines classes for representing variable and constraint information in a microgrid system. It includes details such as variable name, domain type, lower and upper bounds, and violation status. The classes also store constraint details like name, list of variables involved, violation value, and representation of the constraint.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/violation_utils.py\":112-153",
            "content": "        domainName = varDomainObj.name\n        domainBounds = varDomainObj.bounds()\n        checker = constructVarChecker(domainName, domainBounds)\n        checkers[domainName] = checker\n    return checkers\nclass VarInfo(BaseModel):\n    varName: str\n    val: float\n    domainName: Literal[  # usually, just need to check if it is boolean/binary/integer.\n        \"Reals\",\n        \"PositiveReals\",\n        \"NonPositiveReals\",\n        \"NegativeReals\",\n        \"NonNegativeReals\",\n        \"Integers\",\n        \"PositiveIntegers\",\n        \"NonPositiveIntegers\",\n        \"NegativeIntegers\",\n        \"NonNegativeIntegers\",\n        \"Boolean\",\n        \"Binary\",\n    ]\n    lower_bound: Union[float, None]\n    upper_bound: Union[float, None]\n    violation: VarViolation\n    @property\n    def has_violation(self):\n        return self.violation.has_violation()\nclass ConstraintInfo(BaseModel):\n    constraintName: str\n    variables: List[VarInfo]\n    violation: float\n    representation: str\n    is_linear: bool\n    @property\n    def has_violation(self):"
        },
        {
            "comment": "This function checks a variable's bounds and type for violations. If the tolerance level is exceeded, it returns a VarInfo object containing information about the variable's name, value, domain name, lower and upper bounds, and violation status.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/violation_utils.py\":154-185",
            "content": "        # TODO: consider overall violation among variables inside constraint\n        return self.violation > 0\nfrom pyomo.core.expr import current as EXPR\ndef get_violation_of_infeasible_bounds_and_vartype_of_single_var(\n    var: Var, tol=1e-6, violation_only: bool = True\n):\n    checkers = getVarCheckers()\n    domainName = var.domain._name\n    varName = var.name\n    val = value(var)\n    if domainName in checkers.keys():\n        checker = checkers[domainName]\n        varViolation, lower_bound, upper_bound = checker(\n            var, tol\n        )  # violation shall be positive when actual violation is greater than tolerance, otherwise zero.\n        if violation_only and not varViolation.has_violation:\n            return\n        varInfo = VarInfo(\n            varName=varName,\n            val=val,\n            domainName=domainName,\n            lower_bound=lower_bound,\n            upper_bound=upper_bound,\n            violation=varViolation,\n        )\n        return varInfo\n    else:\n        raise Exception(\"unknown domain name: %s\" % domainName)"
        },
        {
            "comment": "This code defines a function `getVarInfoListFromVarInfoDict` that takes a dictionary of variable information and returns a list of the values in the dictionary. It also includes a class `SkipSettingNoneDict`, which is a subclass of `dict` that doesn't allow setting none as a value, and a context manager `varInfoDictContext` to facilitate updating a variable information dictionary with violation information for variables if they are not None.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/violation_utils.py\":188-224",
            "content": "from typing import Dict\ndef getVarInfoListFromVarInfoDict(varInfoDict: Dict[str, VarInfo]):\n    varInfoList = list(varInfoDict.values())\n    return varInfoList\nfrom contextlib import contextmanager\nfrom copy import deepcopy\nclass SkipSettingNoneDict(dict):\n    def __setitem__(self, name, value):\n        if value is not None:\n            super().__setitem__(name, value)\n@contextmanager\ndef varInfoDictContext():\n    class VarInfoDictUpdator:\n        def __init__(self, violation_only: bool = False):\n            self._varInfoDict = SkipSettingNoneDict()\n            self.violation_only = violation_only\n        def update(self, var):\n            if var is not None:\n                varName = str(var)\n                if varName not in self._varInfoDict.keys():\n                    self._varInfoDict[\n                        varName\n                    ] = get_violation_of_infeasible_bounds_and_vartype_of_single_var(\n                        var, violation_only=self.violation_only\n                    )\n        @property\n        def varInfoDict(self):"
        },
        {
            "comment": "The code defines a class for updating variable information and provides functions to decompose linear and nonlinear constraints, retrieving variable information along the way. The `VarType` is used as a union of various types of variables. The `walk_expression` function iterates over the expression's arguments, yielding vars if they exist or recursively calling itself for other arguments. The `decompose_linear_constraint_from_terms_and_get_variable_info` function uses the `varInfoDictUpdator` to update variable info and returns the updated dictionary of variables. Similarly, the `decompose_nonlinear_constraint_and_get_variable_info_dict` function decomposes a nonlinear constraint and retrieves the variable information as a dictionary.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/violation_utils.py\":225-261",
            "content": "            return deepcopy(self._varInfoDict)\n        def __del__(self):\n            del self._varInfoDict\n    varInfoDictUpdator = VarInfoDictUpdator()\n    try:\n        yield varInfoDictUpdator\n    finally:\n        del varInfoDictUpdator\ndef decompose_linear_constraint_from_terms_and_get_variable_info(terms):\n    with varInfoDictContext() as varInfoDictUpdator:\n        for coef, var in terms:\n            varInfoDictUpdator.update(var)\n            return varInfoDictUpdator.varInfoDict\nfrom pyomo.core.base.var import *\nVarType = Union[Var, _VarData, _GeneralVarData, VarList, SimpleVar, ScalarVar]\nfrom typing import Iterable\ndef walk_expression(expr: Expression):\n    if (args := getattr(expr, \"args\", None)) is not None:\n        if isinstance(args, Iterable):\n            for arg in args:\n                if isinstance(arg, VarType):\n                    yield arg\n                else:\n                    yield from walk_expression(arg)\ndef decompose_nonlinear_constraint_and_get_variable_info_dict(constr: Constraint):"
        },
        {
            "comment": "This code snippet appears to be a part of a larger program for handling constraints in a microgrid optimization problem. It includes functions to decompose linear and nonlinear constraints, as well as piecewise constraints. The code uses the Pyomo library for constraint manipulation and potentially Pydantic for data management. However, the use of Pydantic is commented out, suggesting it may not be necessary in this context. Additionally, there seems to be a TODO note indicating future work on handling piecewise constraints.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/violation_utils.py\":262-296",
            "content": "    with varInfoDictContext() as varInfoDictUpdator:\n        for var in walk_expression(constr.body):\n            varInfoDictUpdator.update(var)\n        return varInfoDictUpdator.varInfoDict\ndef decompose_constraint_and_get_variable_info(constr: Constraint):\n    is_linear, terms = EXPR.decompose_term(constr.body)\n    # decompose non-linear constraints.\n    if is_linear:\n        varInfoDict = decompose_linear_constraint_from_terms_and_get_variable_info(\n            terms\n        )\n    else:\n        varInfoDict = decompose_nonlinear_constraint_and_get_variable_info_dict(constr)\n    varInfoList = getVarInfoListFromVarInfoDict(varInfoDict)\n    return is_linear, varInfoList\n# TODO: iterate over piecewise constraints.\nimport numpy as np\nfrom pyomo.core.base.piecewise import SimplePiecewise, IndexedPiecewise\nPiecewiseType = Union[Piecewise, SimplePiecewise, IndexedPiecewise]\nfrom typing import Tuple\n# do not use this. we need the data.\n# from pydantic import PrivateAttr\n# from functools import cached_property\n# not avaliable on pydantic v1"
        },
        {
            "comment": "Class PiecewiseBaseInfo represents base information for piecewise functions, including name, type, input and output variable info, and input and output points. Class PiecewiseInfo extends PiecewiseBaseInfo with computed fields: output_violation, input_domain_violation, and input_domain. The compute method takes a PiecewiseBaseInfo object and computes the input_domain_violation and expected_output using the input and output variable values, as well as the input points and domain.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/violation_utils.py\":297-328",
            "content": "# ref: https://docs.pydantic.dev/latest/usage/computed_fields\n# from pydantic import computed_field\nclass PiecewiseBaseInfo(BaseModel):\n    piecewiseName: str\n    piecewiseTypeName: Literal[\"Piecewise\", \"SimplePiecewise\", \"IndexedPiecewise\"]\n    inputVarInfo: VarInfo\n    outputVarInfo: VarInfo\n    input_points: List[float]\n    output_points: List[float]\nclass PiecewiseInfo(PiecewiseBaseInfo):\n    # computed.\n    output_violation: float\n    input_domain_violation: float\n    input_domain: Tuple[float, float]\n    @classmethod\n    def compute(cls, piecewiseBaseInfo: PiecewiseBaseInfo, tol=1e-6):\n        input_domain = (\n            min(piecewiseBaseInfo.input_points),\n            max(piecewiseBaseInfo.input_points),\n        )\n        input_point = piecewiseBaseInfo.inputVarInfo.val\n        output_point = piecewiseBaseInfo.outputVarInfo.val\n        input_domain_violation = get_bounds_violation(input_point, *input_domain, tol=0)\n        if input_domain_violation == 0:  # within bound.\n            expected_output = np.interp("
        },
        {
            "comment": "The code defines a class for storing violation information related to input domain and output, and a MagicList class with append, sort_by_attr, and filter_by_attr methods. The ViolationInfo class takes input_point, input_points, output_points, output_violation, input_domain_violation, and input_domain as parameters. It calculates the output violation if the else condition is met, otherwise sets it to 0. The has_violation property returns True if either output_violation or input_domain_violation is not equal to 0. MagicList class extends list with additional append, sort_by_attr, and filter_by_attr methods that handle None values, sort by a specified attribute, and filter based on a specified attribute with negation option respectively.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/violation_utils.py\":329-361",
            "content": "                input_point,\n                piecewiseBaseInfo.input_points,\n                piecewiseBaseInfo.output_points,\n            )\n            output_violation = abs(output_point - expected_output)\n            output_violation = moderate_violation(output_violation, tol)\n        else:\n            output_violation = 0\n        return cls(\n            **piecewiseBaseInfo.dict(),\n            output_violation=output_violation,\n            input_domain_violation=input_domain_violation,\n            input_domain=input_domain,\n        )\n    @property\n    def has_violation(self):\n        return any(\n            [v != 0 for v in [self.output_violation, self.input_domain_violation]]\n        )\nclass MagicList(list):\n    def append(self, value):\n        if value is not None:\n            super().append(value)\n    def sort_by_attr(self, attr: str, reverse=False):\n        super().sort(key=lambda e: getattr(e, attr), reverse=reverse)\n        return self\n    def filter_by_attr(self, attr: str, negate=False):\n        if negate:"
        },
        {
            "comment": "This code defines a `ModelScanner` class which scans a ConcreteModel object and its components, specifically focusing on constraints. It utilizes a `ModelInfo` class to store information about the model's constraints, variables, and piecewise functions. The `clear()` method removes all objects from the instance's dictionaries. The `tol` parameter sets a tolerance level for constraint evaluation, while `violation_only` determines if only constraints with violations are considered. The code includes methods to activate or deactivate constraints within the model.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/violation_utils.py\":362-396",
            "content": "            ret = filter(lambda e: not getattr(e, attr), self)\n        else:\n            ret = filter(lambda e: getattr(e, attr), self)\n        return MagicList(ret)\nclass ModelInfo:\n    def __init__(self):\n        self.constraints: List[ConstraintInfo] = MagicList()\n        self.variables: List[VarInfo] = MagicList()\n        self.piecewises: List[PiecewiseInfo] = MagicList()\n    def clear(self):\n        for obj in self.__dict__.values():\n            obj.clear()\nfrom rich.pretty import pretty_repr\nclass ModelScanner:\n    def __init__(self, model: ConcreteModel, tol=1e-6, violation_only=True):\n        self.tol = tol\n        self.model = model\n        self.modelInfo = ModelInfo()\n        self.violation_only = violation_only\n    def constraint(self):\n        self.modelInfo.constraints.clear()\n        # you can deactivate some constraints.\n        # model.constraint.activate()\n        # model.constraint.deactivate()\n        for constr in self.model.component_data_objects(\n            ctype=Constraint, active=True, descend_into=True"
        },
        {
            "comment": "This code calculates constraint violations and adds the information to a model. It checks each constraint's body value, extracts its name and expression, decomposes it into linear components and variable info, and stores the relevant details in ConstraintInfo objects for later use. The method returns all stored constraints.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/violation_utils.py\":397-421",
            "content": "        ):\n            body_value = value(constr.body, exception=False)\n            constraint_bounds = get_var_or_constraint_bounds(constr)\n            constraintName = constr.name\n            if body_value is not None:\n                violation = get_bounds_violation(\n                    body_value, *constraint_bounds, self.tol\n                )\n                if self.violation_only and violation == 0:\n                    continue\n                representation = str(constr.expr)\n                is_linear, varInfoList = decompose_constraint_and_get_variable_info(\n                    constr\n                )\n                constraintInfo = ConstraintInfo(\n                    constraintName=constraintName,\n                    is_linear=is_linear,\n                    variables=varInfoList,\n                    violation=violation,\n                    representation=representation,\n                )\n                self.modelInfo.constraints.append(constraintInfo)\n        return self.modelInfo.constraints\n    def variable(self):"
        },
        {
            "comment": "The function clears the model's variable list, iterates through all variables in the model, and appends information about each variable's violation of bounds and variable type to the modelInfo list. The piecewise function clears the model's piecewise list, iterates through active, descend-into PiecewiseType objects, and adds their information (name, type, input/output parameter details) to the modelInfo list.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/violation_utils.py\":422-445",
            "content": "        self.modelInfo.variables.clear()\n        for var in self.model.component_data_objects(ctype=Var, descend_into=True):\n            self.modelInfo.variables.append(\n                get_violation_of_infeasible_bounds_and_vartype_of_single_var(\n                    var, self.tol, violation_only=self.violation_only\n                )\n            )\n        return self.modelInfo.variables\n    def piecewise(self):\n        self.modelInfo.piecewises.clear()\n        for pw in self.model.block_data_objects(active=True, descend_into=True):\n            if isinstance(pw, PiecewiseType):\n                piecewiseName = pw.name\n                piecewiseTypeName = type(pw).__name__\n                io_params = {}\n                for key, value in {\"input\": \"domain\", \"output\": \"range\"}.items():\n                    var = getattr(pw, f\"_{value}_var\")\n                    io_params[\n                        f\"{key}VarInfo\"\n                    ] = get_violation_of_infeasible_bounds_and_vartype_of_single_var(\n                        var, self.tol, violation_only=False"
        },
        {
            "comment": "This code is a part of a microgrid model. It defines functions for constraint, variable, piecewise, and report operations. The modelScannerContext function acts as a context manager. The piecewise function computes and appends piecewise information to the model if there are no violations, then returns the list of piecewises. The all function performs all model operations and returns the modelInfo object. Finally, the report function generates a formatted report from the modelInfo object for presentation.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/violation_utils.py\":446-480",
            "content": "                    )\n                    io_params[f\"{key}_points\"] = getattr(pw, f\"_{value}_pts\")\n                piecewiseBaseInfo = PiecewiseBaseInfo(\n                    piecewiseName=piecewiseName,\n                    piecewiseTypeName=piecewiseTypeName,\n                    **io_params,\n                )\n                piecewiseInfo = PiecewiseInfo.compute(piecewiseBaseInfo, tol=self.tol)\n                if self.violation_only and not piecewiseInfo.has_violation:\n                    continue\n                self.modelInfo.piecewises.append(piecewiseInfo)\n        return self.modelInfo.piecewises\n    def all(self):\n        self.constraint()\n        self.variable()\n        self.piecewise()\n        return self.modelInfo\n    def report(self):\n        self.all()\n        report_lines = []\n        for key, obj in self.modelInfo.__dict__:\n            report.append(key.center(70, \"=\"))\n            report.append(pretty_repr(obj))\n        report = \"\\n\".join(report_lines)\n        return report\n@contextmanager\ndef modelScannerContext("
        },
        {
            "comment": "The code initializes a Pyomo model with five variables and four constraints, representing an advanced logical expression. The ConcreteModel is scanned using ModelScanner with given tolerance and violation settings. The model variables are set to specific values and constraints are defined to represent the logical expressions.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/violation_utils.py\":481-512",
            "content": "    model: ConcreteModel, tol: float = 1e-6, violation_only: bool = True\n):\n    modelScanner = ModelScanner(model, tol=tol, violation_only=violation_only)\n    try:\n        yield modelScanner\n    finally:\n        del modelScanner\nif __name__ == \"__main__\":\n    # advanced logical expression linearization using pyomo.GDP\n    # ref: https://pyomo.readthedocs.io/en/latest/modeling_extensions/gdp/modeling.html\n    model = ConcreteModel()\n    model.a = Var(within=Binary)\n    model.b = Var(within=NonNegativeReals)\n    model.c = Var(within=NonNegativeIntegers)\n    model.d = Var(bounds=(-10, 10))\n    model.e = Var()\n    model.a.set_value(1.5)\n    model.b.set_value(-0.5)\n    model.c.set_value(100.5)\n    model.d.set_value(-11)\n    model.e.set_value(-50.5)\n    model.con1 = Constraint(expr=model.d >= model.c)\n    model.con2 = Constraint(expr=model.b >= model.c)\n    model.con3 = Constraint(expr=model.a + model.b <= -model.c)\n    model.con4 = Constraint(expr=model.b * model.b >= model.c)\n    # piecewise is not constraint, though."
        },
        {
            "comment": "The code creates a piecewise function using the Piecewise class, specifying constraints and representation type. It then sets values for certain elements of the piecewise function object and initializes a ModelScanner to extract information from the model. It logs constraint, variable, and piecewise information for analysis.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/violation_utils.py\":514-543",
            "content": "    model.pw = Piecewise(\n        model.c,  # y_var\n        model.e,  # x_var\n        pw_pts=[-100, 0, 100],\n        pw_repn=\"MC\",\n        # pw_repn=\"SOS2\",\n        f_rule=[100, 0, -100],\n        pw_constr_type=\"EQ\",\n        unbounded_domain_var=True,\n        warn_domain_coverage=False,\n    )\n    model.pw.MC_poly_x[1] = 1\n    model.pw.MC_poly_x[2] = 1\n    model.pw.MC_bin_y[1] = 1\n    model.pw.MC_bin_y[2] = 1\n    modelScanner = ModelScanner(model)\n    for constrInfo in modelScanner.constraint():\n        logger_print(constrInfo)\n    logger_print(\"=\" * 70)\n    for varInfo in modelScanner.variable():\n        logger_print(varInfo)\n    logger_print(\"=\" * 70)\n    for piecewiseInfo in modelScanner.piecewise():\n        logger_print(piecewiseInfo)"
        }
    ]
}