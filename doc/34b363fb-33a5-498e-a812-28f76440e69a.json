{
    "summary": "The code allows stepwise manipulation of source code for testing, using Pydantic and namedtuple. It provides a CLI tool with Python 3.9 support, defines classes for exchange data and a validator function, and outputs results in JSON format.",
    "details": [
        {
            "comment": "Code snippet for stepwise source code manipulation in testing, importing Pydantic and namedtuple. Provides an example usage with '-t'. Written to be run as a command line tool using conda, preferably Python 3.9, for compatibility purposes.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/test/runtime_override_stepwise.py\":0-31",
            "content": "# shall not use shebang.\n#!/usr/bin/env conda run -n base --live-stream --no-capture-output python --\n# ref: https://www.baeldung.com/linux/shebang-types\n# import os\n# filename = os.path.basename(__file__)\n# __doc__ = \"\"\"Stepwise source code manipulation for testing.\n# Usage:\n#     -t\n# \"\"\".format(filename=filename)\n# doc = __doc__\nfrom pydantic import BaseModel\nfrom collections import namedtuple\nFuncSourceWithName = namedtuple(\"FuncSourceWithName\", [\"changed_source\", \"funcname\"])\n# it is a small function which can be run as commandline tool.\n# just invoke conda while testing. do not try to run the whole environment in python3.9\n# for compatibility, better use python3.9\n# though using \"redbaron\" or some other code refactor tool also works.\n# refs:\n# https://github.com/python-rope/rope\n# https://redbaron.readthedocs.io/en/latest/\n# https://pybowler.io/\n# https://libcst.readthedocs.io/en/stable/why_libcst.html\n# try:\n#     from pydantic import field_validator as validator\n# except:\n#     from pydantic import validator"
        },
        {
            "comment": "This code defines an iterate_till_keyword function that stops iteration when a specified keyword is found, and a class ExchangePaths with two static methods to get the input and output file paths.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/test/runtime_override_stepwise.py\":32-75",
            "content": "from pydantic import validator\nimport os\ndef iterate_till_keyword(iterator, keyword: str):\n    \"\"\"\n    Iterate through the given iterator until the specified keyword is found.\n    Parameters:\n        - iterator: An iterator object.\n        - keyword: A string representing the keyword to stop the iteration.\n    Returns:\n        None\n    \"\"\"\n    while True:\n        it = next(iterator)\n        if it == keyword:\n            print(f\"Stopped iteration at keyword: '{keyword}'\")\n            break\nclass ExchangePaths:\n    input = \"input.json\"\n    output = \"output.json\"\n    @staticmethod\n    def getInputPath(basedir: str):\n        \"\"\"\n        A static method that takes a base directory as input and returns the path to the input file.\n        Parameters:\n            basedir (str): The base directory.\n        Returns:\n            str: The path to the input file.\n        \"\"\"\n        return os.path.join(basedir, ExchangePaths.input)\n    @staticmethod\n    def getOutputPath(basedir: str):\n        \"\"\"\n        Get the output path by joining the base directory with the output path."
        },
        {
            "comment": "This code defines a `SourceCodeExchange` class which represents source code exchange data. The class has fields for source_code, processed status, and optional funcname and keywords. It also includes a validator function for the \"keywords\" field that checks if the processed flag is set to True or False. If processed is True, the keywords field should be empty; otherwise, it can contain non-empty values.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/test/runtime_override_stepwise.py\":77-115",
            "content": "        Args:\n            basedir (str): The base directory.\n        Returns:\n            str: The output path.\n        \"\"\"\n        return os.path.join(basedir, ExchangePaths.output)\nclass SourceCodeExchange(BaseModel):\n    source_code: str\n    processed: bool\n    funcname: str = \"\"\n    keywords: set = set()  # validation values follows the order.\n    @validator(\"keywords\")\n    def validate_keywords(cls, v, values):\n        \"\"\"\n        Validate the \"keywords\" field.\n        Args:\n            cls: The class itself.\n            v: The value of the \"keywords\" field.\n            values: The values of all the fields in the model.\n        Returns:\n            The validated value of the \"keywords\" field.\n        \"\"\"\n        # print(values)\n        # breakpoint()\n        if processed := values.get(\"processed\"):  # ERROR\n            assert (\n                len(v) == 0\n            ), \"Processed: {}\\nInvalid keywords: {} (Shall be empty)\".format(\n                processed, v\n            )\n        else:\n            assert (\n                len(v) != 0"
        },
        {
            "comment": "The code is validating the 'funcname' parameter, ensuring it is not empty if the 'processed' value exists in the dictionary of values. If 'processed' does not exist, the funcname should be empty. The code also checks the Python version to ensure compatibility with Python 3.9 and higher.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/test/runtime_override_stepwise.py\":116-153",
            "content": "            ), \"Processed: {}\\nInvalid keywords: {} (Shall not be empty)\".format(\n                processed, v\n            )\n        return v\n    @validator(\"funcname\")\n    def validate_funcname(cls, v, values):\n        \"\"\"\n        Validate the funcname parameter.\n        Parameters:\n            cls (class): The class object.\n            v (Any): The value to be validated.\n            values (Dict[str, Any]): The dictionary of values.\n        Returns:\n            Any: The validated value.\n        \"\"\"\n        if processed := values.get(\"processed\"):\n            assert (\n                v != \"\"\n            ), \"Processed: {}\\nInvalid funcname: {} (Shall not be empty)\".format(\n                processed, repr(v)\n            )\n        else:\n            assert (\n                v == \"\"\n            ), \"Processed: {}\\nInvalid funcname: {} (Shall be empty)\".format(\n                processed, repr(v)\n            )\n        return v\nimport sys\nif sys.version_info >= (3, 9):\n    def add_stepwise_lines_to_func_source(func_source_cleaned, keywords: set):"
        },
        {
            "comment": "This code imports the ast_comments module and defines a function to add stepwise lines to a given function's source code. It takes cleaned source code and a set of keywords as input, then uses ast.unparse from ast_comments to return an object containing the modified source code and function name. The code also includes debugging prints for testing purposes.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/test/runtime_override_stepwise.py\":154-180",
            "content": "        \"\"\"\n        Adds stepwise lines to the given function source code.\n        Parameters:\n            func_source_cleaned (str): The cleaned source code of the function.\n            keywords (set): A set of keywords to search for in the function source code.\n        Returns:\n            FuncSourceWithName: An object containing the changed source code and the function name.\n        \"\"\"\n        import ast_comments as ast\n        # import astunparse\n        # no comment support!\n        # unparse_func = astor.to_source\n        # unparse_func = astunparse.unparse\n        unparse_func = ast.unparse\n        # func_ast = ast.parse(func_source_cleaned, type_comments=True)\n        func_ast = ast.parse(func_source_cleaned)\n        print(func_ast)  # unexpected indent, if not cleaned.\n        print(func_ast.body)  # [<_ast.FunctionDef object at 0x1048a1a00>]\n        # for cn in ast.iter_child_nodes(func_ast):\n        #     print(cn)\n        funcdef = func_ast.body[0]\n        funcname = funcdef.name\n        print(funcdef.body)  # no comment?"
        },
        {
            "comment": "This code is modifying a function's body by inserting a yield expression containing the keyword 'myflag'. It removes any additional occurrences of that keyword and preserves comments in the process. The function's body is reconstructed with the new modifications before being unparsed into source form.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/test/runtime_override_stepwise.py\":181-203",
            "content": "        # breakpoint()\n        # [<_ast.Expr object at 0x105359550>, <_ast.Expr object at 0x105368100>, <_ast.Assert object at 0x105395790>, <_ast.Expr object at 0x105395a60>]\n        print(dir(funcdef))\n        print(funcdef.decorator_list)  # [<_ast.Name object at 0x103081b50>]\n        # changed_source = ast.dump(funcdef)\n        new_body = []\n        for item in funcdef.body:\n            new_body.append(item)\n            item_code = unparse_func(item)\n            _k = None\n            for keyword in keywords:\n                if keyword in item_code:\n                    stepwise_expr = ast.parse(\"yield '{}'\".format(\"myflag\")).body[0]\n                    new_body.append(stepwise_expr)\n                    _k = keyword\n                    break\n            if _k:  # only use that keyword one time.\n                # can't you preserve comments in ast?\n                # pip3 install ast-comments\n                keywords.remove(_k)\n        funcdef.body = new_body\n        changed_source = unparse_func(funcdef)  # cannot convert comment back to source."
        },
        {
            "comment": "This code defines a function that adds stepwise lines to a given function's source code. It takes the cleaned source code of the function and a set of keywords as arguments. If the source has been changed, it prints messages and returns an object containing the modified source and function name. Otherwise, it calls another function to implement the addition of stepwise lines using a temporary directory and file paths.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/test/runtime_override_stepwise.py\":204-231",
            "content": "        print(\"CHANGED SOURCE\".center(70, \"=\"))\n        print(changed_source)\n        return FuncSourceWithName(changed_source=changed_source, funcname=funcname)\nelse:\n    def add_stepwise_lines_to_func_source(func_source_cleaned, keywords: set):\n        \"\"\"\n        Adds stepwise lines to the function source code.\n        Args:\n            func_source_cleaned (str): The cleaned source code of the function.\n            keywords (set): A set of keywords.\n        Returns:\n            FuncSourceWithName: An object containing the changed source code and function name.\n        \"\"\"\n        # implement it by calling conda.\n        # use temporary directory.\n        import tempfile\n        with tempfile.TemporaryDirectory() as tmpdir:  # str!\n            # tmpdir_name = tmpdir.name\n            data = SourceCodeExchange(\n                source_code=func_source_cleaned, keywords=keywords, processed=False\n            )\n            input_path = ExchangePaths.getInputPath(tmpdir)\n            output_path = ExchangePaths.getOutputPath(tmpdir)"
        },
        {
            "comment": "This code snippet reads a function definition from a file, processes it, and returns a modified version of the function where \"yield\" is inserted after every line containing specific keywords. It first writes the original function to a temporary file, then executes a command in the terminal to run the Python script with the new function written to the file, and finally reads the output file to extract the processed function data. The code also handles an overwrite operation for the given function, inserting \"yield\" after specific keywords.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/test/runtime_override_stepwise.py\":232-254",
            "content": "            with open(input_path, \"w+\") as f:\n                content = data.json()\n                f.write(content)\n            commandline = \"conda run -n base --no-capture-output --live-stream python {filename} -i '{input_path}'\".format(\n                filename=os.path.basename(__file__), input_path=input_path\n            )\n            print(\"EXCUTING: {}\".format(commandline))\n            os.system(commandline)\n            processed_data = SourceCodeExchange.parse_file(output_path)\n            return FuncSourceWithName(\n                changed_source=processed_data.source_code,\n                funcname=processed_data.funcname,\n            )\ndef overwrite_func(func, keywords: set):  # nameclash warning!\n    # def overwrite_func(func, c_globals, keywords: set):\n    \"\"\"\n    Overwrites a given function with a modified version that inserts \"yield\" after every line containing given keywords.\n    Args:\n        func: The function to be overwritten.\n        keywords (set): A set of keywords to be inserted after each line in the modified function."
        },
        {
            "comment": "This code defines a function `overwrite_func` that takes in a function, modifies its source code by inserting yield statements at the beginning of each line and returns the modified function. It uses regular expressions to find the definition of the original function and strip unnecessary blanks before replacing them with new lines containing yield. The cleaned source code is then printed for verification.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/test/runtime_override_stepwise.py\":256-289",
            "content": "    Returns:\n        The modified function.\n    \"\"\"\n    # def overwrite_func(func, c_locals, c_globals, keywords: set):\n    import inspect\n    # import ast\n    import re\n    # get definition and return a new func.\n    # test: add \"yield\" after every line.\n    # func_ast = astor.code_to_ast(func)\n    # print(func_ast)\n    # deprecated?\n    c_globals = func.__globals__\n    # what is the name of the function?\n    func_source = inspect.getsource(func)\n    # return new_func\n    find_def = r\"^( +)(?:def|async)\"  # not async\n    FDRegex = re.compile(find_def, flags=re.MULTILINE)\n    strip_blanks = FDRegex.findall(func_source)[0]\n    blank_count = len(strip_blanks)\n    # print(\"BLANK COUNT:\", blank_count) # BLANK COUNT: 4\n    indent_replace = r\"^ \" + (\"{%d}\" % blank_count)\n    # print(repr(indent_replace))\n    IRRegex = re.compile(indent_replace, flags=re.MULTILINE)\n    func_source_cleaned = IRRegex.sub(\"\", func_source)\n    print(\"SOURCE CODE CLEANED\".center(70, \"=\"))\n    print(func_source_cleaned)\n    print()\n    changed_source, funcname = add_stepwise_lines_to_func_source("
        },
        {
            "comment": "Function `add_locals_and_globals_inspectors_to_instance` adds local and global inspectors to the given instance. These inspectors allow access to the function's local and global variables, respectively. The code also includes argument parsing using `argparse` for executing tests or providing an input file.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/test/runtime_override_stepwise.py\":290-326",
            "content": "        func_source_cleaned, keywords\n    )\n    # exec(changed_source, globals=None, locals=None, /)\n    # exec(changed_source, c_globals,c_locals, /)\n    exec(changed_source, c_globals)\n    print(locals().keys())\n    new_func = eval(funcname)  # not in locals.\n    # new_func = locals()[funcname]\n    return new_func\nfrom types import MethodType\ndef add_locals_and_globals_inspectors_to_instance(c):\n    \"\"\"\n    Adds local and global inspectors to the given instance.\n    :param c: The instance to add the inspectors to.\n    \"\"\"\n    c.locals = MethodType(lambda self: locals(), c)\n    c.globals = MethodType(lambda self: globals(), c)\nif __name__ == \"__main__\":\n    # import docopt\n    # print(__doc__)\n    # arguments = docopt.docopt(__doc__, help=False, version='Stepwise Test Util 1.0')\n    import argparse\n    argparser = argparse.ArgumentParser()\n    argparser.add_argument(\"-t\", \"--test\", action=\"store_true\", default=False)\n    argparser.add_argument(\"-i\", \"--input\", type=str, default=None)\n    # print(arguments)\n    # breakpoint()"
        },
        {
            "comment": "This code defines a decorator function and a class with methods. The decorator takes a function as input and returns the same function. The class has a static method that returns \"a\" and an instance method that prints the keys of local and global scopes.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/test/runtime_override_stepwise.py\":327-365",
            "content": "    arguments = argparser.parse_args()\n    if arguments.test:\n        def dec(f):\n            \"\"\"\n            Decorator function that takes a function as input and returns the same function.\n            \"\"\"\n            \"\"\"\n            Decorator function that takes a function as input and returns the same function.\n            \"\"\"\n            return f\n        class MyClass:\n            val = 1\n            @staticmethod\n            def newfunc():\n                \"\"\"\n                A static method that returns the string \"a\".\n                \"\"\"\n                return \"a\"\n            def inspect_class(self):\n                \"\"\"\n                A method that inspects the current class and prints the keys of the local and global scope.\n                Parameters:\n                    self: The instance of the class.\n                Returns:\n                    None\n                \"\"\"\n                print(locals().keys())\n                print(globals().keys())\n            @dec\n            def myfunc(self):\n                \"\"\""
        },
        {
            "comment": "This code defines a decorator function that replaces the original 'myfunc' method of class MyClass with a new version. The new version prints \"abc\", \"def\", and \"in range\" 20 times, then raises an AssertionError with the message \"you cannot pass\". Finally, it returns the string \"abc\". The code also attempts to print the keys in the global dictionary of MyClass.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/test/runtime_override_stepwise.py\":366-395",
            "content": "                Decorated function that prints \"abc\", \"def\", and \"in range\" 20 times.\n                Raises an AssertionError with the message \"you cannot pass\".\n                Returns the string \"abc\".\n                \"\"\"\n                print(\"abc\")\n                print(\"def\")\n                # mycomment\n                # mycomment_has_keyword\n                for _ in range(20):\n                    print(\"in range\")\n                assert False, \"you cannot pass\"\n                print(\"hjk\")\n                # every comment shall be ignored.\n                # yield \"myflag\"  # you may yield flag.\n                return \"abc\"\n        c = MyClass()\n        # add_locals_and_globals_inspectors_to_instance(c)\n        # c_locals = c.locals()\n        # c_globals = c.globals()\n        # c_globals = c.myfunc.__globals__\n        # # c_globals = MyClass.__globals__\n        # # c_globals = c.__globals__\n        # # print(c_locals.keys())\n        # print(c_globals.keys())\n        keywords = {\"def\", \"has_keyword\"}\n        new_func = overwrite_func(c.myfunc, keywords)"
        },
        {
            "comment": "This code defines a function that overwrites an existing function with new code and then executes the modified function. It also demonstrates generator functionality by creating an iterator that yields 2, returns 1, and prints the type of execution result. Additionally, it can parse input files and add stepwise lines to functions.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/test/runtime_override_stepwise.py\":396-425",
            "content": "        # new_func = overwrite_func(c.myfunc, c_globals, keywords)\n        # new_func = overwrite_func(c.myfunc, c_locals, c_globals, keywords)\n        c.myfunc = MethodType(new_func, c)\n        exec_result = c.myfunc()\n        print(type(exec_result))\n        # c.inspect_class()\n        # for flag in exec_result:\n        #     print(\"RECEVICED FLAG:\", flag)\n        # AssertionError: you cannot pass\n        def myiterator():\n            \"\"\"\n            A generator function that yields the value 2 and then returns 1.\n            \"\"\"\n            yield 2\n            return 1  # stopped iteration.\n            # if you want to \"return\", just don't insert any \"yield\" statements.\n        a = myiterator()  # generator.\n        print(a)\n        print()\n        for it in a:\n            print(it)\n    elif input_path := arguments.input:\n        print(\"INPUT FILE PATH:\", input_path)\n        data = SourceCodeExchange.parse_file(input_path)\n        output = add_stepwise_lines_to_func_source(\n            func_source_cleaned=data.source_code, keywords=data.keywords"
        },
        {
            "comment": "The code reads input from a file and checks if it needs to be overridden. If so, it writes the output data to a specified path in JSON format. If no override is needed, it prints help information.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/test/runtime_override_stepwise.py\":426-440",
            "content": "        )\n        with open(\n            output_path := ExchangePaths.getOutputPath(os.path.dirname(input_path)),\n            \"w+\",\n        ) as f:\n            print(\"WRITE TO:\", output_path)\n            output_data = SourceCodeExchange(\n                source_code=output.changed_source,\n                processed=True,\n                funcname=output.funcname,\n            )\n            content = output_data.json()\n            f.write(content)\n    else:\n        argparser.print_help()"
        }
    ]
}