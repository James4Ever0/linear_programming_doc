{
    "summary": "The code includes debugging, logging, and error handling, with a context manager for micro challenges. It offers utility functions for variable constraints, word counters, and keyword addition. The code calculates system variables, logs objective values, and provides optimization solver options for solving models while analyzing results without affecting the original model.",
    "details": [
        {
            "comment": "Code from \"jubilant-adventure/microgrid_base/debug_utils.py\":0-33 contains functions related to debugging, logging, and error handling using Python libraries like log_utils, flashtext, pydantic, etc. It also includes functionality for solving optimization problems with Pyomo and defining normal SolverStatus and TerminationCondition.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/debug_utils.py\":0-33",
            "content": "# TODO: assign debug/error id and separate logger/folder for error logging.\n# TODO: use miplib (problem dataset) to test our debugging tools\n# ref: https://miplib.zib.de/\n# sensitivity analysis cannot be done before solution\n# ref: https://www.ibm.com/docs/en/icos/12.9.0?topic=tutorial-performing-sensitivity-analysis\nfrom log_utils import logger_print\n# input: model, objective, etc.\n# output: multiple diagnostics\n# from pyomo.environ import *\nfrom pyomo_environ import *\n# from ies_optim import ModelWrapper\nfrom contextlib import contextmanager\nimport flashtext\nimport os\nfrom beartype import beartype\n# import subprocess\n# from typing import TypedDict\nfrom pydantic import BaseModel\nimport uuid\n# from typing import Literal, TypedDict\nnormalSSs = [SolverStatus.ok, SolverStatus.warning]\n# should you include more termination conditions, or should you just check for values, by creating dummy uninitialized variable or dummy independent  constraints with variables init at violation regions\nnormalTCs = [\n    TerminationCondition.globallyOptimal,"
        },
        {
            "comment": "This code defines a context manager that checks if a given model is solved by using micro challenges. It includes different test modes to check if values exist, exist and are inbound, or satisfy constraints. It also provides utility functions for assigning attributes with random names to objects.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/debug_utils.py\":34-75",
            "content": "    TerminationCondition.locallyOptimal,\n    TerminationCondition.feasible,\n    TerminationCondition.optimal,\n]\nIOUTerminationConditions = [\n    TerminationCondition.infeasible,\n    TerminationCondition.infeasibleOrUnbounded,\n]\nfrom enum import auto\nfrom strenum import StrEnum\nclass SolvedTestMode(StrEnum):\n    values_exist = auto()  # does not work well with cplex.\n    values_exist_and_inbound = auto()\n    values_exist_and_satisfy_constraint = auto()  # default.\ndef get_unassigned_attrname(obj):\n    while True:\n        attrname = str(uuid.uuid4()).replace(\"-\", \"_\")\n        challange = uuid.uuid4()\n        attr = getattr(obj, attrname, challange)\n        if attr == challange:\n            return attrname\ndef assign_attr_to_obj_with_random_name(obj, value):\n    attrName = get_unassigned_attrname(obj)\n    setattr(obj, attrName, value)\n    return attrName\n@contextmanager\ndef modelSolvedTestContext(\n    model: ConcreteModel,\n    testMode: SolvedTestMode = SolvedTestMode.values_exist_and_satisfy_constraint,\n):\n    \"\"\"\n    Context manager that checks that the model is solved, by means of micro challenges."
        },
        {
            "comment": "This code sets bounds for a variable and creates constraints based on the test mode. It defines a check_solved function to verify if the solution falls within the specified range.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/debug_utils.py\":76-107",
            "content": "    \"\"\"\n    lb = 20\n    ub = 40\n    attrNames = []\n    attrNames.append(assign_attr_to_obj_with_random_name(model, var := Var()))\n    if testMode == SolvedTestMode.values_exist_and_inbound:\n        var.setlb(lb)\n        var.setub(ub)\n    elif testMode == SolvedTestMode.values_exist_and_satisfy_constraint:\n        attrNames.append(\n            assign_attr_to_obj_with_random_name(\n                model, con1 := Constraint(expr=var >= lb)\n            )\n        )\n        attrNames.append(\n            assign_attr_to_obj_with_random_name(\n                model, con2 := Constraint(expr=var <= ub)\n            )\n        )\n    elif testMode == SolvedTestMode.values_exist:\n        ...\n    else:\n        raise Exception(\"Unsupported test mode:\", testMode)\n    def check_solved():\n        var_value = value(var, exception=False)\n        solved = False\n        if var_value is not None:\n            if testMode != SolvedTestMode.values_exist:\n                solved = var_value >= lb and var_value <= ub\n            else:\n                solved = True"
        },
        {
            "comment": "This code defines a SolverReturnStatus class and a CheckSolverReturnValResult class, as well as a function to build a word counter from a model wrapper. The word_counter function extracts keywords from text using a keyword processor and returns a dictionary of keyword counts. The checkIfSolverHasSolvedModel function takes solver_result as input and checks if the solver has solved the model. The termination_condition variable is defined using TC from solver_result. The code also includes deprecated functions for building word counters and adding keywords to a keyword processor.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/debug_utils.py\":108-147",
            "content": "        return solved\n    try:\n        yield check_solved\n    finally:\n        for name in attrNames:\n            delattr(model, name)\nclass SolverReturnStatus(BaseModel):\n    terminationCondition: TerminationCondition\n    solverStatus: SolverStatus\nclass CheckSolverReturnValResult(BaseModel):\n    success: bool\n    status: SolverReturnStatus\n# deprecated.\n# def buildWordCounterFromModelWrapper(mw):\n#     keyword_processor = flashtext.KeywordProcessor()\n#     for varName in mw.varNameToSubmodelName.keys():\n#         keyword_processor.add_keyword(varName)\n#     def word_counter(text: str) -> Dict[str, int]:\n#         keywords_found = keyword_processor.extract_keywords(text)\n#         keyword_counts = {}\n#         for keyword in keywords_found:\n#             keyword_counts[keyword] = keyword_counts.get(keyword, 0) + 1\n#         return keyword_counts\n#     return word_counter\n# deprecated!\ndef checkIfSolverHasSolvedModel(solver_result) -> CheckSolverReturnValResult:\n    TC = solver_result.solver.termination_condition"
        },
        {
            "comment": "This code defines a function named 'conflict_refiner' that takes parameters such as model_path, output, config, and timeout. It uses argparse_utils module's conflictRefinerManager to call the function. The function is designed to solve conflicts by calling 'conflict_utils.py', using specified model_path and config, with a timeout of 5 seconds.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/debug_utils.py\":148-181",
            "content": "    SS = solver_result.solver.status\n    solved = TC in normalTCs and SS in normalSSs\n    return CheckSolverReturnValResult(\n        success=solved,\n        status=SolverReturnStatus(terminationCondition=TC, solverStatus=SS),\n    )\n# TODO: gluecode automation (maybe metaclass?)\n# ref: https://github.com/gwenzek/func_argparse\n# ref: https://github.com/Acellera/func2argparse (py3.9+)\n# ref: https://github.com/pseeth/argbind\n# @beartype\n# def conflict_refiner(\n#     model_path: str,\n#     output: str,\n#     config: Literal[\"cplex\", \"docplex\"],\n#     timeout: float = 5,\n# ):\nfrom shared_datamodels import ConflictRefinerParams\nfrom argparse_utils import conflictRefinerManager\n@conflictRefinerManager.call\ndef conflict_refiner(params: ConflictRefinerParams):\n    # def conflict_refiner(param):\n    # cmd = \"conda run -n docplex --live-stream --no-capture-output python conflict_utils.py\"\n    # arguments = [\n    #     \"--model_path\",\n    #     model_path,\n    #     \"--config\",\n    #     config,\n    #     \"--timeout\",\n    #     timeout,"
        },
        {
            "comment": "The code reads a symbol map and converts it to a translation table. It first combines the symbol map's bySymbol and aliases into a full map, then iterates through each numeric name in the full map. For each numeric name, it retrieves the corresponding object using the weakref and checks if its name is a string. If so, this name is added to the translation table. Additionally, the code includes error handling for output files not found, as well as checking the process return code for potential errors.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/debug_utils.py\":182-211",
            "content": "    #     \"--output\",\n    #     output,\n    # ]\n    # proc = subprocess.run(cmd.split() + arguments)\n    # logger_print(\"process output:\", proc.stdout.decode())\n    # logger_print(\"process stderr:\", proc.stderr.decode())\n    # # logger_print(\"process return code\", proc.returncode)\n    # if proc.returncode != 0:\n    #     logger_print(\"invalid process return code:\", proc.returncode)\n    output = params.output\n    if os.path.exists(output):\n        with open(output, \"r\") as f:\n            output_content = f.read()\n        return output_content\n    else:\n        logger_print(\"output file not found:\", output)\nfrom typing import Dict\ndef convertSymbolMapToTranslationTable(symbol_map: SymbolMap):\n    translationTable = {}\n    # get alias from symbol map.\n    full_map = {**symbol_map.bySymbol, **symbol_map.aliases}\n    for numeric_name, object_weakref in full_map.items():\n        obj = object_weakref()\n        if obj is not None:\n            object_name = getattr(obj, \"name\", None)\n            if isinstance(object_name, str):"
        },
        {
            "comment": "The code defines a class ExportedModel that takes a model and filepath as parameters. It checks the format of the filepath, writes the model to the file, and retrieves the symbol map. Then, it converts the symbol map to translation tables using convertSymbolMapToTranslationTable function. The reverse_translation_table is created by swapping keys and values in the translation_table.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/debug_utils.py\":212-239",
            "content": "                translationTable[numeric_name] = object_name\n            else:\n                raise Exception(f\"Cannot retrieve name from symbol '{obj}'\")\n        else:\n            translationTable[numeric_name] = numeric_name\n            # raise Exception(\n            #     f\"Numeric symbol name '{numeric_name}' does not have reference to model.\"\n            # )\n    return translationTable\nclass ExportedModel:\n    def __init__(self, model: ConcreteModel, filepath: str):\n        self._model = model\n        self._filepath = filepath\n        fmt = filepath.split(\".\")[-1]\n        if fmt not in [\"mps\", \"lp\"]:\n            raise Exception(f\"Cannot export unknown format: {fmt}\")\n        _, smap_id = model.write(filepath, format=fmt)\n        self.smap: SymbolMap = model.solutions.symbol_map[smap_id]\n        self.translation_table = convertSymbolMapToTranslationTable(self.smap)\n        \"\"\"\n        Translate exported names back to the original name.\n        \"\"\"\n        self.reverse_translation_table = {\n            v: k for k, v in self.translation_table.items()"
        },
        {
            "comment": "This code defines functions for translating text using a translation table. The `getKeywordProcessorFromTranslationTable` function creates a keyword processor and adds replaced items to it based on the given translation table. The `translateTextUsingTranslationTable` function uses this keyword processor to replace keywords in a given text. The `translateFileUsingTranslationTable` function reads a file, translates its content using the previous function, and returns the translated content.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/debug_utils.py\":240-270",
            "content": "        }\n        \"\"\"\n        Translate original names to exported names.\n        \"\"\"\n@contextmanager\ndef getKeywordProcessorFromTranslationTable(translationTable: Dict[str, str]):\n    keyword_processor = flashtext.KeywordProcessor(case_sensitive=True)\n    try:\n        for replaced_item, wanted_item in translationTable.items():\n            keyword_processor.add_keyword(replaced_item, wanted_item)\n        yield keyword_processor\n    finally:\n        del keyword_processor\ndef translateTextUsingTranslationTable(\n    text: str, translationTable: Dict[str, str]\n) -> str:\n    with getKeywordProcessorFromTranslationTable(translationTable) as keyword_processor:\n        translatedText = keyword_processor.replace_keywords(text)\n        return translatedText\n@beartype\ndef translateFileUsingTranslationTable(filepath: str, translationTable: Dict[str, str]):\n    if os.path.exists(filepath):\n        with open(filepath, \"r\") as f:  # unsure what the encoding is!\n            content_before_translation = f.read()\n            content_after_translation = translateTextUsingTranslationTable("
        },
        {
            "comment": "This code defines a function `translateFileUsingSymbolMap` that takes a file path and a symbol map as arguments, converts the symbol map to a translation table, and then calls another function `translateFileUsingTranslationTable` with these parameters. The `solve_with_translated_log_and_statistics` function solves a model using a specific solver, logging the result to a file with the given label and directory. It also asserts that the label does not contain spaces, replaces underscores with spaces in the label, and uses this updated label for the log file name.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/debug_utils.py\":271-300",
            "content": "                content_before_translation, translationTable\n            )\n        with open(filepath, \"w+\", encoding=\"utf-8\") as f:\n            f.write(content_after_translation)\n        logger_print(\"File %s translated.\" % filepath)\n    else:\n        raise Exception(\"Could not open file: %s\" % filepath)\n@beartype\ndef translateFileUsingSymbolMap(filepath: str, symbolMap: SymbolMap):\n    translationTable = convertSymbolMapToTranslationTable(symbolMap)\n    translateFileUsingTranslationTable(filepath, translationTable)\ndef solve_with_translated_log_and_statistics(\n    model: ConcreteModel, solver, log_directory, label\n):\n    # def solve_with_translated_log_and_statistics(modelWrapper, solver, log_directory, label):\n    # model = modelWrapper.model\n    label = label.strip()\n    assert \" \" not in label\n    msg_label = label.replace(\"_\", \" \")\n    ret = solver.solve(\n        model,\n        tee=True,\n        logfile=(logfile := os.path.join(log_directory, f\"{label}.log\")),\n    )\n    # breakpoint()\n    smap = model.solutions.symbol_map[solver._smap_id]"
        },
        {
            "comment": "Function decomposeExpression takes an expression and returns its constant term, variable names as keys in varNameToVarObject dictionary, and their coefficients in varNameToVarCoefficient dictionary. This function helps to break down the expression into its components.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/debug_utils.py\":302-338",
            "content": "    translateFileUsingSymbolMap(logfile, smap)\n    termination_condition = ret.solver.termination_condition\n    logger_print(f\"{msg_label} termination condition:\", termination_condition)\n    logger_print(f\"{msg_label} logfile: %s\" % logfile)\n    checkResult = checkIfSolverHasSolvedModel(ret)\n    solved = checkResult.success\n    if not solved:\n        logger_print(\"solver does not have solution.\")\n    # else:\n    #     ...\n    return solved\nfrom pyomo.core.expr import current as EXPR\nfrom typing import Dict, Any\nclass DecomposedExpression(BaseModel):\n    constant: float\n    varNameToVarObject: Dict[str, Any]\n    varNameToVarCoefficient: Dict[str, float]\ndef decomposeExpression(expr):\n    const = 0\n    varNameToVarObject = {}\n    varNameToVarCoefficient = {}\n    is_linear, terms = EXPR.decompose_term(expr)\n    if is_linear:\n        for coef, var in terms:\n            if var is None:\n                const += coef\n            else:\n                varName = str(var)\n                varNameToVarObject[varName] = var\n                varNameToVarCoefficient[varName] = ("
        },
        {
            "comment": "This code defines functions to decompose an expression, get a list of variable values and their associated values from a dictionary, and sort and display the top N sorted variables by their values. The code is used for debugging utility in microgrid base.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/debug_utils.py\":339-376",
            "content": "                    varNameToVarCoefficient.get(varName, 0) + coef\n                )\n        # breakpoint()\n        return DecomposedExpression(\n            constant=const,\n            varNameToVarObject=varNameToVarObject,\n            varNameToVarCoefficient=varNameToVarCoefficient,\n        )\nfrom typing import List, Tuple\ndef getValueListFromValueDict(valueDict: Dict[str, float]):\n    valueList = list(valueDict.items())\n    return valueList\ndef sortAndDisplayVarValues(\n    valueList: List[Tuple[str, float]],\n    mw,\n    banner: str,\n    head_count=10,\n    reverse=False,\n):\n    output = []\n    output.append(f\"SORT BY {banner}\".center(70, \"=\"))  # to be commented out\n    valueList.sort(key=lambda x: x[1], reverse=reverse)\n    head_count = min(len(valueList), head_count)\n    message = [f\"reversed: {reverse}\", \"\"]\n    for i in range(head_count):\n        varName, val = valueList[i]\n        message.append(\n            \"%s\\t%s\\t%s<%s>\"\n            % (\n                varName,\n                val,\n                mw.varNameToSubmodelName[varName],"
        },
        {
            "comment": "The code contains two functions. The first function `logger_print` takes a list of strings and prints them as a message. The second function `sortAndDisplayVarValuesAndTermValues` takes dictionaries containing variable names to their values or term values, a microgrid object, and an optional submodel name. It displays the sorted and formatted variable value lists for both variables and terms, along with banners indicating the type of values being displayed (VAR NAME TO VAR VALUE and VAR NAME TO TERM VALUE). The function calls `sortAndDisplayVarValues` multiple times to achieve this.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/debug_utils.py\":377-406",
            "content": "                mw.varNameToSubmodelClassName[varName],\n            )\n        )\n    output.append(\"\\n\".join(message))\n    logger_print(*output)\n    return output\ndef sortAndDisplayVarValuesAndTermValues(\n    varNameToVarValue: Dict[str, float],\n    varNameToTermValue: Dict[str, float],\n    mw,\n    submodelName: str = \"\",\n):\n    BANNER_VARNAME_TO_VAR_VALUE = (\n        f\"{submodelName if submodelName+' ' else ''}VAR NAME TO VAR VALUE\",\n    )\n    BANNER_VARNAME_TO_TERM_VALUE = (\n        f\"{submodelName if submodelName+' ' else ''}VAR NAME TO TERM VALUE\",\n    )\n    valueListOfVarNameToVarValue = getValueListFromValueDict(varNameToVarValue)\n    valueListOfVarNameToTermValue = getValueListFromValueDict(varNameToTermValue)\n    sortAndDisplayVarValues(\n        valueListOfVarNameToVarValue, mw, BANNER_VARNAME_TO_VAR_VALUE\n    )\n    sortAndDisplayVarValues(\n        valueListOfVarNameToVarValue, mw, BANNER_VARNAME_TO_VAR_VALUE, reverse=True\n    )\n    sortAndDisplayVarValues(\n        valueListOfVarNameToTermValue, mw, BANNER_VARNAME_TO_TERM_VALUE"
        },
        {
            "comment": "The code defines two functions: `selectiveSortVarNames` and `cplex_refine_model_and_display_info`. The first function takes a dictionary of selected variable names, a dictionary mapping variable names to counts, and other parameters. It sorts and displays the selected variable names in descending order of count, and also in reverse order. The second function seems incomplete as it is not fully indented, making it difficult to determine its purpose without further context.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/debug_utils.py\":407-441",
            "content": "    )\n    sortAndDisplayVarValues(\n        valueListOfVarNameToTermValue, mw, BANNER_VARNAME_TO_TERM_VALUE, reverse=True\n    )\n    logger_print()\ndef selectiveSortVarNames(\n    keyToSelectedVarNames, varNameCountDict, mw, banner=\"SELECTIVE\"\n):\n    output = []\n    for key, selectedVarNames in keyToSelectedVarNames.items():\n        if selectedVarNames != []:  # skip empty\n            submodelVarNameCountList = [\n                (varName, count)\n                for varName, count in varNameCountDict.items()\n                if varName in selectedVarNames\n            ]\n            output.extend(\n                sortAndDisplayVarValues(\n                    submodelVarNameCountList, mw, banner=f\"{banner} <{key}>\"\n                )\n            )\n            output.extend(\n                sortAndDisplayVarValues(\n                    submodelVarNameCountList,\n                    mw,\n                    banner=f\"{banner} <{key}> REVERSE\",\n                    reverse=True,\n                )\n            )\n    return output\ndef cplex_refine_model_and_display_info("
        },
        {
            "comment": "This code refines a cplex conflict log, translates it using a symbol map, and sorts the resulting output by model. It then reads the translated content and counts occurrences of variable names, creating a list of (variable name, count) pairs. Finally, it extends an output list with sorted and displayed information related to conflict variable counts.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/debug_utils.py\":442-475",
            "content": "    mw,\n    lp_filepath,\n    log_dir,\n    smap,\n    # word_counter,\n    output_filename=\"cplex_conflict.txt\",\n    statistics_filename=\"cplex_conflict_statistics.txt\",\n):\n    word_counter = mw.word_counter\n    crp = ConflictRefinerParams(\n        model_path=lp_filepath,\n        output=(cplex_conflict_output_path := os.path.join(log_dir, output_filename)),\n        timeout=7,\n    )\n    refine_log = conflict_refiner(crp)\n    if refine_log:\n        logger_print(\"cplex refine log:\", refine_log)\n        # translate_and_append(\n        #     cplex_conflict_output_path, export_model_smap\n        # )\n        translateFileUsingSymbolMap(cplex_conflict_output_path, smap)\n        # then you sort it by model.\n        with open(cplex_conflict_output_path, \"r\") as f:\n            content = f.read()\n            varNameCountDict = word_counter(content)\n            varNameCountList = [\n                (varName, count) for varName, count in varNameCountDict.items()\n            ]\n        output = []\n        output.extend(\n            sortAndDisplayVarValues(varNameCountList, mw, banner=\"CONFLICT VAR COUNT\")"
        },
        {
            "comment": "This code appears to be part of a larger debugging utility module in Python. It seems to handle conflict resolution by counting variables, sorting them based on counts and submodel names/classes, and storing the output in a file. The functions `sortAndDisplayVarValues`, `selectiveSortVarNames`, and `filterVarNameBySubModelVarNames` are used for this purpose.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/debug_utils.py\":476-514",
            "content": "        )\n        output.extend(\n            sortAndDisplayVarValues(\n                varNameCountList,\n                mw,\n                banner=\"CONFLICT VAR COUNT REVERSE\",\n                reverse=True,\n            )\n        )\n        output.extend(\n            selectiveSortVarNames(\n                mw.submodelNameToVarName,\n                varNameCountDict,\n                mw,\n                banner=\"(CONFLICT) SUBMODEL NAME\",\n            )\n        )\n        output.extend(\n            selectiveSortVarNames(\n                mw.submodelClassNameToVarName,\n                varNameCountDict,\n                mw,\n                banner=\"(CONFLICT) SUBMODEL CLASS NAME\",\n            )\n        )\n        with open(os.path.join(log_dir, statistics_filename), \"w+\") as f:\n            f.write(\"\\n\".join(output))\n        return True\ndef filterVarNameBySubModelVarNames(mDict, submodelVarNames):\n    return {k: v for k, v in mDict.items() if k in submodelVarNames}\ndef groupBySubModelRelatedTranslationTable(\n    varNameToVarValue: Dict[str, float],"
        },
        {
            "comment": "Code snippet defines functions for grouping and analyzing objective expression by submodels. It filters variable names by submodel, sorts and displays variable values and term values, and decomposes the expression into its constituent terms and coefficients. This information can be used to analyze the objective function's components in a more granular manner.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/debug_utils.py\":515-543",
            "content": "    varNameToTermValue: Dict[str, float],\n    translationTable: Dict[str, List[str]],\n    label: str,\n    mw,\n):\n    logger_print(f\"grouping by submodel {label}:\")\n    for submodelNameOrClassName, varNames in translationTable.items():\n        submodel_vn2v = filterVarNameBySubModelVarNames(varNameToVarValue, varNames)\n        submodel_vn2t = filterVarNameBySubModelVarNames(varNameToTermValue, varNames)\n        sortAndDisplayVarValuesAndTermValues(\n            submodel_vn2v, submodel_vn2t, mw, submodelName=submodelNameOrClassName\n        )\ndef decomposeAndAnalyzeObjectiveExpression(\n    obj_expr,\n    submodelNameToVarNames: Dict[str, List[str]],\n    submodelClassNameToVarNames: Dict[str, List[str]],\n    mw,\n):\n    decomposedResult = decomposeExpression(obj_expr)\n    if decomposedResult:\n        logger_print(decomposedResult)\n        varNameToVarValue = {}\n        varNameToTermValue = {}\n        for varName, varObj in decomposedResult.varNameToVarObject.items():\n            varValue = value(varObj)\n            coef = decomposedResult.varNameToVarCoefficient["
        },
        {
            "comment": "The code performs calculations and displays results for variables related to a microgrid system. It multiplies coefficients with variable values, stores them in dictionaries, sorts the values by submodel name, and logs the objective value, constant, and their difference. The code also prints these logged values for reference.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/debug_utils.py\":544-571",
            "content": "                varName\n            ]  # seems to be no typeddict type checking in pyright\n            termValue = coef * varValue\n            varNameToVarValue[varName] = varValue\n            varNameToTermValue[varName] = termValue\n        # sort and display\n        sortAndDisplayVarValuesAndTermValues(varNameToVarValue, varNameToTermValue, mw)\n        obj_val = value(obj_expr)\n        obj_const = decomposedResult.constant\n        # now we need to sort value by submodel name (grouping). don't count keywords here, because that is done in conflict report.\n        groupBySubModelRelatedTranslationTable(\n            varNameToVarValue, varNameToTermValue, submodelNameToVarNames, \"name\", mw\n        )\n        groupBySubModelRelatedTranslationTable(\n            varNameToVarValue,\n            varNameToTermValue,\n            submodelClassNameToVarNames,\n            \"className\",\n            mw,\n        )\n        logger_print(\"(OBJ - OBJ_CONST)?\", obj_val - obj_const)\n        logger_print(\"OBJ?\", obj_val)\n        logger_print(\"OBJ_CONST?\", obj_const)"
        },
        {
            "comment": "This code defines a context manager function, \"solverOptionsContext\", that allows temporary modification of solver options during its execution. It maintains a list of option names and their corresponding old values, and updates the solver's options with new values provided. After the context management block is exited, it restores the previous option values. The function takes a solver instance and optional list of options as arguments.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/debug_utils.py\":572-604",
            "content": "    else:\n        logger_print(\"objective expression is non-linear.\")\nimport uuid\n# import weakref\nfrom contextlib import contextmanager\n@contextmanager\ndef solverOptionsContext(solver, _options: List[Tuple[str, float]] = []):\n    optionNames = []\n    optionNameToOldOptionValue = {}\n    def setSolverOption(optionName: str, optionValue):\n        optionName = optionName.strip()\n        if oldOptionValue := solver.options.get(optionName, None) is not None:\n            optionNameToOldOptionValue[optionName] = oldOptionValue\n        solver.options[optionName] = optionValue\n    def setSolverOptions(options: List[Tuple[str, float]]):\n        for optionName, optionValue in options:\n            setSolverOption(optionName, optionValue)\n    try:\n        setSolverOptions(_options)\n        yield setSolverOptions\n    finally:\n        for optionName in optionNames:\n            if optionName in optionNameToOldOptionValue.keys():\n                solver.options[optionName] = optionNameToOldOptionValue[optionName]\n            else:"
        },
        {
            "comment": "This code defines a context manager function, `setBoundsContext`, that allows setting and removing bounds on a variable within the scope of a model. It creates unique bound names using UUIDs and adds constraints to ensure the variable stays within specified limits. The bounds are removed when the context manager is exited.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/debug_utils.py\":605-634",
            "content": "                del solver.options[optionName]\n@contextmanager\ndef setBoundsContext(bound, model):\n    assert bound > 0, f\"bound must be positive.\\npassed: {bound}\"\n    all_bound_names = []\n    def setBounds(varObject):\n        bound_names = []\n        while len(bound_names) != 2:\n            name = str(uuid.uuid4()).replace(\"-\", \"_\")\n            if getattr(model, name, None) is None:\n                bound_names.append(f\"{name}\")\n        setattr(model, bound_names[0], Constraint(expr=varObject >= -bound))\n        setattr(model, bound_names[1], Constraint(expr=varObject <= bound))\n        # varObject.setlb(-bound)\n        # varObject.setub(bound)\n        all_bound_names.extend(bound_names)  # kinda like weakref?\n    # return (weakref.ref(c) for c in [lb_constraint, ub_constraint])\n    try:\n        yield setBounds\n    finally:\n        for bound_name in all_bound_names:\n            if getattr(model, bound_name, None) is not None:\n                delattr(model, bound_name)\nfrom violation_utils import modelScannerContext"
        },
        {
            "comment": "This function, solve_decompose_and_scan, takes a modelWrapper, solver, log_directory, and banner as input. It creates a directory for CPLEX logs, exports the model to an LP file, refines the model using CPLEX and displays information, and then solves the model with translated logs and statistics. If decompose is set to True, it decomposes and analyzes the objective expression when the solution is successful.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/debug_utils.py\":637-660",
            "content": "def solve_decompose_and_scan(\n    modelWrapper, solver, log_directory, banner, decompose=False\n):\n    cplex_log_dir = os.path.join(log_directory, f\"{banner}_cplex_log\")\n    os.mkdir(cplex_log_dir)\n    lp_filepath = os.path.join(log_directory, \"model.lp\")\n    # _, smap_id = modelWrapper.model.write(lp_filepath)\n    # smap = modelWrapper.model.solutions.symbol_map[smap_id]\n    lp_exported = ExportedModel(modelWrapper.model, lp_filepath)\n    cplex_refine_model_and_display_info(\n        modelWrapper, lp_filepath, cplex_log_dir, lp_exported.smap\n    )\n    # cplex_refine_model_and_display_info(modelWrapper, lp_filepath, cplex_log_dir, smap)\n    # TODO: add translate method to export model wrapper class\n    model = modelWrapper.model\n    obj_expr = modelWrapper.obj_expr\n    solved = solve_with_translated_log_and_statistics(\n        model, solver, log_directory, banner\n    )\n    if decompose:\n        if solved:\n            decomposeAndAnalyzeObjectiveExpression(\n                obj_expr,\n                modelWrapper.submodelNameToVarNames,"
        },
        {
            "comment": "The code defines a function called `checkInfeasibleOrUnboundedModel` that takes in a modelWrapper, solver, log_directory, timelimit, and max_bound as parameters. The function sets the timelimit option for the solver and calls the `solve_decompose_and_scan` function with default arguments to solve the model. It also writes the report to a file in the log directory. The obj and obj_expr attributes are set from the modelWrapper object.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/debug_utils.py\":661-695",
            "content": "                modelWrapper.submodelClassNameToVarNames,\n                modelWrapper,\n            )\n            with modelScannerContext(model) as modelScanner:\n                report = modelScanner.report()\n                report_fpath = os.path.join(log_directory, \"report.txt\")\n                with open(report_fpath, \"w+\") as f:\n                    f.write(report)\nimport random\nfrom typing import Union\n# TODO: put \"obj\" & \"obj_expr\" into modelWrapper.\ndef checkInfeasibleOrUnboundedModel(\n    modelWrapper,\n    # obj,\n    # obj_expr,\n    solver,\n    log_directory: str,\n    timelimit: float = 10,\n    max_bound: float = 1e8,\n):\n    # TODO: set param input (deepcopy) as attribute of modelWrapper\n    model = modelWrapper.model\n    obj = modelWrapper.obj\n    obj_expr = modelWrapper.obj_expr\n    solver.options[\"timelimit\"] = timelimit\n    def default_solve_decompose_and_scan(banner, decompose=False):\n        return solve_decompose_and_scan(\n            modelWrapper, solver, log_directory, banner, decompose=decompose\n        )"
        },
        {
            "comment": "The code sets options for an optimization solver, limiting iteration and preventing premature solutions. It includes parameters like maximum nodes, mipgap tolerance, time limits, memory usage, heuristic strategy, and other advanced settings.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/debug_utils.py\":697-719",
            "content": "    # phase 0: limit iteration and get premature solutions\n    # advanced start might be used along with other solvers.\n    # ref: https://www.ibm.com/docs/en/icos/12.9.0?topic=mip-starting-from-solution-starts\n    options: List[Tuple[str, Union[str, float]]] = [\n        # options: List[Tuple[str, float]] = [\n        (\"mip limits strongit\", 1),\n        (\"mip limits nodes\", 2e2),\n        (\"mip tolerances mipgap\", 1),  # mipgap\n        (\"mip tolerances absmipgap\", 1e8),\n        (\"dettimelimit\", 1e4),\n        (\"mip limits treememory\", 1e3),  # 300MB\n        (\"mip limits solutions\", 1),\n        (\"mip limits populate\", 2),\n        (\"mip strategy fpheur\", -1),\n        (\"sifting iterations\", 1e3),\n        (\"mip pool intensity\", 1),\n        (\"mip limits probetime\", 1e1),\n        (\"simplex limits iterations\", 1e4),\n        (\"mip limits repairtries\", 1e3),\n        (\"preprocessing relax\", 0),\n        (\"preprocessing reduce\", 0),\n        (\"randomseed\", random.randint(0, 1e10)),\n        (\"mip strategy presolvenode\", -1),"
        },
        {
            "comment": "This code sets various options for a solver, such as preprocessing presolve settings, MIP polish after solutions and time limits, barrier limits, network iteration settings, MIP strategy parameters, emphasis on MIP, and search type. It then uses the \"solverOptionsContext\" function to apply these options and activates the default_solve_decompose_and_scan method with decompose set to True. The objective is then deactivated.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/debug_utils.py\":720-750",
            "content": "        (\"preprocessing presolve\", \"y\"),\n        # (\"preprocessing presolve\", 0),\n        (\"mip polishafter solutions\", 1),\n        (\"mip polishafter time\", 5),\n        (\"barrier limits iteration\", 1e3),\n        (\"barrier limits growth\", 1e5),\n        (\"network iterations\", 1e3),\n        (\"mip strategy probe\", 3),\n        (\"emphasis mip\", 4),  # feasibility first\n        (\"mip strategy search\", 1)  # disable dynamic search\n        # callbacks can be used in static search\n        # ref: https://www.ibm.com/docs/en/icos/12.9.0?topic=callbacks-where-query-are-called\n    ]\n    with solverOptionsContext(solver, options):\n        default_solve_decompose_and_scan(\n            \"limit_iteration\",\n            decompose=True,\n        )\n        # solve_decompose_and_scan(\n        #     modelWrapper,\n        #     solver,\n        #     log_directory,\n        #     \"limit_iteration\",\n        #     decompose=True,\n        # )\n    # phase 1: check if infeasible.\n    obj.deactivate()\n    # TODO: Constant objective detected, replacing with a placeholder to prevent solver failure."
        },
        {
            "comment": "Code snippet initializes a null objective model, solves it without analysis, and sets limits for the objective expression's range. This is likely part of debugging utility functions in microgrid optimization modeling.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/debug_utils.py\":751-771",
            "content": "    # model_name = \"null_objective\"\n    # modelWrapper.submodelName = model_name\n    # modelWrapper.submodelClassName = model_name\n    # model.debug_null_objective = Objective()\n    model.debug_null_objective = Objective(expr=0)\n    # model.debug_null_objective = Objective(expr=0, sense=minimize)\n    # solve_with_translated_log_and_statistics(\n    #     model, solver, log_directory, \"null_objective\"\n    # )  # we don't care about this solution. don't do analysis.\n    # solve_decompose_and_scan(modelWrapper, solver, log_directory, model_name)\n    default_solve_decompose_and_scan(\"null_objective\")\n    # phase 2: limit range of objective expression\n    # model.debug_obj_expr_bound = Var()\n    # model.debug_obj_expr_bound_constraint = Constraint(\n    #     expr=model.debug_obj_expr_bound == obj_expr\n    # )\n    # setBounds(model.debug_obj_expr_bound, max_bound)\n    # model.debug_obj_lb_constraint = Constraint(expr=obj_expr >= -max_bound)\n    # model.debug_obj_ub_constraint = Constraint(expr=obj_expr <= max_bound)"
        },
        {
            "comment": "The code deactivates a debug objective, activates the original objective, sets bounds context for an expression, solves it with decomposition and scanning, and if solved, decomposes and analyzes the objective expression. This is not a persistent solver.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/debug_utils.py\":773-799",
            "content": "    model.debug_null_objective.deactivate()\n    obj.activate()\n    with setBoundsContext(max_bound, model) as setBounds:\n        setBounds(obj_expr)\n        # debug_bound_attrs = setBounds(obj_expr, max_bound, model)\n        default_solve_decompose_and_scan(\"bounded_objective\", decompose=True)\n        # solve_decompose_and_scan(\n        #     modelWrapper, solver, log_directory, \"bounded_objective\", decompose=True\n        # )\n    # solved = solve_with_translated_log_and_statistics(\n    #     model, solver, log_directory, \"bounded_objective\"\n    # )\n    # if solved:\n    #     decomposeAndAnalyzeObjectiveExpression(\n    #         obj_expr,\n    #         modelWrapper.submodelNameToVarNames,\n    #         modelWrapper.submodelClassNameToVarNames,\n    #         modelWrapper,\n    #     )\n    # this is not a persistent solver.\n    # ref: https://pyomo.readthedocs.io/en/stable/advanced_topics/persistent_solvers.html\n    # del model.debug_obj_expr_bound_constraint\n    # del model.debug_obj_expr_bound\n    # del debug_obj_ub_constraint_weakref()"
        },
        {
            "comment": "This code segment is used to decompose an objective expression, set bounds on variables using a context manager, and then solve the model. It uses weak references for variable bounds and deletes them after solving to avoid side effects on the original model. The goal is to optimize the objective function within specified bounds, allowing for early abortion if necessary.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/debug_utils.py\":800-828",
            "content": "    # del debug_obj_lb_constraint_weakref()\n    # for attrName in debug_bound_attrs:\n    #     delattr(model, attrName)\n    decomposed_obj_expr = decomposeExpression(obj_expr)\n    # var_bound_weakrefs = []\n    with setBoundsContext(max_bound, model) as setBounds:\n        for varName, varObject in decomposed_obj_expr.varNameToVarObject.items():\n            setBounds(varObject)\n        # var_lb_weakref, var_ub_weakref = setBounds(varObject, max_bound)\n        # var_bound_weakrefs.extend([var_lb_weakref, var_ub_weakref])\n        default_solve_decompose_and_scan(\n            \"bounded_objective_vars\",\n            decompose=True,\n        )\n        # solve_decompose_and_scan(\n        #     modelWrapper,\n        #     solver,\n        #     log_directory,\n        #     \"bounded_objective_vars\",\n        #     decompose=True,\n        # )\n    # for var_bound_weakref in var_bound_weakrefs:\n    #     del var_bound_weakref()\n# we need to change solver options to early abort execution."
        }
    ]
}