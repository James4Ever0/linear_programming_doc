{
    "summary": "This code includes a function for traversing and updating JSON objects, supporting nested key-value pairs while preserving order. The `jsonApply` function applies a series of functions to specific locations in the JSON object, creating a deep copy using `copy.deepcopy`, and iterating through each location with `jsonWalk`. Finally, it updates the copied JSON object using `jsonUpdate`.",
    "details": [
        {
            "comment": "This function recursively traverses a JSON-like object, yielding each key-value pair if the value is not a dictionary, list, or tuple. It handles both dictionaries and lists as input, adapting to non-pure JSON structures.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/json_utils.py\":0-29",
            "content": "from log_utils import logger_print\nimport json\n# it's json-like object, not json serializable object!\ndef jsonWalk(jsonObj, location=[]):\n    # this is not tuple. better convert it first?\n    # mlocation = copy.deepcopy(location)\n    if type(jsonObj) == dict:\n        for key in jsonObj:\n            content = jsonObj[key]\n            if type(content) not in [dict, list, tuple]:\n                yield location + [key], content\n            else:\n                # you really ok with this?\n                for mkey, mcontent in jsonWalk(content, location + [key]):\n                    yield mkey, mcontent\n    elif type(jsonObj) in [\n        list,\n        tuple,\n    ]:  # this is not pure JSON. we only have list and dicts.\n        for key, content in enumerate(jsonObj):\n            # content = jsonObj[key]\n            if type(content) not in [dict, list, tuple]:\n                yield location + [key], content\n            else:\n                for mkey, mcontent in jsonWalk(content, location + [key]):\n                    yield mkey, mcontent"
        },
        {
            "comment": "This code defines several functions for manipulating JSON objects. `jsonWalk2` converts an object to JSON and then calls `jsonWalk`, `jsonLocate` recursively finds a location within the JSON, and `jsonUpdate` updates values at specified locations in the JSON.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/json_utils.py\":30-65",
            "content": "    else:\n        raise Exception(\"Not a JSON compatible object: {}\".format(type(jsonObj)))\ndef jsonWalk2(jsonObj):\n    jsonObj = jsonify(jsonObj)\n    return jsonWalk(jsonObj)\ndef jsonLocate(jsonObj, location=[]):\n    # logger_print(\"object:\",jsonObj)\n    # logger_print(\"location:\",location)\n    if location != []:\n        # try:\n        return jsonLocate(jsonObj[location[0]], location[1:])\n        # except:\n        #     breakpoint()\n    return jsonObj\ndef jsonUpdate(jsonObj, location=[], update_content=None):\n    if location != []:\n        if type(jsonObj) == dict:\n            target = {\n                location[0]: jsonUpdate(\n                    jsonObj[location[0]],\n                    location=location[1:],\n                    update_content=update_content,\n                )\n            }\n            # logger_print(\"keys:\", location)\n            # logger_print(\"JSONOBJ:\", jsonObj)\n            # logger_print(\"update target:\", target)\n            jsonObj.update(target)\n            return jsonObj\n        elif type(jsonObj) == list:"
        },
        {
            "comment": "This code defines two functions, `jsonUpdateObject` and `jsonDeleteObject`, for updating and deleting objects in a JSON object respectively. The `jsonUpdateObject` function takes a JSON object, a location (list) to update or delete the object, and an optional update_content argument. It recursively updates the key-value pairs in the JSON object until it reaches the target location, then replaces or deletes the specified object as required. If an unsupported type is encountered, it raises an exception. The `jsonDeleteObject` function removes a nested key-value pair from the JSON object by iterating through the given location list and finally deleting the last key in the chain.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/json_utils.py\":66-96",
            "content": "            target = jsonUpdate(\n                jsonObj[location[0]],\n                location=location[1:],\n                update_content=update_content,\n            )\n            # logger_print(\"keys:\", location)\n            # logger_print(\"JSONOBJ:\", jsonObj)\n            # logger_print(\"override target:\", target)\n            jsonObj[location[0]] = target\n            return jsonObj\n        else:\n            raise Exception(\"Unsupported JSON update target type:\", type(jsonObj))\n    return update_content\ndef jsonDeleteObject(jsonObj, location: list):\n    assert len(location) > 0\n    obj = jsonObj\n    # logger_print(location, obj)\n    for key in location[:-1]:\n        obj = obj[key]\n    del obj[location[-1]]\n    return jsonObj\n# how to reload module directly, so we can include this function as well?\nimport typing\n# what the fuck is going on here?\n# ImportError: cannot import name 'jsonDeleteAllinstances' from 'lazero.utils.json' (/root/Desktop/works/lazero/lazero/utils/json.py)\n# how to reload module actually, making from <module> import <object> work?"
        },
        {
            "comment": "The code defines three functions: `jsonDeleteAllInstances`, `jsonTupleToList`, and `jsonify`. These functions work with JSON data. The first function deletes all instances of a specified type from the JSON object, while maintaining the order. The second function converts tuple values in the JSON object to lists. Lastly, the `jsonify` function can be used to refine the JSON structure and delete specific instance types while copying the original data.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/json_utils.py\":99-134",
            "content": "def jsonDeleteAllInstances(\n    jsonObj, isInstance: typing.Callable[[typing.Any], bool], copy=True\n):\n    if copy:\n        jsonObj2 = jsonObj.copy()\n    else:\n        jsonObj2 = jsonObj\n    candidates = []\n    for key, value in jsonWalk(jsonObj2):\n        if isInstance(value):\n            # delete that thing! but how to delete these things once for all?\n            candidates.append(key)\n    candidates.sort(key=lambda x: -x[-1] if type(x[-1]) == int else 1)\n    for candidate in candidates:\n        jsonObj2 = jsonDeleteObject(jsonObj, candidate)\n    return jsonObj2\ndef jsonTupleToList(jsonObj2, copy=True):\n    if copy:\n        jsonObj = jsonObj2.copy()\n    else:\n        jsonObj = jsonObj2\n    candidates = []\n    for key, value in jsonWalk(jsonObj):\n        if type(value) == tuple:\n            candidates.append(key)\n    for candidate in candidates:\n        data = jsonLocate(jsonObj, candidate)\n        data = list(data)\n        jsonObj = jsonUpdate(jsonObj, candidate, data)\n    return jsonObj\ndef jsonify(\n    jsonObj, copy=True, refine=False, isInstance=lambda obj: obj == ..."
        },
        {
            "comment": "Function `jsonApply` applies a series of functions to specific locations in the JSON object and returns the updated JSON. It uses `copy.deepcopy` for creating a deep copy of the original JSON object, and `jsonWalk` to iterate over each location within the JSON structure. For each location, it applies all provided functions and then updates the copied JSON object with the modified content using `jsonUpdate`.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/json_utils.py\":135-155",
            "content": "):  # remove ellipsis\n    jsonObj2 = jsonTupleToList(jsonObj, copy=copy)\n    jsonObj2 = jsonDeleteAllInstances(jsonObj2, isInstance, copy=copy)\n    if refine:\n        return json.loads(json.dumps(jsonObj2))\n    else:\n        return jsonObj2\n#### NEW FUNCTIONS ####\nimport copy\ndef jsonApply(jsonObj, *funcs):\n    jsonObj2 = copy.deepcopy(jsonObj)\n    for location, content in jsonWalk(jsonObj):\n        for func in funcs:\n            content = func(location, content)\n        jsonUpdate(jsonObj2, location, content)\n    return jsonObj2"
        }
    ]
}