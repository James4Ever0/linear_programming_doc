{
    "summary": "This code imports libraries, defines functions and macros, sets up a microgrid simulation, performs efficiency and cost calculations, creates device classes, updates objects with parameters, handles exceptions, exports data related to device output curves, generates time series, and provides an overview of planning schemes.",
    "details": [
        {
            "comment": "Imports necessary libraries and defines functions for data manipulation, error handling, and conversion. Imports specific models and variables from 'ies_optim' and 'constants'.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/export_format_validate.py.j2\":0-45",
            "content": "from log_utils import logger_print\n{# from ies_optim import {{ \",\".join(model_names) }} #}\n{# import device ports. #}\n{# TODO: check export logic of lithium battery. #}\n{# TODO: mark out #}\n{% macro assert(expr, message) %}\n  {% if expr != true %}\n    {% error message %}\n  {% endif %}\n{% endmacro %}\n{# {% set nonCountableDevNames = ['\u4f20\u8f93\u7ebf']%} #}\nfrom typing import List\nfrom constants import *\n{# import numpy as np #}\nfrom pyomo_environ import *\n{# from pyomo.environ import value #}\nfrom pydantic import BaseModel, validator\n{# if unit is one, use \"int\" as type, else \"float\"#}\n{# timeParam: how many hours have passed #}\nfrom ies_optim import *\n{# import math #}\nimport statistics\nfrom pyomo.core.base.var import IndexedVar\ndef sumVarList(varList:IndexedVar):\n    return sum(varList.values())\ndef addListElem(*args):\n    vals = []\n    for elem_zip in zip(*args):\n        vals.append(sum(elem_zip))\n    return vals\nimport cmath\ndef safeValue(val):\n    try:\n        return value(val)\n    except:\n        return val\ndef safeDiv(val, div):"
        },
        {
            "comment": "This code contains various functions and macro definitions. It includes safe division, safe absolute value, ReLU function for activation function in machine learning, macro BANNER for printing messages with character count, and some calculation parameters used for simulation mode.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/export_format_validate.py.j2\":46-82",
            "content": "    try:\n        return safeValue(val)/safeValue(div)\n    except:\n        return cmath.nan\n    {# EPS = 1e-10\n    return (val)/(div+EPS if (type(div) not in [int, float] or div == 0 ) else div) #}\ndef safeAbs(val):\n    if type(val) in [str]: return val\n    try:\n        return abs(val)\n    except:\n        return cmath.nan\ndef ReLU(val):\n    if type(val) not in [int, float]:\n        val = value(val)\n    if val>0:\n        return val\n    else:\n        return 0\n{# where you prepare the export data. #}\n{# in simulation mode #}\n{% set totalSimulationTimeInHour = \"model.\u8ba1\u7b97\u53c2\u6570.\u603b\u8ba1\u7b97\u65f6\u957f\"%}\n{% set \u5178\u578b\u65e5\u6743\u91cd = \"(timeParam / {})\".format(totalSimulationTimeInHour)%}\n{% set \u5e74\u5316\u6743\u91cd = \"(timeParam / \u6bcf\u5e74\u5c0f\u65f6\u6570)\" %}\n{% set extraParams = {\"\u5e73\u5747\u6548\u7387_\u5e73\u5747COP\": \u5178\u578b\u65e5\u6743\u91cd} %}\n{% macro BANNER(msg)%}\n    {% set msglen = namespace(val=0)%}\n        {% for e in list(msg)%}\n            {% set l = ord(e)%}\n            {% if l > 500 %}\n                {% set msglen.val =2+msglen.val%}\n            {% else %}\n                {% set msglen.val =1+msglen.val%}\n            {% endif %}"
        },
        {
            "comment": "This code snippet defines a macro to iterate through a parameter dictionary and update a \"paramWithUnits\" dictionary based on certain conditions. It also sets two lists, \"exceptionList\" and \"commonParamNames\", and initializes an empty dictionary \"paramWithUnits\". The code checks for unique parameters and assigns the appropriate data type for each parameter value in the dictionary.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/export_format_validate.py.j2\":83-117",
            "content": "        {% endfor %}\n{{ \"#\" * (msglen.val+4)}}\n# {{msg}} #\n{{ \"#\" * (msglen.val+4)}}\n{% endmacro %}\n{% set exceptionList = [\"\u5e73\u5747\u6548\u7387_\u5e73\u5747COP\"] %}\n{% set commonParamNames = [\n    \"\u5143\u4ef6\u540d\u79f0\",\n    \"\u5143\u4ef6\u7c7b\u578b\",\n    \"\u8bbe\u5907\u578b\u53f7\",\n    \"\u8bbe\u5907\u53f0\u6570\",\n    \"\u8bbe\u5907\u7ef4\u62a4\u8d39\u7528\",\n    \"\u65f6\u95f4\"\n]%}\n{% set paramWithUnits = dict() %}\n{% macro iterParamDict(paramDict, has_list, className, needUpdate) %}\n    {% if needUpdate %}\n        {% do paramWithUnits.update({className:list()}) %}\n    {% endif %}\n    {% set flag = namespace(val=False) %}\n    {% for paramName, paramDef in paramDict.items() %}\n        {% set PN = paramName.replace(\"/\",\"_\") %}\n        {% if flag.val == False %}\n            {% if PN not in commonParamNames %}\n                {% set flag.val=True %}\n    ## UNIQ PARAMS ##\n            {% endif %}\n        {% endif %}\n        {% if paramDef == None %}\n            {% set t = 'str'%}\n        {% elif paramDef[1] == 'one' and paramDef[0] == 1 and PN not in exceptionList %}\n            {% set t = 'int'%}\n        {% else%}\n            {% set t = 'float'%}\n        {% endif %}"
        },
        {
            "comment": "This code defines several macros for generating Python classes with validators and properties, dealing with unit conversions and customized formats. It also performs calculations based on time parameters, annual weights, and lists of values. The purpose appears to be to facilitate the creation of well-structured, validated data models in a concise manner using Jinja2 templating language.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/export_format_validate.py.j2\":118-145",
            "content": "    {{PN}} :{{'List[{}]'.format(t) if ( t!='str' and has_list) else t}}\n        {% if t!='str' %}\n    {# mag, std, old #}\n    {% if needUpdate %}\n        {% do paramWithUnits[className].append((PN, paramDef[2])) %}\n    {% endif%}\n    \"\"\"\n    \u5355\u4f4d: {{paramDef[2] if paramDef[0] == 1 else \"{} <- {}\".format(paramDef[2], paramDef[1])}}\n    \"\"\"\n            {% if paramDef[0] !=1 %}\n    @validator(\"{{PN}}\")\n    def standard_unit_to_custom_{{PN}}(cls, v):\n                {% if has_list%}\n        return [e / {{paramDef[0]}} for e in v]\n                {% else%}\n        return v / {{paramDef[0]}}\n                {% endif%}\n            {% endif %}\n        {% endif %}\n    {% endfor %}\n{% endmacro %}\n{% macro TP(val)%}(({{val}}) * timeParam){%endmacro%}\n{% macro TP_ANNUAL(val)%}(({{val}}) * ({{\u5e74\u5316\u6743\u91cd}})){%endmacro%}\n{% macro IV(vlist)%}for e in {{vlist}}.values(){% endmacro%}\n{%macro VLIST(vlist)%}[value(e) {{IV(vlist)}}]{% endmacro%}\n{%macro ELIST(elist)%}[value(e) for e in {{elist}}]{% endmacro%}\n{% macro VLIST_PAT(vlist, pattern) %}[value({{pattern.format('e')}}) {{IV(vlist)}}]{% endmacro %}"
        },
        {
            "comment": "This code defines macros for various transformations and calculations, such as VLISTINV (inverse list), VLISTDIV (divide by a constant), VLISTPOS (positive ReLU), VLISTNEG (negative ReLU), MVLIST (mean of the list), MVLISTPOS (mean of positive ReLU list), MVLISTNEG (mean of negative ReLU list), MVLISTINV (mean of inverse list), TP_MVLIST (transformed mean list with TP function), TP_MVLISTPOS (same but for positive ReLU list), TP_MVLISTNEG (same but for negative ReLU list), and TP_MVLISTINV (same but for inverse list). Additionally, there are macros for bidirectional single conversion (BIDIR_SINGLE_CVT) and bidirectional conversion with copy (BIDIR_CVT_COP), which calculate conversion values based on model variables.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/export_format_validate.py.j2\":146-159",
            "content": "{%macro VLISTINV(vlist)%}[-value(e) {{IV(vlist)}}]{% endmacro%}\n{%macro VLISTDIV(vlist, div)%}[value(safeDiv(e,{{div}})) {{IV(vlist)}}]{% endmacro%}\n{%macro VLISTPOS(vlist)%}[ReLU(e) {{IV(vlist)}}]{% endmacro%}\n{%macro VLISTNEG(vlist)%}[-ReLU(-e) {{IV(vlist)}}]{% endmacro%}\n{%macro MVLIST(vlist)%}statistics.mean({{VLIST(vlist)}}){% endmacro%}\n{%macro MVLISTPOS(vlist)%}statistics.mean({{VLISTPOS(vlist)}}){% endmacro%}\n{%macro MVLISTNEG(vlist)%}statistics.mean({{VLISTNEG(vlist)}}){% endmacro%}\n{%macro MVLISTINV(vlist)%}statistics.mean({{VLISTINV(vlist)}}){% endmacro%}\n{% macro TP_MVLIST(vlist)%}{{TP(MVLIST(vlist))}}{% endmacro %}\n{% macro TP_MVLISTPOS(vlist)%}{{TP(MVLISTPOS(vlist))}}{% endmacro %}\n{% macro TP_MVLISTNEG(vlist)%}{{TP(MVLISTNEG(vlist))}}{% endmacro%}\n{% macro TP_MVLISTINV(vlist)%}{{TP(MVLISTINV(vlist))}}{% endmacro%}\n{% macro BIDIR_SINGLE_CVT(x,y)%}(safeDiv(sumVarList(model.{{x}}.x_pos),sumVarList(model.{{y}}.x_neg)) * sumVarList(model.{{x}}.b_pos)){%endmacro%}\n{% macro BIDIR_CVT_COP(x,y)%}value({{BIDIR_SINGLE_CVT(x,y)}}+ {{BIDIR_SINGLE_CVT(y,x)}})/model.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570{% endmacro%}"
        },
        {
            "comment": "This code sets up various parameters and their mappings for a microgrid simulation. It defines common parameters like energy production, fuel consumption, COP (Coefficient of Performance), and revenue. Then, it maps these parameters to specific energy sources such as solar, wind, hydrogen, gasoline, and diesel generators. The code also performs calculations to determine efficiency and cost for each generator based on the input data.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/export_format_validate.py.j2\":160-199",
            "content": "{# {% set EPS = \"1e-10\"%} #}\n{% set commonSimParams = {\n    \"\u4ea7\u7535\u91cf\": TP_MVLIST(\"model.\u7535\u63a5\u53e3\"),\n    \"\u67f4\u6cb9\u6d88\u8017\u91cf\": TP_MVLIST(\"model.\u71c3\u6599\u63a5\u53e3\"),\n    \"\u5929\u7136\u6c14\u6d88\u8017\u91cf\": TP_MVLIST(\"model.\u71c3\u6599\u63a5\u53e3\"),\n    \"\u5355\u5411\u7535\u8f6c\u6362COP\": \"- safeDiv({},{})\".format(MVLIST(\"model.\u7535\u8f93\u5165\"), MVLIST(\"model.\u7535\u8f93\u51fa\")),\n    '\u7535\u6536\u5165': \"-value(model.\u603b\u6210\u672c\u5e74\u5316)\",\n    '\u6c22\u6c14\u6536\u5165': \"-value(model.\u603b\u6210\u672c\u5e74\u5316)\",\n    \"\u67f4\u6cb9\u6d88\u8017\u8d39\u7528\": \"value(model.\u603b\u6210\u672c\u5e74\u5316)\"\n}%}\n{% set CSPL = {} %}\n{% macro dictValueToKeyValuePair(a,b)%}\n{% for k,v in a.items() %}\n    {% do b.update({k: (k,v)}) %}\n{% endfor %}\n{% endmacro %}\n{% do dictValueToKeyValuePair(commonSimParams, CSPL) %}\n{% set simDevParamMapping = {\n    \"\u67f4\u6cb9\": [\n        CSPL['\u67f4\u6cb9\u6d88\u8017\u8d39\u7528'],\n        CSPL['\u67f4\u6cb9\u6d88\u8017\u91cf'],\n    ],\n    \"\u7535\u8d1f\u8377\": [\n        (\"\u7535\u8d1f\u8377\", TP_MVLISTINV(\"model.\u7535\u63a5\u53e3\")),\n        CSPL['\u7535\u6536\u5165']\n    ],\n    \"\u6c22\u8d1f\u8377\": [\n        (\"\u6c22\u6c14\u6d88\u8017\u91cf\", TP_MVLISTINV(\"model.\u6c22\u6c14\u63a5\u53e3\")),\n        CSPL['\u6c22\u6c14\u6536\u5165']\n    ],\n    \"\u5149\u4f0f\u53d1\u7535\": [\n        CSPL['\u4ea7\u7535\u91cf']\n    ],\n    \"\u98ce\u529b\u53d1\u7535\": [\n        CSPL['\u4ea7\u7535\u91cf']\n    ],\n    \"\u67f4\u6cb9\u53d1\u7535\": [\n        CSPL['\u4ea7\u7535\u91cf'],\n        CSPL['\u67f4\u6cb9\u6d88\u8017\u91cf'],\n        (\"\u5e73\u5747\u6548\u7387_\u5e73\u5747COP\",\"safeDiv({}, model.\u71c3\u6599\u70ed\u503c * ({}))\".format(commonSimParams['\u4ea7\u7535\u91cf'],commonSimParams['\u67f4\u6cb9\u6d88\u8017\u91cf']))"
        },
        {
            "comment": "This code defines a dictionary with different types of energy components in a microgrid system and their associated parameters. It also includes macros for exporting data related to each component. The values for some parameters are determined during the parsing of the topological structure, while others like gas turbine fuel heat value or battery efficiency depend on specific models.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/export_format_validate.py.j2\":200-232",
            "content": "    ],\n    \"\u71c3\u6c14\u53d1\u7535\u673a\":[\n        CSPL['\u4ea7\u7535\u91cf'],\n        CSPL['\u5929\u7136\u6c14\u6d88\u8017\u91cf'],\n        (\"\u4ea7\u70ed\u91cf\", \"({}) + ({})\".format(TP_MVLIST(\"model.\u9ad8\u6e29\u70df\u6c14\u4f59\u70ed\u63a5\u53e3\"), TP_MVLIST(\"model.\u7f38\u5957\u6c34\u4f59\u70ed\u63a5\u53e3\")))\n    ],\n    \"\u9502\u7535\u6c60\":[\n        (\"\u5e73\u5747\u6548\u7387_\u5e73\u5747COP\", (\"safeDiv(ReLU(({}) - ({})) , (-({})))\".format(TP_MVLISTPOS(\"model.\u7535\u63a5\u53e3\"), \"model.InitSOC * model.TotalCapacity\", TP_MVLISTNEG(\"model.\u7535\u63a5\u53e3\"))))\n    ], \n    \"\u53d8\u538b\u5668\":[\n        (\"\u5e73\u5747\u6548\u7387_\u5e73\u5747COP\", commonSimParams['\u5355\u5411\u7535\u8f6c\u6362COP'])\n    ],\n    \"\u53d8\u6d41\u5668\": [\n        (\"\u5e73\u5747\u6548\u7387_\u5e73\u5747COP\", commonSimParams['\u5355\u5411\u7535\u8f6c\u6362COP'])\n    ],\n    \"\u53cc\u5411\u53d8\u6d41\u5668\": [\n        (\"\u5e73\u5747\u6548\u7387_\u5e73\u5747COP\", BIDIR_CVT_COP(\"\u50a8\u80fd\u7aef_\",\"\u7ebf\u8def\u7aef_\"))\n    ],\n    \"\u4f20\u8f93\u7ebf\": [\n        (\"\u5e73\u5747\u6548\u7387_\u5e73\u5747COP\", commonSimParams['\u5355\u5411\u7535\u8f6c\u6362COP'])\n    ],\n    \"\u7535\u89e3\u69fd\": [\n        (\"\u7535\u8d1f\u8377\", TP_MVLISTINV(\"model.\u7535\u63a5\u53e3\")),\n        (\"\u6c22\u6c14\u4ea7\u91cf\", TP_MVLIST(\"model.\u5236\u6c22\u63a5\u53e3\")),\n        (\"\u4ea7\u70ed\u91cf\", TP_MVLIST(\"model.\u8bbe\u5907\u4f59\u70ed\u63a5\u53e3\"))\n    ]\n}%}\n{# \u67f4\u6cb9\u53d1\u7535\u7b49\u7684\u71c3\u6599\u70ed\u503c\u5728\u89e3\u6790\u62d3\u6251\u7ed3\u6784\u7684\u65f6\u5019\u8fdb\u884c\u786e\u5b9a #}\n{% macro export_data_with_model(devName, obj, classType, paramDict, needAbs=False)%}\n    @staticmethod\n    def export(model: {{devName}}\u6a21\u578b, timeParam:float):\n    {% do obj.update(dict(\u5143\u4ef6\u540d\u79f0 = \"model.\u8bbe\u5907\u4fe1\u606f.\u8bbe\u5907\u540d\u79f0\")) %}"
        },
        {
            "comment": "This code defines a macro function `update_obj` that takes an object, parameter dictionary, device name, and a list of check parameters. It first checks if the device has unique parameters by comparing keys in both the parameter dictionary and the object's key set. If not, it raises an assertion error with relevant information for debugging. Then, it updates the object with the unique parameters from the dictionary and returns the updated object.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/export_format_validate.py.j2\":233-259",
            "content": "{{caller()}}\n{% set _paramKeys = []%}\n{% for key in paramDict.keys() %}\n    {% do _paramKeys.append(key.replace(\"/\",'_'))%}\n{% endfor%}\n{% set paramKeys = _set(_paramKeys) %}\n{% set objKeys = _set(obj.keys()) %}\n{% do assert(paramKeys.__eq__(objKeys), \"devName: {}\\n{} (code uniq)\\n{} (template uniq)\".format(devName, paramKeys.difference(objKeys), objKeys.difference(paramKeys))) %}\n        return {{devName}}{{classType}}(\n    {% for key, value in obj.items() %}\n        {% if needAbs %}\n            {{key}} = safeAbs({{value if key not in extraParams.keys() else \"({}) * ({})\".format(value, extraParams[key])}}),\n        {% else %}\n            {{key}} = {{value}},\n        {% endif %}\n    {% endfor %}\n        )\n{% endmacro%}\n{% macro update_obj(obj, paramDict, devName, CPN, check) %}\n    {% if devName in paramDict.keys() %}\n        {% if len(paramDict[devName]) == 0 %}\n            {% error \"\u8bbe\u5907'{}'\u7684\u72ec\u6709\u53c2\u6570\u672a\u8bbe\u7f6e\".format(devName) %}\n        {% endif%}\n        {% for k, v in paramDict[devName]%}\n            {% if k in CPN%}\n                {% error(\"\u8bbe\u5907'{}'\u7684\u53c2\u6570'{}'\u4e0d\u662f\u72ec\u6709\u53c2\u6570\".format(devName, k)) %}"
        },
        {
            "comment": "This code defines a macro named 'iterParamDict' and creates a class for each device type in the simulation results. It updates objects with parameters, validates if there are unique device-specific parameters, and adds additional attributes like device model and maintenance fees. The code also handles exceptions and provides error messages when needed.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/export_format_validate.py.j2\":260-293",
            "content": "            {% endif%}\n            {% do obj.update({k : v}) %}\n        {% endfor%}\n    {% else%}\n        {% if check%}\n            {% error \"\u8bbe\u5907'{}'\u6ca1\u6709\u72ec\u6709\u53c2\u6570\".format(devName)%}\n        {% endif%}\n    {% endif %}\n{% endmacro %}\n{{ BANNER(\"\u4eff\u771f\u7ed3\u679c\") }}\n{% for devName, paramDict in main_data['\u4eff\u771f\u7ed3\u679c'].items() %}\n    {% if devName == 'ALL' %}\n        {% continue %}\n    {% endif %}\nclass {{devName}}\u4eff\u771f\u7ed3\u679c(BaseModel):\n{{iterParamDict(paramDict, false, devName, true)}}\n{% set obj = {} %}\n{% call export_data_with_model(devName, obj, '\u4eff\u771f\u7ed3\u679c', paramDict, needAbs=True)%}\n    {% do obj.update(                \n        \u5143\u4ef6\u7c7b\u578b = \"model.\u8bbe\u5907\u4fe1\u606f.__class__.__name__.strip('\u4fe1\u606f')\"\n    )%}\n    {% if devName not in nonDevNames %}\n        {% do obj.update(\n            dict(\n                \u8bbe\u5907\u578b\u53f7 = \"model.\u8bbe\u5907\u4fe1\u606f.\u8bbe\u5907\u578b\u53f7\",\n                \u8bbe\u5907\u7ef4\u62a4\u8d39\u7528 = TP_ANNUAL(\"value(model.\u603b\u56fa\u5b9a\u7ef4\u62a4\u6210\u672c + model.\u603b\u53ef\u53d8\u7ef4\u62a4\u6210\u672c\u5e74\u5316)\"),\n                )\n        )\n        %}\n        {% if devName not in nonCountableDevNames %}\n            {% do obj.update(\n                \u8bbe\u5907\u53f0\u6570 = \"value(model.DeviceCount)\","
        },
        {
            "comment": "The code defines a dictionary called `commonTimeSeries` with various electricity parameters for different energy sources and devices. It then creates an empty dictionary `CTSL` and converts the key-value pairs from `commonTimeSeries` to key-value pairs in `CTSL`. Another dictionary `timeSeriesMapping` is created, which contains a list of energy source types as keys, and a list of corresponding time series parameters as values. The code then creates these time series for each energy source type using the data from `commonTimeSeries` and `CTSL`.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/export_format_validate.py.j2\":294-340",
            "content": "            )%}\n        {% endif%}\n    {% endif %}\n    {% do update_obj(obj, simDevParamMapping, devName, commonParamNames, True) %}\n{% endcall %}\n{% endfor %}\n{% set commonTimeSeries = dict(\n \u53d1\u7535\u529f\u7387=VLIST('model.\u7535\u63a5\u53e3'),\n \u5145\u7535\u529f\u7387=VLISTNEG('model.\u7535\u63a5\u53e3'),\n \u653e\u7535\u529f\u7387=VLISTPOS('model.\u7535\u63a5\u53e3'),\n \u8377\u7535\u5bb9\u91cf=VLIST_PAT('model.CurrentTotalCapacity', \"{}\"),\n \u8377\u7535\u72b6\u6001=VLIST_PAT('model.CurrentTotalCapacity', \"safeDiv({} , model.TotalCapacity)\"),\n \u7535\u8f6c\u6362\u529f\u7387=VLIST('model.\u7535\u8f93\u51fa'),\n)\n%}\n{% set CTSL = {} %}\n{% do dictValueToKeyValuePair(commonTimeSeries, CTSL) %}\n{% set timeSeriesMapping = {\n    \"\u5149\u4f0f\u53d1\u7535\": [\n       CTSL['\u53d1\u7535\u529f\u7387']\n    ],\n    \"\u98ce\u529b\u53d1\u7535\": [\n       CTSL['\u53d1\u7535\u529f\u7387']\n    ],\n    \"\u67f4\u6cb9\u53d1\u7535\":\n    [\n        CTSL['\u53d1\u7535\u529f\u7387']\n    ],\n    \"\u71c3\u6c14\u53d1\u7535\u673a\":\n    [\n        CTSL['\u53d1\u7535\u529f\u7387'],\n        (\"\u6bcf\u5c0f\u65f6\u5929\u7136\u6c14\u8017\u91cf\", VLISTINV('model.\u71c3\u6599\u63a5\u53e3')),\n        (\"\u7f38\u5957\u6c34\u70ed\u529f\u7387\", VLIST('model.\u7f38\u5957\u6c34\u4f59\u70ed\u63a5\u53e3')),\n        (\"\u70df\u6c14\u70ed\u529f\u7387\", VLIST('model.\u9ad8\u6e29\u70df\u6c14\u4f59\u70ed\u63a5\u53e3')),\n    ],\n    \"\u9502\u7535\u6c60\":\n    [\n        (\"\u7535\u529f\u7387\",VLIST('model.\u7535\u63a5\u53e3')),\n        CTSL['\u8377\u7535\u5bb9\u91cf'],\n        CTSL['\u8377\u7535\u72b6\u6001']\n    ],\n    \"\u53d8\u538b\u5668\":[\n        ('\u8f6c\u6362\u529f\u7387',commonTimeSeries['\u7535\u8f6c\u6362\u529f\u7387'])\n    ],\n    \"\u53d8\u6d41\u5668\":[\n        ('\u8f6c\u6362\u529f\u7387', commonTimeSeries['\u7535\u8f6c\u6362\u529f\u7387'])"
        },
        {
            "comment": "This code is defining a class called \"\u8bbe\u5907\u51fa\u529b\u66f2\u7ebf\" and iterating over different device names in the main_data dictionary. It updates parameters for each device, such as removing \"\u653e\u7535\u529f\u7387\" for \"\u9502\u7535\u6c60\". It creates an object with time series data for each device and calls a function to export data based on the device name. This class appears to be related to exporting data for device output curves.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/export_format_validate.py.j2\":341-371",
            "content": "    ],\n    \"\u53cc\u5411\u53d8\u6d41\u5668\":[\n        ('\u8f6c\u6362\u529f\u7387', 'addListElem({}, {})'.format(VLIST('model.\u50a8\u80fd\u7aef_.x_pos'),VLISTINV('model.\u7ebf\u8def\u7aef_.x_pos')))\n    ],\n    \"\u7535\u8d1f\u8377\":[('\u8017\u7535\u529f\u7387', VLISTINV('model.\u7535\u63a5\u53e3'))],\n    \"\u6c22\u8d1f\u8377\":[('\u8017\u6c22\u6d41\u91cf', VLISTINV('model.\u6c22\u6c14\u63a5\u53e3'))],\n    \"\u4f20\u8f93\u7ebf\":[('\u4f20\u8f93\u529f\u7387', VLISTINV('model.\u7535\u8f93\u5165'))],\n    \"\u7535\u89e3\u69fd\":[\n        ('\u8017\u7535\u529f\u7387', VLISTINV('model.\u7535\u63a5\u53e3')),\n        (\"\u4ea7\u6c22\u6d41\u91cf\", VLIST('model.\u5236\u6c22\u63a5\u53e3')),\n        (\"\u4ea7\u70ed\u529f\u7387\", VLIST('model.\u8bbe\u5907\u4f59\u70ed\u63a5\u53e3')), \n    ]\n}\n%}\n{# use \"call\" here. #}\n{{ BANNER(\"\u8bbe\u5907\u51fa\u529b\u66f2\u7ebf\") }}\n{% for devName, paramDict in main_data['\u8bbe\u5907\u51fa\u529b\u66f2\u7ebf'].items() %}\nclass {{devName}}\u51fa\u529b\u66f2\u7ebf(BaseModel):\n{% if devName == '\u9502\u7535\u6c60' %}\n    {% do paramDict.pop('\u653e\u7535\u529f\u7387') %}\n    {% do paramDict.update(dict(\u7535\u529f\u7387 = paramDict.pop('\u5145\u7535\u529f\u7387'))) %}\n    {# {% set paramDict['\u7535\u529f\u7387'] = paramDict.pop('\u5145\u7535\u529f\u7387') %} #}\n{% endif %}\n{{ iterParamDict(paramDict, true, devName, false) }}\n{% set obj = {} %}\n{% do obj.update(dict(\u65f6\u95f4=\"list(range(model.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570))\")) %}\n{% call export_data_with_model(devName, obj, '\u51fa\u529b\u66f2\u7ebf', paramDict) %}\n    {% do update_obj(obj, timeSeriesMapping, devName, [], False) %}\n{% endcall %}"
        },
        {
            "comment": "Ends the for loop and provides a comment explaining that this code block used to display an overview of planning schemes, requiring the scheme type as input. It has been moved to \"ies_optim.py\".",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/export_format_validate.py.j2\":372-376",
            "content": "{% endfor %}\n{# \u89c4\u5212\u65b9\u6848\u6982\u89c8\u5c31\u662f\u628a\u6240\u6709\u7684\u89c4\u5212\u7ed3\u679c\u8be6\u60c5\u7edf\u8ba1\u4e00\u4e0b\u653e\u5230\u8fd9\u91cc \u9700\u8981\u4f20\u5165\u65b9\u6848\u7c7b\u578b #}\n{# moved to \"ies_optim.py\" #}"
        }
    ]
}