{
    "summary": "This code manages Docker images and containers, with functions for updates, stopping/pruning, and finding latest image versions. It builds, tags, updates Docker images, sets container settings, binds logs, attaches to running containers (non-Windows) while handling errors, exceptions, and providing Windows fixes.",
    "details": [
        {
            "comment": "The code imports necessary modules and defines functions for executing docker commands, parsing docker image build time, and handling the architecture. It also sets timeout values and a placeholder for tagging the final image with date and time.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/docker_launch.py\":0-39",
            "content": "from log_utils import logger_print\nfrom log_utils import DOCKER_IMAGE_TAG\nimport progressbar\nimport sys\nimport os\nimport easyprocess, func_timeout\nfrom typing import Tuple\nimport re\nimport datetime\nLATEST = \"latest\"\nDOCKER = \"docker\"\ndef docker_exec(cmd):\n    logger_print(\"executing docker command: {}\".format(cmd))\n    os.system(f\"{DOCKER} {cmd}\")\ndef parse_docker_image_builttime_and_get_timestamp(builttime: str):\n    no_letter_builttime, _ = re.subn(r\"[a-zA-Z]\", \"\", builttime)\n    no_letter_builttime = no_letter_builttime.strip()\n    time_format = r\"%Y-%m-%d %H:%M:%S %z\"\n    builttime_timeobj = datetime.datetime.strptime(no_letter_builttime, time_format)\n    builttime_timestamp = builttime_timeobj.timestamp()\n    return builttime_timestamp\nimport json\n# TODO: tag the final image with date & time\n# docker tag microgrid_docplex:<latest_version> microgrid_docplex:latest\nDOCKER_PROC_TIMEOUT = 15\nACCEPTED_DOCKER_ARCH = \"x86_64\"  # the only one.\n# hold, we may check the architecture.\ndef number_to_version(number: int):"
        },
        {
            "comment": "Extracts the three digits from a given number, converts a tuple of version into an integer and back to tuple with incremented value, retrieves image information using Docker command and returns the image hash, and gets the latest build time for a specified Docker image.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/docker_launch.py\":40-76",
            "content": "    digit1 = number // 100  # extract the first digit (hundreds place)\n    digit2 = (number // 10) % 10  # extract the second digit (tens place)\n    digit3 = number % 10  # extract the third digit (ones place)\n    result = (digit1, digit2, digit3)\n    return result\ndef version_to_number(version: Tuple[int, int, int]):\n    number = 100 * version[0] + 10 * version[1] + version[2]\n    return number\ndef increment_version(prev_version: Tuple[int, int, int]):\n    ver_plain = version_to_number(prev_version)\n    ver_plain += 1\n    ver_new = number_to_version(ver_plain)\n    return ver_new\ndef get_image_hash(image_name):\n    dat = get_image_info(image_name)\n    image_hash = dat[\"ID\"]\n    return image_hash\ndef get_image_info(image_name):\n    cmd = f\"docker images --format json {image_name}\"\n    proc = easyprocess.EasyProcess(cmd).call()\n    stdout = proc.stdout\n    dat = json.loads(stdout)\n    return dat\ndef get_latest_builttime_of_image(image_basename):\n    latest_image_name = image_basename + f\":{LATEST}\"\n    dat = get_image_info(latest_image_name)"
        },
        {
            "comment": "This code defines a function `check_if_latest_builttime_of_image_is_out_of_date` to determine if the latest build time of a Docker image is older than a specified threshold. The function calculates the age of the image by comparing the current timestamp with the latest build time, and returns True if the age exceeds the threshold (set as one day in this case). It also logs a message indicating whether the image is out of date or not.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/docker_launch.py\":77-111",
            "content": "    builttime: str = dat[\"CreatedAt\"]\n    return builttime\nONE_HOUR = 3600\nONE_DAY = ONE_HOUR * 24\n# ONE_WEEK = ONE_DAY * 7\n# IMAGE_OUT_OF_DATE_THRESHOLD = ONE_WEEK\nIMAGE_OUT_OF_DATE_THRESHOLD = ONE_DAY\ndef check_if_latest_builttime_of_image_is_out_of_date(image_basename):\n    out_of_date = True\n    current_timestamp = datetime.datetime.now().timestamp()\n    latest_builttime = get_latest_builttime_of_image(image_basename)\n    latest_builttime_timestamp = parse_docker_image_builttime_and_get_timestamp(\n        latest_builttime\n    )\n    age = current_timestamp - latest_builttime_timestamp\n    if age > IMAGE_OUT_OF_DATE_THRESHOLD:\n        logger_print(\n            f\"image {image_basename} is out of date. latest builttime: {latest_builttime}\"\n        )\n    else:\n        out_of_date = False\n    return out_of_date\ndef call_cmd_with_timeout_and_return_proc(cmd, timeout=DOCKER_PROC_TIMEOUT):\n    proc = easyprocess.EasyProcess(cmd).call(timeout=timeout)\n    return proc\ndef check_if_docker_arch_acceptable():\n    cmd = \"docker info -f json\""
        },
        {
            "comment": "This code kills and prunes all Docker containers by listing them, iterating over their IDs, and executing the \"docker container kill\" command for each one. The code uses a progress bar for visual feedback during the process. It is wrapped in functions and may be used with other scripts or in different contexts.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/docker_launch.py\":112-147",
            "content": "    proc = call_cmd_with_timeout_and_return_proc(cmd)\n    obj = json.loads(proc.stdout)\n    arch = obj[\"Architecture\"]\n    if arch != ACCEPTED_DOCKER_ARCH:\n        raise Exception(\n            \"Unsupported architecture: %s (run under %s instead)\"\n            % (arch, ACCEPTED_DOCKER_ARCH)\n        )\ncheck_if_docker_arch_acceptable()\n\"\"\"\ncreate or import docker environment with scripts.\nyou may use Dockerfile.\n\"\"\"\n# TODO: replace with docker compose\n# TODO: put this into release archive\n# TODO: show both cli argument help\nimport docker\nfrom config_utils import getConfig\ndef killAndPruneAllContainers():\n    cmd = \"docker container ls\"\n    proc = call_cmd_with_timeout_and_return_proc(cmd)\n    # proc = easyprocess.EasyProcess(\"docker container ls -a\").call()\n    if proc.stdout:\n        lines = proc.stdout.split(\"\\n\")[1:]\n        container_ids = [line.split(\" \")[0] for line in lines]\n        for cid in progressbar.progressbar(container_ids):\n            cmd = f\"docker container kill {cid}\"\n            try:\n                func_timeout.func_timeout(2, os.system, args=(cmd,))"
        },
        {
            "comment": "This code is handling the termination of Docker containers. It's checking for a configuration flag to determine if it should only kill containers or also prune them. The code is using Docker SDK from_env() method to connect to Docker, and recursive_split_path() function to handle file paths. The sys.maxsize < 2**32 check seems unrelated.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/docker_launch.py\":148-185",
            "content": "            except func_timeout.FunctionTimedOut:\n                logger_print(\n                    f'timeout while killing container \"{cid}\".\\nmaybe the container is not running.'\n                )\n            # os.system(f\"docker container kill -s SIGKILL {cid}\")\n        os.system(\"docker container prune -f\")\n# from config import IESEnv\nfrom config_dataclasses import IESEnv, DockerLauncherConfig\nconfig = getConfig(DockerLauncherConfig)\n# breakpoint()\n# logger_print(config.reduce())\n# breakpoint()\nif config.TERMINATE_ONLY:\n    killAndPruneAllContainers()\n    logger_print(\"TERMINATE_ONLY is set. Exiting.\")\n    exit(0)\ndef recursive_split_path(path):\n    leftover, ret = os.path.split(path)\n    if ret != \"\":\n        yield ret\n    if leftover != \"\":\n        yield from recursive_split_path(leftover)\nclient = docker.from_env()\nabs_curdir = os.path.abspath(\".\")\npath_components_generator = recursive_split_path(abs_curdir)\nrel_curdir = next(path_components_generator)\nrel_pardir = next(path_components_generator)\nif sys.maxsize < 2**32:"
        },
        {
            "comment": "This code segment checks if the system is 32-bit or lower, raises an exception if true as Docker does not support it. It also updates Dockerfile paths based on the current directory and sets the release environment flag accordingly. The code defines a function to build a Docker image with optional parameters for image tag, dockerfile path, and context path. In a non-release environment, it may set an additional suffix for copying files from the release directory instead of directly from the current directory due to its large size.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/docker_launch.py\":186-210",
            "content": "    raise Exception(\"Your system is 32bit or lower, which Docker does not support.\")\ndockerfile_init_path = \"Dockerfile_init\"\ndockerfile_main_path = \"Dockerfile_main\"\ndockerfile_patch_path = \"Dockerfile_patch\"\ndockerfile_update_path = \"Dockerfile_update\"\ndockerfile_update_self_path = \"Dockerfile_update_self\"\nRELEASE_ENV = False\nif rel_curdir != \"microgrid_base\":\n    RELEASE_ENV = True\n    os.system(\n        f\"sed -i 's/jubilant-adventure2\\\\/microgrid_base/{rel_pardir}\\\\/init/g' {dockerfile_patch_path} {dockerfile_update_path}\",\n    )\n# client = docker.DockerClient(\n#     base_url=\"//./pipe/docker_engine\" if os.name == \"nt\" else \"unix://var/run/docker.sock\"\n# )\ndef build_image(image_tag, dockerfile_path, context_path):\n    global RELEASE_ENV\n    # if not RELEASE_ENV:\n    #     os.environ['ADDITIONAL_SUFFIX'] ='/microgrid_server_release' # copy files from release, don't straight from curdir because it is huge.\n    # env_additional_suffix = '' if RELEASE_ENV else 'env ADDITIONAL_SUFFIX=/microgrid_server_release' # copy files from release, don't straight from curdir because it is huge."
        },
        {
            "comment": "The code defines ADDITIONAL_SUFFIX_ARGS based on the RELEASE_ENV, builds a Docker image using the specified DOCKER and dockerfile_path, sets build arguments to copy files from the release folder instead of the current directory. It then logs and executes the command using os.system(), raising an exception if there's an abnormal exit code. The code also includes functions for generating image tags based on version information.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/docker_launch.py\":211-231",
            "content": "    ADDITIONAL_SUFFIX_ARGS = \"../\" if RELEASE_ENV else \"microgrid_server_release\"\n    docker_buildargs = f\"--build-arg ADDITIONAL_SUFFIX_ARGS=/{ADDITIONAL_SUFFIX_ARGS}\"  # copy files from release, don't straight from curdir because it is huge.\n    command = f\"{DOCKER} build -t {image_tag} -f {dockerfile_path} --progress plain {docker_buildargs} {context_path}\"\n    logger_print(\"build command:\", command)\n    # command = f\"{env_additional_suffix} {DOCKER} build -t {image_tag} -f {dockerfile_path} --progress plain {context_path}\"\n    # logger_print(command)\n    exit_code = os.system(command)\n    if exit_code:\n        raise Exception(f\"Abnormal exit code {exit_code} for command:\\n{' '*4+command}\")\n    return True\n# import datetime\nupdate_image_basename = \"microgrid_update\"\ngenerate_image_with_tag = (\n    lambda basename, verinfo: f\"{basename}:v{'.'.join([str(i) for i in verinfo])}\"\n)\ngenerate_update_image_with_tag = lambda verinfo: generate_image_with_tag(\n    update_image_basename, verinfo\n)\ninit_verinfo = number_to_version(1)"
        },
        {
            "comment": "This code sets up image storage directories and configurations for microgrid Docker images. It checks if the image directory exists, creates it if not, and initializes a gitignore file to exclude all files in the directory. The function `list_image_tags()` returns a list of Docker image tags from the current set of available images.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/docker_launch.py\":232-260",
            "content": "update_image_first_ver_tag = generate_update_image_with_tag(init_verinfo)\nupdate_image_tag = f\"{update_image_basename}:latest\"\n# update_interval = datetime.timedelta(days=config.UPDATE_INTERVAL_IN_DAYS)\n# update_image_file_path = os.path.join(os.path.expanduser(\"~\"), \".microgrid_update\")\nfinal_image_tag = f\"microgrid_docplex:{LATEST}\"\nimage_tag = f\"microgrid_server:{LATEST}\"\nremote_image_tag = f\"agile4im/microgrid_server:{LATEST}\"\nintermediate_image_tag = \"microgrid_init\"\ncontext_path = \"../../\"\nimage_storage_dir = \"images\"\nimage_path = os.path.join(image_storage_dir, f\"{image_tag.replace(':','_')}.tar\")\nimage_storage_gitignore = os.path.join(image_storage_dir, \".gitignore\")\nif os.path.exists(image_storage_dir):\n    if not os.path.isdir(image_storage_dir):\n        raise Exception(\"'%s' exists and is not a directory!\" % image_storage_dir)\nelse:\n    os.mkdir(image_storage_dir)\nwith open(image_storage_gitignore, \"w+\") as f:\n    f.write(\"*\\n\")\ndef list_image_tags():\n    images = client.images.list()\n    image_tags = [tag for image in images for tag in image.tags]"
        },
        {
            "comment": "This code checks if the final and image tags are present in the list of existing image tags. If not, it either pulls the remote image or builds and saves a new image from the local context.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/docker_launch.py\":261-285",
            "content": "    return image_tags\nimage_tags = list_image_tags()\nif final_image_tag not in image_tags:\n    if image_tag not in image_tags:\n        logger_print(\"image not found: %s\" % image_tag)\n        if not os.path.exists(image_path):\n            if config.NO_HALFDONE:\n                # run remote pull command.\n                docker_exec(f\"pull {remote_image_tag}\")\n                docker_exec(f\"tag {remote_image_tag} {image_tag}\")\n            else:\n                # first build the image, then export.\n                logger_print(\"building image...\")\n                # client.images.build(\n                #     path=context_path, tag=image_tag, dockerfile=dockerfile_path, quiet=False\n                # )\n                build_image(intermediate_image_tag, dockerfile_init_path, context_path)\n                build_image(image_tag, dockerfile_main_path, context_path)\n                image = client.images.get(image_tag)\n                # image.save()\n                logger_print(\"saving image...\")\n                # not working via api."
        },
        {
            "comment": "This code is responsible for handling the loading and patching of Docker images. If an image path is specified, it either loads or saves the image accordingly. If a scheduled update is required, it checks if the update interval has been exceeded and forces an update if necessary. The code also includes deprecated functions related to image updates using file paths and time intervals.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/docker_launch.py\":286-316",
            "content": "                # with open(image_path, \"wb\") as f:\n                #     for chunk in image.save():\n                #         f.write(chunk)\n                docker_exec(f\"save -o {image_path} {image_tag}\")\n        else:\n            logger_print(\"loading image...\")\n            docker_exec(f\"load -i {image_path}\")\n            # with open(image_path, \"rb\") as f:\n            #     data = f.read()\n            #     client.images.load(data)\n    # now patch the image.\n    build_image(final_image_tag, dockerfile_patch_path, context_path)\n# DEPRECATED: may not need to use scheduled update here.\n# import pathlib\n# import time\n# def need_update_image():\n#     if config.FORCE_UPDATE:\n#         logger_print(f\"user forced to update image.\")\n#         return True\n#     ti_c = os.path.getctime(update_image_file_path)\n#     time_now = time.time()\n#     last_update_td = datetime.timedelta(seconds=time_now - ti_c)\n#     if last_update_td > update_interval:\n#         logger_print(\n#             f\"last update time: {last_update_td.days} days ago >= update interval: {update_interval.days} days\""
        },
        {
            "comment": "This code stops running containers, prunes stopped containers, updates the Docker image if needed, and then loads the exported image to launch the server. It also has a debugging feature to prevent potential hanging issues by checking if an update is necessary before proceeding with image operations.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/docker_launch.py\":317-345",
            "content": "#         )\n#         logger_print(\"need to update image.\")\n#         return True\n#     return False\n# DEPRECATED: this may hang forever\n# all_containers = client.containers.list(all=True)\n# logger_print(\"stopping running containers...\")\n# for container in progressbar.progressbar(all_containers):\n#     container.stop()\n# logger_print(\"pruning stopped containers...\")\n# client.containers.prune()\n# if need_update_image():\n#     # remove old image first, then build new image\n#     # how does docker build work anyway? does it cache based on file hash?\n#     killAndPruneAllContainers()\n#     docker_exec(f\"image rm {dockerfile_update_path}\")\n#     if build_image(update_image_tag, dockerfile_update_path, context_path) is True:\n#         os.remove(update_image_file_path)\n#         pathlib.Path(update_image_file_path).touch()\n#     else:\n#         raise Exception(\"Image update failed.\")\n# load the exported image.\n# run the command to launch server within image from here.\n# host_path = \"./microgrid_server_release\"\nlog_path = ("
        },
        {
            "comment": "Code sets the log path based on RELEASE_ENV and creates a directory if it doesn't exist. Adjusts path for NT systems, kills and prunes all containers. Finds latest version info of an image with latest tags.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/docker_launch.py\":346-378",
            "content": "    os.path.join(os.path.expanduser(\"~\"), \"logs_container\")\n    if RELEASE_ENV\n    else \"./logs_container\"\n)\nif os.path.isdir(log_path):\n    logger_print(f\"skipping creating logger directory: {log_path}\")\nelif not os.path.exists(log_path):\n    os.mkdir(log_path)\nelse:\n    raise Exception(f\"{log_path} exists but is not a directory.\")\n# if RELEASE_ENV:\n# host_path = \"../.\" + host_path\n# host_mount_path = os.path.abspath(host_path)\n# don't need this workaround when using docker-py.\ndef refine_nt_abspath_for_docker_mount(path: str):\n    if os.name == \"nt\":\n        disk_symbol, pathspec = path.split(\":\")\n        pathspec = pathspec.replace(\"\\\\\", \"/\")\n        path = f\"//{disk_symbol.lower()}{pathspec}\"\n    return path\nhost_log_path = os.path.abspath(log_path)\n# host_log_path = refine_nt_abspath_for_docker_mount(host_log_path)\nkillAndPruneAllContainers()\ndef find_latest_verinfo_of_image_with_latest_image_tags(image_basename: str):\n    image_tags = list_image_tags()\n    return find_latest_verinfo_of_image(image_tags, image_basename)"
        },
        {
            "comment": "This function finds the latest image tag and its associated version information for a given image basename by iterating over a list of image tags. If an appropriate image tag is found, it returns the generated image with that tag. If no matching tags are found, it returns None. The function also checks if the version format is valid (three positive integers) and updates the latest version information if a newer one is found.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/docker_launch.py\":381-404",
            "content": "def find_latest_image_tag_with_latest_verinfo_of_image_and_latest_image_tags(\n    image_basename: str,\n):\n    verinfo = find_latest_verinfo_of_image_with_latest_image_tags(image_basename)\n    if verinfo is None:\n        return None\n    return generate_image_with_tag(image_basename, verinfo)\ndef find_latest_verinfo_of_image(image_tags: list[str], image_basename: str):\n    latest_verinfo = None\n    for image_tag in image_tags:\n        if image_tag.startswith(image_basename):\n            verpart_ = image_tag.split(\":v\")\n            if len(verpart_) == 2:\n                verpart = verpart_[1]\n                verinfo = tuple([int(i) for i in verpart.split(\".\")])\n                assert len(verinfo) == 3, (\n                    \"invalid version format at: %s\\nhint: must be three positive integers splited by dot, and first two on the right must be smaller than 10\"\n                    % image_tag\n                )\n                if latest_verinfo is None:\n                    latest_verinfo = verinfo\n                elif verinfo > latest_verinfo:"
        },
        {
            "comment": "This code snippet defines a function find_latest_verinfo_of_update_image() that finds the latest versioned image with a tag starting with update_image_basename. It also includes a contextmanager function, check_if_need_to_tag_context(), to check if an image needs to be tagged based on its current hash and previous hash values. The logger_print() is used for printing the latest version found for the image.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/docker_launch.py\":405-435",
            "content": "                    latest_verinfo = verinfo\n                else:\n                    continue\n    if latest_verinfo is None:\n        raise Exception(\n            f\"Could not find any versioned image ({image_basename}) with tag starting with {update_image_basename}\"\n        )\n    logger_print(f\"latest version for image {image_basename}: {latest_verinfo}\")\n    return latest_verinfo\ndef find_latest_verinfo_of_update_image(image_tags: list[str]):\n    return find_latest_verinfo_of_image(image_tags, update_image_basename)\nfrom contextlib import contextmanager\n@contextmanager\ndef check_if_need_to_tag_context(image_tag):\n    info = dict(need_to_tag=True, previous_hash=None)\n    _image_tags = list_image_tags()\n    if image_tag in _image_tags:\n        info[\"need_to_tag\"] = False\n        info[\"previous_hash\"] = get_image_hash(image_tag)\n    def get_need_to_tag():\n        if info[\"need_to_tag\"] == False:\n            # check hash now.\n            current_hash = get_image_hash(image_tag)\n            need_to_tag = info[\"previous_hash\"] != current_hash"
        },
        {
            "comment": "This code defines a function `build_and_tag` that builds and tags Docker images. It uses the context manager `check_if_need_to_tag_context` to determine if an image needs to be tagged after building it. The `build_image` function is called with the appropriate image tags, latest and latest version, along with the dockerfile path and context path. If the image needs to be tagged, it executes a Docker command to tag the image. However, if the final image tag is set to LATEST, it skips the update process.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/docker_launch.py\":436-468",
            "content": "        return need_to_tag\n    try:\n        yield get_need_to_tag\n    finally:\n        del _image_tags\n        del get_need_to_tag\n        del info\ndef build_and_tag(\n    latest_version_image_tag,\n    latest_image_tag,\n    dockerfile_path,\n    context_path,\n    # override_need_to_tag = False\n):\n    with check_if_need_to_tag_context(latest_image_tag) as get_need_to_tag:\n        build_image(latest_image_tag, dockerfile_path, context_path)\n        # build_image(latest_version_image_tag, dockerfile_path, context_path)\n        need_to_tag = get_need_to_tag()\n    # check if we really want to tag this (is this updated?)\n    if need_to_tag:\n        # if override_need_to_tag or need_to_tag:\n        docker_exec(f\"tag {latest_image_tag} {latest_version_image_tag}\")\n    # docker_exec(f\"tag {latest_version_image_tag} {latest_image_tag}\")\n# update with tagging\nif config.FINAL_IMAGE_TAG != LATEST:\n    logger_print(f\"skipping update because of custom tag: {config.FINAL_IMAGE_TAG}\")\nelif update_image_tag in image_tags:\n    if update_image_first_ver_tag not in image_tags:"
        },
        {
            "comment": "This code snippet is performing a recursive update of a Docker image. It first tags the initial versioned final image with a specific tag and then checks if the image needs an update based on the current version information. If it's outdated, it increments the version; otherwise, it retains the old tag to save space.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/docker_launch.py\":469-493",
            "content": "        logger_print(\n            f\"tagging first versioned final image ({update_image_tag}) build as: {update_image_first_ver_tag}\"\n        )\n        docker_exec(f\"tag {update_image_tag} {update_image_first_ver_tag}\")\n        # image_tags.append(update_image_first_ver_tag)\n    logger_print(\"performing recursive update of final image\")\n    # old_verinfo = find_latest_verinfo_of_update_image(image_tags)\n    old_verinfo = find_latest_verinfo_of_image_with_latest_image_tags(\n        update_image_basename\n    )\n    if old_verinfo > init_verinfo:\n        out_of_date = check_if_latest_builttime_of_image_is_out_of_date(\n            update_image_basename\n        )\n    else:\n        logger_print(\n            f\"forcing update because latest version info equals to initial version info: {init_verinfo}\"\n        )\n        out_of_date = True\n    if out_of_date:\n        latest_verinfo = increment_version(old_verinfo)\n    else:\n        logger_print(f\"using old tag: {old_verinfo} (to save space)\")\n        latest_verinfo = old_verinfo"
        },
        {
            "comment": "This code segment builds and tags Docker images, updates them if necessary, and retrieves the latest image tag based on the version information. If the final image tag is set to LATEST, it assigns the latest update image tag; otherwise, it uses the specified final image tag. It also handles errors related to mount source path and provides a fix by restarting the Docker engine (for Windows).",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/docker_launch.py\":495-525",
            "content": "    latest_verinfo = increment_version(old_verinfo)\n    latest_update_image_tag = generate_update_image_with_tag(latest_verinfo)\n    build_and_tag(\n        latest_update_image_tag,\n        update_image_tag,\n        dockerfile_update_path,\n        # dockerfile_update_self_path,\n        context_path,\n    )\nelse:\n    logger_print(\"building final image (non-recursive)\")\n    build_and_tag(\n        update_image_first_ver_tag,\n        update_image_tag,\n        dockerfile_update_path,\n        context_path,\n    )\nlatest_update_image = (\n    find_latest_image_tag_with_latest_verinfo_of_image_and_latest_image_tags(\n        update_image_basename\n    )\n)\n# build_image(update_image_tag, dockerfile_update_path, context_path)\n# BUG: error while creating mount source path\n# FIX: restart the docker engine (win) if fail to run container (usually caused by unplugging anything mounted by volume)\ncontainer_image_tag = (\n    latest_update_image\n    if config.FINAL_IMAGE_TAG == LATEST\n    else f\"{update_image_basename}:{config.FINAL_IMAGE_TAG}\""
        },
        {
            "comment": "This code runs a Docker container with the specified image tag, environment variables, command, and configuration. It can be used to run different commands within the container depending on the needs of the application. The container is set to detach from the terminal, restart on failure, and use a tty for better monitoring.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/docker_launch.py\":526-550",
            "content": ")\ncontainer_env = {DOCKER_IMAGE_TAG: container_image_tag, **config.reduce().dict()}\nlogger_print(\"running container...\")\ntry:\n    container = client.containers.run(\n        # final_image_tag,\n        container_image_tag,\n        # image_tag,\n        environment=container_env,\n        # environment=dict(os.environ),  # may override normal environment variables?\n        # remove=True,\n        remove=False,  # to get the image hash.\n        # command=\"ls -lth microgrid\",\n        # command=\"bash fastapi_tmuxp.sh\",\n        # command=\"bash -c 'cd microgrid/init && bash init.sh && cd ../server && bash fastapi_tmuxp.sh windows'\",\n        command=\"bash -c 'cd microgrid/server && bash fastapi_tmuxp.sh windows'\",\n        # command=\"bash -c 'cd microgrid/server && ls -lth .'\",\n        # command=\"echo 'hello world'\",\n        detach=True,\n        restart_policy={\n            \"Name\": \"on-failure\"\n        },  # restart indefinitely, though might not always work.\n        # detach=False,\n        # we need to monitor this.\n        tty=True,"
        },
        {
            "comment": "This code is configuring Docker container settings, including specifying ports and volumes. It binds the host's log path to the container's logs directory with read-write permissions, and sets the working directory inside the container. The detach keys configuration is mentioned for non-Windows operating systems.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/docker_launch.py\":551-571",
            "content": "        ports={f\"{(server_port:=9870)}/tcp\": server_port},\n        volumes={  # if using volumes, you need to copy the contents of the volume to outside to view it.\n            # docker run --rm \\\n            #   --mount source=myvolume,target=/mnt \\\n            #   -v /backup:/backup \\\n            #   alpine cp -r /mnt /backup\n            host_log_path: {\"bind\": \"/root/microgrid/server/logs\", \"mode\": \"rw\"}\n            # \"microgrid_logs\": {\"bind\": \"/root/microgrid/server/logs\", 'mode':'rw'}\n        }\n        # volumes={\n        #     host_mount_path: {\"bind\": (mount_path := \"/root/microgrid\"), \"mode\": \"rw\"}\n        # },\n        # volumes={\"<HOST_PATH>\": {\"bind\": \"<CONTAINER_PATH>\", \"mode\": \"rw\"}},\n        # working_dir=os.path.join(mount_path, \"server\"),\n    )\n    short_id = container.short_id\n    logger_print(\"attaching to: %s\" % short_id)\n    # ref: https://www.howtogeek.com/devops/how-to-detach-from-a-docker-container-without-stopping-it/\n    if os.name == \"nt\":\n        logger_print(\"unable to configure detach keys on windows.\")"
        },
        {
            "comment": "This code is a part of a Docker container management system. It uses the `os.system` function to attach to a running Docker container using either the `docker attach` or `docker attach --detach-keys` command based on certain conditions. The code also handles exceptions, prints error messages if any and logs information about the created container and service availability.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/docker_launch.py\":572-596",
            "content": "        os.system(f\"docker attach {short_id}\")\n    else:\n        os.system(f'docker attach {short_id} --detach-keys=\"{config.DETACH_KEYS}\"')\n    # while True:\n#     # exit_code = os.system(f\"docker attach {short_id} --detach-keys '{config.DETACH_KEYS}'\")\n#     # exit_code = os.system(f\"docker attach {short_id} --detach-keys '{config.DETACH_KEYS}'\")\n#     exit_code = os.system(f\"docker attach {short_id}\")\n#     if exit_code == 0:\n#         break\nexcept:\n    import traceback\n    traceback.print_exc()\n    raise Exception(\"Error running new container.\\nYou may restart the docker engine.\")\n# logger_print(container.logs())\n# import rich\n# logger_print(container.__dict__)\n# breakpoint()\ncontainer_id = container.attrs[\"Config\"][\"Hostname\"]\ncontainer_name = container.attrs[\"Name\"].strip(\"/\")\nlogger_print(f\"Container {container_id} ({container_name}) created.\")\nlogger_print(f\"Service available at: http://localhost:{server_port}\")\n# for line in container.logs(stream=True):\n#     logger_print(line.decode('utf-8').strip(), end=None)  # binary string."
        }
    ]
}