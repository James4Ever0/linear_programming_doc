{
    "summary": "The code tests Pyomo's bounds detection, defines classes for variable and constraint details, validates domains and constraints using dictionaries, introduces PiecewiseInfo class for constraint decomposition, and includes ModelScanner class to handle microgrid problems.",
    "details": [
        {
            "comment": "This code assigns invalid values to variables and constraints in Pyomo, a modeling language for optimization problems. It tests if the system can detect bounds/constraint violations by setting variable values outside of their defined ranges and creating conflicting constraints.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/check_invalid_var_and_constraints.py\":0-36",
            "content": "# assign invalid values to var and constraints.\n# see if the system can detect bounds/constraint violations\nfrom pyomo.environ import *\n# advanced logical expression linearization using pyomo.GDP\n# ref: https://pyomo.readthedocs.io/en/latest/modeling_extensions/gdp/modeling.html\nmodel = ConcreteModel()\nmodel.a = Var(within=Binary)\nmodel.b = Var(within=NonNegativeReals)\nmodel.c = Var(within=NonNegativeIntegers)\nmodel.d = Var(bounds=(-10, 10))\nmodel.e = Var()\nmodel.a.set_value(1.5)\nmodel.b.set_value(-0.5)\nmodel.c.set_value(100.5)\nmodel.d.set_value(-11)\nmodel.e.set_value(-50.5)\nmodel.con1 = Constraint(expr=model.d >= model.c)\nmodel.con2 = Constraint(expr=model.b >= model.c)\nmodel.con3 = Constraint(expr=model.a + model.b <= -model.c)\nmodel.con4 = Constraint(expr=model.b * model.b >= model.c)\n# piecewise is not constraint, though.\nmodel.pw = Piecewise(\n    model.c,  # y_var\n    model.e,  # x_var\n    pw_pts=[-100, 0, 100],\n    pw_repn=\"MC\",\n    # pw_repn=\"SOS2\",\n    f_rule=[100, 0, -100],\n    pw_constr_type=\"EQ\",\n    unbounded_domain_var=True,"
        },
        {
            "comment": "This code defines a function to get the violation of variable bounds and checks for any violations in the given variable. It also defines a class to store these violations and a method to moderate the violation value based on tolerance. This is used to check the validity of constraints in a model.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/check_invalid_var_and_constraints.py\":37-78",
            "content": "    warn_domain_coverage=False,\n)\nmodel.pw.MC_poly_x[1] = 1\nmodel.pw.MC_poly_x[2] = 1\nmodel.pw.MC_bin_y[1] = 1\nmodel.pw.MC_bin_y[2] = 1\n# you might need to sort it out. check how much further it goes.\n# from pyomo.util.infeasible import log_infeasible_constraints,\nfrom pydantic import BaseModel\nfrom typing import Union, Literal, List\ndef get_var_or_constraint_bounds(var: Var):\n    lb, ub = None, None\n    if var.has_lb():\n        lb = value(var.lower, exception=False)\n    if var.has_ub():\n        ub = value(var.upper, exception=False)\n    return lb, ub\nclass VarViolation(BaseModel):\n    bound_violation: float\n    vartype_violation: float\n    @property\n    def has_violation(self):\n        return any([v > 0 for v in [self.bound_violation, self.vartype_violation]])\ndef moderate_violation(violation, tol):\n    assert tol >= 0, f\"violation tolerance must be non-negative\\npassed: {tol}\"\n    violation = abs(violation)\n    if violation <= tol:\n        violation = 0\n    return violation\ndef get_lower_bound_violation(val: float, lower_bound: Union[float, None], tol: float):"
        },
        {
            "comment": "This code checks the bounds and values of variables in a constraint programming problem. It calculates violations based on these bounds and values, ensuring that they are within the defined tolerances. The get_bounds_violation function checks both lower and upper bounds for validity and returns a violation score. The get_boolean_or_integer_violation function handles violations related to variable type (boolean or integer). The constructVarChecker function creates a variable checker function using provided domain name and bounds information, taking into account the specific type of variable being checked.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/check_invalid_var_and_constraints.py\":79-112",
            "content": "    violation = 0\n    if any([v is None for v in [val, lower_bound]]):\n        return violation\n    if val < lower_bound:\n        violation = moderate_violation(lower_bound - val, tol)\n    return violation\ndef get_bounds_violation(\n    val: float,\n    lower_bound: Union[float, None],\n    upper_bound: Union[float, None],\n    tol: float,\n):\n    if all([bound is not None for bound in [lower_bound, upper_bound]]):\n        assert (\n            lower_bound <= upper_bound\n        ), \"invalid bound ({lower_bound}, {upper_bound})\\nlower bound shall not be greater than upper bound.\"\n    violation = get_lower_bound_violation(val, lower_bound, tol)\n    if violation == 0:\n        violation = get_lower_bound_violation(upper_bound, val, tol)\n    return violation\ndef get_boolean_or_integer_violation(val: float, tol: float):\n    violation = val % 1\n    if violation != 0:\n        violation = min([violation, 1 - violation])\n    return moderate_violation(violation, tol)\ndef constructVarChecker(domainName: str, domainBounds):\n    def checker(var: Var, tol: float):"
        },
        {
            "comment": "This code defines a function `getVarCheckers()` that utilizes the LRU cache decorator and checks for bounds and variable type violations in variables of different data types. It creates checker functions for each variable domain (e.g., Reals, Integers, Booleans) and returns them. The checker function identifies if a given value is within the variable's bound and has the correct data type.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/check_invalid_var_and_constraints.py\":113-149",
            "content": "        val = value(var)\n        var_bounds = get_var_or_constraint_bounds(var)\n        bounds_violation = get_bounds_violation(val, *var_bounds, tol)\n        vartype_violation = get_bounds_violation(val, *domainBounds, tol)\n        if vartype_violation == 0:\n            if \"Integers\" in domainName or domainName in [\"Boolean\", \"Binary\"]:\n                vartype_violation = get_boolean_or_integer_violation(val, tol)\n        varViolation = VarViolation(\n            bound_violation=bounds_violation, vartype_violation=vartype_violation\n        )\n        return (varViolation, *var_bounds)\n    return checker\nfrom functools import lru_cache\n@lru_cache(maxsize=1)\ndef getVarCheckers():\n    varDomainObjs = [\n        Reals,\n        PositiveReals,\n        NonPositiveReals,\n        NegativeReals,\n        NonNegativeReals,\n        Integers,\n        PositiveIntegers,\n        NonPositiveIntegers,\n        NegativeIntegers,\n        NonNegativeIntegers,\n        Boolean,\n        Binary,\n    ]\n    checkers = {}\n    for varDomainObj in varDomainObjs:"
        },
        {
            "comment": "The code defines a class `VarInfo` for storing variable information including its name, value, domain type, and lower/upper bounds. It also defines a class `ConstraintInfo` for storing constraint details such as its name, associated variables, violation level, and representation. The code creates a dictionary of checkers to validate the domain and constraints of variables.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/check_invalid_var_and_constraints.py\":150-189",
            "content": "        domainName = varDomainObj.name\n        domainBounds = varDomainObj.bounds()\n        checker = constructVarChecker(domainName, domainBounds)\n        checkers[domainName] = checker\n    return checkers\nclass VarInfo(BaseModel):\n    varName: str\n    val: float\n    domainName: Literal[  # usually, just need to check if it is boolean/binary/integer.\n        \"Reals\",\n        \"PositiveReals\",\n        \"NonPositiveReals\",\n        \"NegativeReals\",\n        \"NonNegativeReals\",\n        \"Integers\",\n        \"PositiveIntegers\",\n        \"NonPositiveIntegers\",\n        \"NegativeIntegers\",\n        \"NonNegativeIntegers\",\n        \"Boolean\",\n        \"Binary\",\n    ]\n    lower_bound: Union[float, None]\n    upper_bound: Union[float, None]\n    violation: VarViolation\nclass ConstraintInfo(BaseModel):\n    constraintName: str\n    variables: List[VarInfo]\n    violation: float\n    representation: str\n    is_linear: bool\n    @property\n    def has_violation(self):\n        # TODO: consider overall violation among variables inside constraint\n        return self.violation > 0"
        },
        {
            "comment": "This function retrieves the violation and variable information for a single variable. It first checks if the variable's domain has a corresponding checker in the getVarCheckers dictionary. If so, it calls the checker to determine the violation status and bounds of the variable. The function returns a VarInfo object containing the variable name, value, domain name, lower bound, upper bound, and violation information. If the violation is not needed or if there's no violation, it doesn't return anything.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/check_invalid_var_and_constraints.py\":192-225",
            "content": "from pyomo.core.expr import current as EXPR\ndef get_violation_of_infeasible_bounds_and_vartype_of_single_var(\n    var: Var, tol=1e-6, violation_only: bool = True\n):\n    checkers = getVarCheckers()\n    domainName = var.domain._name\n    varName = var.name\n    val = value(var)\n    if domainName in checkers.keys():\n        checker = checkers[domainName]\n        varViolation, lower_bound, upper_bound = checker(\n            var, tol\n        )  # violation shall be positive when actual violation is greater than tolerance, otherwise zero.\n        if violation_only and not varViolation.has_violation:\n            return\n        varInfo = VarInfo(\n            varName=varName,\n            val=val,\n            domainName=domainName,\n            lower_bound=lower_bound,\n            upper_bound=upper_bound,\n            violation=varViolation,\n        )\n        return varInfo\n    else:\n        raise Exception(\"unknown domain name: %s\" % domainName)\nfrom typing import Dict\ndef getVarInfoListFromVarInfoDict(varInfoDict: Dict[str, VarInfo]):"
        },
        {
            "comment": "Class \"SkipSettingNoneDict\" is a custom dictionary that doesn't allow None values.\nVarInfoDictUpdator class initializes SkipSettingNoneDict and updates varInfoDict with relevant var info when not None.\nget_violation_of_infeasible_bounds_and_vartype returns violation and vartype of a single var.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/check_invalid_var_and_constraints.py\":226-261",
            "content": "    varInfoList = list(varInfoDict.values())\n    return varInfoList\nfrom contextlib import contextmanager\nfrom copy import deepcopy\nclass SkipSettingNoneDict(dict):\n    def __setitem__(self, name, value):\n        if value is not None:\n            super().__setitem__(name, value)\n@contextmanager\ndef varInfoDictContext():\n    class VarInfoDictUpdator:\n        def __init__(self, violation_only: bool = False):\n            self._varInfoDict = SkipSettingNoneDict()\n            self.violation_only = violation_only\n        def update(self, var):\n            if var is not None:\n                varName = str(var)\n                if varName not in self._varInfoDict.keys():\n                    self._varInfoDict[\n                        varName\n                    ] = get_violation_of_infeasible_bounds_and_vartype_of_single_var(\n                        var, violation_only=self.violation_only\n                    )\n        @property\n        def varInfoDict(self):\n            return deepcopy(self._varInfoDict)\n        def __del__(self):"
        },
        {
            "comment": "This code defines functions for obtaining variable information from linear and nonlinear constraints in a mathematical model. It utilizes context management to update the variable dictionary and returns it after processing each constraint. The code also includes utility functions for walking through expressions and handling different types of variables.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/check_invalid_var_and_constraints.py\":262-297",
            "content": "            del self._varInfoDict\n    varInfoDictUpdator = VarInfoDictUpdator()\n    try:\n        yield varInfoDictUpdator\n    finally:\n        del varInfoDictUpdator\ndef decompose_linear_constraint_from_terms_and_get_variable_info(terms):\n    with varInfoDictContext() as varInfoDictUpdator:\n        for coef, var in terms:\n            varInfoDictUpdator.update(var)\n            return varInfoDictUpdator.varInfoDict\nfrom pyomo.core.base.var import *\nVarType = Union[Var, _VarData, _GeneralVarData, VarList, SimpleVar, ScalarVar]\nfrom typing import Iterable\ndef walk_expression(expr: Expression):\n    if (args := getattr(expr, \"args\", None)) is not None:\n        if isinstance(args, Iterable):\n            for arg in args:\n                if isinstance(arg, VarType):\n                    yield arg\n                else:\n                    yield from walk_expression(arg)\ndef decompose_nonlinear_constraint_and_get_variable_info_dict(constr: Constraint):\n    with varInfoDictContext() as varInfoDictUpdator:\n        for var in walk_expression(constr.body):"
        },
        {
            "comment": "Function to decompose constraints and retrieve variable information.\nDecomposes terms in a constraint and retrieves variable information.\nReturns linear constraints, nonlinear constraints.\nPiecewise constraints are not yet supported.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/check_invalid_var_and_constraints.py\":298-332",
            "content": "            varInfoDictUpdator.update(var)\n        return varInfoDictUpdator.varInfoDict\ndef decompose_constraint_and_get_variable_info(constr: Constraint):\n    is_linear, terms = EXPR.decompose_term(constr.body)\n    # decompose non-linear constraints.\n    if is_linear:\n        varInfoDict = decompose_linear_constraint_from_terms_and_get_variable_info(\n            terms\n        )\n    else:\n        varInfoDict = decompose_nonlinear_constraint_and_get_variable_info_dict(constr)\n    varInfoList = getVarInfoListFromVarInfoDict(varInfoDict)\n    return is_linear, varInfoList\n# TODO: iterate over piecewise constraints.\nimport numpy as np\nfrom pyomo.core.base.piecewise import SimplePiecewise, IndexedPiecewise\nPiecewiseType = Union[Piecewise, SimplePiecewise, IndexedPiecewise]\nfrom typing import Tuple\n# do not use this. we need the data.\n# from pydantic import PrivateAttr\nclass PiecewiseBaseInfo(BaseModel):\n    piecewiseName: str\n    piecewiseTypeName: Literal[\"Piecewise\", \"SimplePiecewise\", \"IndexedPiecewise\"]\n    inputVarInfo: VarInfo"
        },
        {
            "comment": "This code defines a class PiecewiseInfo that extends PiecewiseBaseInfo. It takes a piecewise base info as input and builds output_violation and input_domain_violation based on the input's domain violation and output point discrepancy. The method is tolerant to small variations in values with a given tolerance level.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/check_invalid_var_and_constraints.py\":333-362",
            "content": "    outputVarInfo: VarInfo\n    input_points: List[float]\n    output_points: List[float]\nclass PiecewiseInfo(PiecewiseBaseInfo):\n    # autogenerated.\n    output_violation: float\n    input_domain_violation: float\n    input_domain: Tuple[float, float]\n    @classmethod\n    def build(cls, piecewiseBaseInfo: PiecewiseBaseInfo, tol=1e-6):\n        input_domain = (\n            min(piecewiseBaseInfo.input_points),\n            max(piecewiseBaseInfo.input_points),\n        )\n        input_point = piecewiseBaseInfo.inputVarInfo.val\n        output_point = piecewiseBaseInfo.outputVarInfo.val\n        input_domain_violation = get_bounds_violation(input_point, *input_domain, tol=0)\n        if input_domain_violation == 0:  # within bound.\n            expected_output = np.interp(\n                input_point,\n                piecewiseBaseInfo.input_points,\n                piecewiseBaseInfo.output_points,\n            )\n            output_violation = abs(output_point - expected_output)\n            output_violation = moderate_violation(output_violation, tol)"
        },
        {
            "comment": "The code defines a class, likely for a microgrid model or optimization problem. It checks for input and output domain violations, has properties to determine if there is any violation, and includes methods to sort and filter list elements based on an attribute.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/check_invalid_var_and_constraints.py\":363-402",
            "content": "        else:\n            output_violation = 0\n        return cls(\n            **piecewiseBaseInfo.dict(),\n            output_violation=output_violation,\n            input_domain_violation=input_domain_violation,\n            input_domain=input_domain,\n        )\n    @property\n    def has_violation(self):\n        return any(\n            [v != 0 for v in [self.output_violation, self.input_domain_violation]]\n        )\nimport rich\nclass MagicList(list):\n    def append(self, value):\n        if value is not None:\n            super().append(value)\n    def sort_by_attr(self, attr: str, reverse=False):\n        super().sort(key=lambda e: getattr(e, attr), reverse=reverse)\n        return self\n    def filter_by_attr(self, attr: str, negate=False):\n        if negate:\n            ret = filter(lambda e: not getattr(e, attr), self)\n        else:\n            ret = filter(lambda e: getattr(e, attr), self)\n        return MagicList(ret)\nclass ModelInfo:\n    def __init__(self):\n        self.constraints: List[ConstraintInfo] = MagicList()"
        },
        {
            "comment": "This code initializes a ModelScanner class and its attributes, allowing the user to deactivate constraints in a model. The constraint method iterates through active Constraint objects in the model, checking if their bodies have violations based on given bounds and tolerance level. If violation_only is True and there is no violation, it continues without adding that constraint's information to the ModelInfo object.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/check_invalid_var_and_constraints.py\":403-429",
            "content": "        self.variables: List[VarInfo] = MagicList()\n        self.piecewises: List[PiecewiseInfo] = MagicList()\nclass ModelScanner:\n    def __init__(self, model: ConcreteModel, tol=1e-6, violation_only=True):\n        self.tol = tol\n        self.model = model\n        self.modelInfo = ModelInfo()\n        self.violation_only = violation_only\n    def constraint(self):\n        # you can deactivate some constraints.\n        # model.constraint.activate()\n        # model.constraint.deactivate()\n        for constr in self.model.component_data_objects(\n            ctype=Constraint, active=True, descend_into=True\n        ):\n            body_value = value(constr.body, exception=False)\n            constraint_bounds = get_var_or_constraint_bounds(constr)\n            constraintName = constr.name\n            if body_value is not None:\n                violation = get_bounds_violation(\n                    body_value, *constraint_bounds, self.tol\n                )\n                if self.violation_only and violation == 0:\n                    continue"
        },
        {
            "comment": "This code checks the model's variables and constraints for any abnormalities or violations. It decompose the constraint, gathers variable info, and appends to the modelInfo list. The function returns a list of violated constraints and infeasible variables.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/check_invalid_var_and_constraints.py\":430-454",
            "content": "                representation = str(constr.expr)\n                is_linear, varInfoList = decompose_constraint_and_get_variable_info(\n                    constr\n                )\n                constraintInfo = ConstraintInfo(\n                    constraintName=constraintName,\n                    is_linear=is_linear,\n                    variables=varInfoList,\n                    violation=violation,\n                    representation=representation,\n                )\n                self.modelInfo.constraints.append(constraintInfo)\n        return self.modelInfo.constraints\n    def variable(self):\n        for var in self.model.component_data_objects(ctype=Var, descend_into=True):\n            self.modelInfo.variables.append(\n                get_violation_of_infeasible_bounds_and_vartype_of_single_var(\n                    var, self.tol, violation_only=self.violation_only\n                )\n            )\n        return self.modelInfo.variables\n    def piecewise(self):\n        for pw in self.model.block_data_objects(active=True, descend_into=True):"
        },
        {
            "comment": "This code is checking if the input variable 'pw' is a PiecewiseType. If so, it extracts the name and type of the piecewise function, as well as relevant parameters (input/output vars, points). It then creates a PiecewiseBaseInfo object with this information and a tolerance value. If violation_only is True and the PiecewiseInfo doesn't have a violation, the loop continues.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/check_invalid_var_and_constraints.py\":455-478",
            "content": "            if isinstance(pw, PiecewiseType):\n                piecewiseName = pw.name\n                piecewiseTypeName = type(pw).__name__\n                io_params = {}\n                for key, value in {\"input\": \"domain\", \"output\": \"range\"}.items():\n                    var = getattr(pw, f\"_{value}_var\")\n                    io_params[\n                        f\"{key}VarInfo\"\n                    ] = get_violation_of_infeasible_bounds_and_vartype_of_single_var(\n                        var, self.tol, violation_only=False\n                    )\n                    io_params[f\"{key}_points\"] = getattr(pw, f\"_{value}_pts\")\n                piecewiseBaseInfo = PiecewiseBaseInfo(\n                    piecewiseName=piecewiseName,\n                    piecewiseTypeName=piecewiseTypeName,\n                    **io_params,\n                )\n                piecewiseInfo = PiecewiseInfo.build(piecewiseBaseInfo, tol=self.tol)\n                if self.violation_only and not piecewiseInfo.has_violation:\n                    continue"
        },
        {
            "comment": "The code creates a ModelScanner object, scans for constraints, variables, and piecewise functions in the given model, and prints their information. It returns the modelInfo containing all the constraint, variable, and piecewise information.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/check_invalid_var_and_constraints.py\":479-501",
            "content": "                self.modelInfo.piecewises.append(piecewiseInfo)\n        return self.modelInfo.piecewises\n    def all(self):\n        self.constraint()\n        self.variable()\n        self.piecewise()\n        return self.modelInfo\nmodelScanner = ModelScanner(model)\nfor constrInfo in modelScanner.constraint():\n    rich.print(constrInfo)\nprint(\"=\" * 70)\nfor varInfo in modelScanner.variable():\n    rich.print(varInfo)\nprint(\"=\" * 70)\nfor piecewiseInfo in modelScanner.piecewise():\n    rich.print(piecewiseInfo)"
        }
    ]
}