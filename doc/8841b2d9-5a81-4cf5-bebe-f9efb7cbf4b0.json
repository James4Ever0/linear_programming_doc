{
    "summary": "This code uses NewType and namedtuple to ensure type usage, implements protocols for arithmetic operations and subscription access, includes a list length function mfunc, and a type-checking myfun.",
    "details": [
        {
            "comment": "This code snippet imports various typing modules and functions, performs type assertions and checks, defines a custom data type using NewType, and demonstrates usage of namedtuple and TypeVar. It also includes a function that returns a list of strings.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/makefile_ninja_pytest_incremental_test/type_check.py\":0-51",
            "content": "from typing import (\n    Any,\n    Generic,\n    Protocol,\n    TypeVar,\n    cast,\n    overload,\n    runtime_checkable,\n    NewType,\n)\nfrom typing_extensions import Never\nfrom collections import namedtuple\n# from typing import NamedTuple\nfrom typing_extensions import TypeGuard, Concatenate, assert_type, assert_never, SupportsIndex, reveal_type\nv = 1\nif type(v) == float:\n    assert False # will it raise error?\n# myList:SupportsIndex = dict()\n# concatenate is for decorators.\nval: int = 0\nassert_type(val, int)  # only for type checker.\nassert_type(val, str)\nif False:\n    assert_never(val)\n    # assert False\nmNewStr = NewType(\"mNewStr\", str)  # you can configure to ignore it.\n# mNewStr = NewType(\"mStr\", str) # ignore: [misc]\n# class Point(NamedTuple):\n#     a: int\n#     b: int\n# s = Point(a=1, b='')\n# s.b\nnt = namedtuple(\"nt\", \"a b c d\")\ninstNt = nt(a=1, b=2, c=1, d=2)\ninstNt.a\nfrom typing import List\ndef get_list() -> List[str]:\n    lst = [\"PyCon\"]\n    lst.append(2019)\n    return [str(x) for x in lst]\nT = TypeVar(\"T\")\na = []  # type: list"
        },
        {
            "comment": "This code defines protocol classes for arithmetic operations, subscription-based read and write access, and addition with length calculation. The purpose is to ensure that certain types can be used in specific contexts.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/makefile_ninja_pytest_incremental_test/type_check.py\":52-107",
            "content": "# a = 1 # type: list\n# how to make some traits of protocol to ensure that term will not implement?\n# class NotList(Protocol):\n#     def __getitem__(*args:Never,**kwargs:Never ) -> Never:...\n# numA:NotList = 1\nclass ArithmaticType(Protocol):\n    \"\"\"\n    Protocol of which able to do arithmatic operations.\n    \"\"\"\n    def __add__(self, v, /) -> Any:\n        ...\n    def __sub__(self, v, /) -> Any:\n        ...\n    def __mul__(self, v, /) -> Any:\n        ...\n    def __div__(self, v, /) -> Any:\n        ...\n    def __eq__(self, v, /) -> Any:\n        ...\n    def __ne__(self, v, /) -> Any:\n        ...\n    def __le__(self, v, /) -> Any:\n        ...\n    def __ge__(self, v, /) -> Any:\n        ...\nclass ReadableBySubscription(Protocol):\n    def __getitem__(self, index: int, /) -> Any:\n        ...\nclass Subscripable(ReadableBySubscription, Protocol):\n    def __setitem__(self, index: int, /) -> Any:\n        ...\n@runtime_checkable\nclass AddAndLength(Protocol):\n    def __add__(self, v, /) -> Any:\n        ...\n    def __len__(self) -> Any:\n        ..."
        },
        {
            "comment": "Function mfunc takes a list as input, calculates and returns the length of the list.\n\nType-checking function myfun converts int to float or vice versa based on input type.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/makefile_ninja_pytest_incremental_test/type_check.py\":110-174",
            "content": "def mfunc(param: AddAndLength) -> int:\n    print(\"You don't care what I do\")\n    length = len(param)\n    print(\"LEN:\", length)\n    return length\n# mfunc(123)\nmfunc([\"i am list\"])\n# a: AddAndLength\na = []\n# a = 123\n# skip pyomo library stub?\nfrom pyomo.environ import ConcreteModel, Var  # type: ignore\nmodel = ConcreteModel()\nmodel.x = cast(ReadableBySubscription, Var([0, 1, 2]))\n# model.x = cast(ReadableBySubscription, Var([0, 1, 2]))\nmodel.x[1]\nmodel.v = cast(ArithmaticType, Var())\nval = model.v * 1\n@overload\ndef myfun(val: int) -> float:\n    ...\n@overload\ndef myfun(val: float) -> int:\n    ...\ndef myfun(val):\n    if type(val) == float:\n        return int(val)\n    elif type(val) == int:\n        return float(val)\n    else:\n        raise Exception(\"Unacceptable type:\", type(val))\nval = myfun(1)\n# from runtype import Dispatch\n# dp = Dispatch()\n# @dp\n# def mf(a: int) -> float:\n#     print(\"RUNNING A\")\n#     return float(a)\n# @dp\n# def mf(a: float) -> int:\n#     print(\"RUNNING B\")\n#     return int(a)\n# unable to statically typecheck"
        }
    ]
}