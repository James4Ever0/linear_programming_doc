{
    "summary": "The code solves MILP problems using CPLEX, clones it for relaxation and compares results before recording in a dictionary and printing.",
    "details": [
        {
            "comment": "This code defines a function to solve a MILP problem by converting integer variables into reals and solving it as an LP. It also creates context managers for delegating the domain and bounds of integer variables to reals.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/solve_as_simplex.py\":0-38",
            "content": "# define a milp problem, convert integer variables into reals, solve it as lp\nfrom pyomo.environ import *\ndef getModelSolution(model: ConcreteModel):\n    solution = {}\n    for v in model.component_data_objects(ctype=Var, active=True, descend_into=True):\n        varName = v.name\n        val = value(v, exception=None)\n        if val is not None:\n            solution[varName] = val\n        else:\n            return None\n    return solution\ndomainDelegationTable = {\n    \"Integers\": Reals,\n    \"NonNegativeIntegers\": NonNegativeReals,\n    \"NonPositiveIntegers\": NonPositiveReals,\n    \"Boolean\": Reals,\n}\ndomainDelegationBoundsTable = {\"Boolean\": (0, 1)}\nfrom contextlib import contextmanager\n@contextmanager\ndef simplexDelegationContext(model: ConcreteModel):\n    \"\"\"\n    This context manager is used to delegate the domain and bounds of integer variables to the reals.\n    Delegation will be cancelled if exiting the manager.\n    \"\"\"\n    delegationRestoreTable = {}\n    for v in model.component_data_objects(Var, active=True):\n        varName = v.name"
        },
        {
            "comment": "The code is handling variable delegation within the model. It stores the original domain and bounds of variables before delegating them to specified domains, and restores these values after the delegation. This allows for temporary changes in variable domains without losing their original information.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/solve_as_simplex.py\":39-64",
            "content": "        domainName = v.domain.name\n        lb, ub = v.lb, v.ub\n        if domainName in domainDelegationTable.keys():\n            delegationRestoreTable[varName] = {\n                \"domain\": v.domain,\n                \"lb\": v.lb,\n                \"ub\": v.ub,\n            }\n            v.domain = domainDelegationTable[domainName]\n            if domainName in domainDelegationBoundsTable.keys():\n                domain_lb, domain_ub = domainDelegationBoundsTable[domainName]\n                if lb is None:\n                    lb = domain_lb\n                if ub is None:\n                    ub = domain_ub\n                v.setlb(max(lb, domain_lb))\n                v.setub(min(ub, domain_ub))\n    try:\n        yield\n    finally:\n        # recover model variable domain & bounds.\n        for v in model.component_data_objects(Var, active=True):\n            varName = v.name\n            if varName in delegationRestoreTable.keys():\n                restoreInfo = delegationRestoreTable[varName]\n                v.setlb(restoreInfo[\"lb\"])"
        },
        {
            "comment": "This code defines a model with variables and constraints, solves it using a CPLEX solver, clones the model, applies a relaxation transformation to the clone, solves both models again, and then tries to solve one of the models within a delegation context. It records the results for each case.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/solve_as_simplex.py\":65-106",
            "content": "                v.setub(restoreInfo[\"ub\"])\n                v.domain = restoreInfo[\"domain\"]\n        del delegationRestoreTable\nsolver = SolverFactory(\"cplex\")\ndef solver_solve(model):\n    ret = solver.solve(model, tee=True)\n    sol = getModelSolution(model)\n    return ret, sol\nmodel = ConcreteModel()\nmodel.a = Var(domain=Integers, bounds=(-0.5, 5.5))\nmodel.b = Var(domain=Boolean, bounds=(0.3, 1.1))  # feasible, if value(model.b) == 1\nmodel.o = Objective(expr=model.a + model.b, sense=maximize)\n# model.o = Objective(expr=model.a + model.b, sense=minimize)\nmodel.c = Constraint(expr=model.a >= model.b)\nret = solver_solve(model)\nmodel_clone = model.clone()\n# this works identically to our context manager.\nTransformationFactory(\"core.relax_integrality\").apply_to(model_clone)\n# working\nret_clone = solver_solve(model_clone)\nwith simplexDelegationContext(model):\n    # not working\n    ret_delegated = solver_solve(model)\nret_after = solver_solve(model)\nresults = {\n    \"ret\": ret,\n    \"ret_clone\": ret_clone,\n    \"ret_delegated\": ret_delegated,"
        },
        {
            "comment": "The code retrieves results from a dictionary, where keys are \"result name\" and values are tuples containing the result and solution. It then prints the result name, the rich formatted result using Rich library, and the solution.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/solve_as_simplex.py\":107-116",
            "content": "    \"ret_after\": ret_after,\n}\nimport rich\nfor res_name, res in results.items():\n    ret, sol = res\n    print(\"result name:\", res_name)\n    rich.print(res)\n    print(sol)"
        }
    ]
}