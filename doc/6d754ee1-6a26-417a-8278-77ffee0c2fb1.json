{
    "summary": "The function solves a list of IntegratedEnergySystem models, handles model conflicts and non-convex quadratic constraints. It returns the solution or \"UNABLE TO SOLVE\", creates save directory, plots results, logs information about detected constraints.",
    "details": [
        {
            "comment": "This function solves a list of IntegratedEnergySystem models and returns the solution. It sets a time limit of 1000 seconds for the model to solve, and if it's unable to solve within this time frame, it prints \"UNABLE TO SOLVE\". If a solution is found, it prints decision variables from the model and integrated energy system device counts.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/mini_data_log_utils.py\":0-39",
            "content": "from typing import List\nfrom docplex.mp.model import Model\nfrom integratedEnergySystemPrototypes import IntegratedEnergySystem, check_conflict\ndef solve_and_log(\n    systems: List[IntegratedEnergySystem], model: Model, simulation_name: str\n):\n    systems_annualized = [system.annualized for system in systems]\n    import functools\n    objective = functools.reduce(lambda a, b: a + b, systems_annualized)\n    model.minimize(objective)\n    # 1000\u79d2\u4ee5\u5185\u89e3\u51fa \u5426\u5219\u653e\u5f03\n    model.set_time_limit(time_limit=1000)\n    from typing import Union\n    from docplex.mp.solution import SolveSolution\n    # \u6a21\u578b\u6c42\u89e3\u8fd4\u56de\u503c \u53ef\u4e3a\u7a7a\n    solution_run1: Union[None, SolveSolution] = model.solve(\n        log_output=True\n    )  # output some solution.\n    from data_visualize_utils import (\n        printDecisionVariablesFromSolution,\n        printIntegratedEnergySystemDeviceCounts,\n        plotSingle,\n    )\n    if solution_run1 == None:\n        print(\"UNABLE TO SOLVE\")\n    else:\n        printDecisionVariablesFromSolution(model)\n        printIntegratedEnergySystemDeviceCounts(systems)"
        },
        {
            "comment": "The code collects all types of lists from different systems, creates a save directory if it doesn't exist, and then plots the data using the plotSingle function. It checks for specific system data names and port directions to determine what to plot.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/mini_data_log_utils.py\":41-60",
            "content": "        # collect all types of lists.\n        import os, shutil\n        save_directory = f\"{simulation_name}_figures\"\n        if os.path.isdir(save_directory):\n            shutil.rmtree(save_directory)\n        for system in systems:\n            system_name = system.device_name\n            system_data_name_list = dir(system)\n            for system_data_name in system_data_name_list:\n                system_data = system.__dict__.get(system_data_name, None)\n                for port_direction in ['input','output']:\n                    if system_data_name == f\"power_of_{port_direction}s\" and type(system_data) == dict:\n                        for key,value in system_data.items():\n                            if type(value) == list:\n                                plotSingle(value,title_content=f\"{system_name}_{system_data_name}_{key}\",save_directory=save_directory)\n                if type(system_data) == list:\n                    # then we plot this!\n                    plotSingle(\n                        system_data,"
        },
        {
            "comment": "This code checks if the model has conflicts or non-convex quadratic constraints. If a conflict is found, it breaks execution and prints a message. If non-convex quadratic constraints are detected, an exception is raised. It logs information about quadratic constraints present in the model for further examination.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/mini_data_log_utils.py\":61-90",
            "content": "                        title_content=f\"{system_name}_{system_data_name}\",\n                        save_directory=save_directory,\n                    )\n        print(\"TOTAL ANNUAL:\", objective.solution_value)\n        # breakpoint()\n        # 1007399999.999996 if charge[0] == discharge[0] == 0\n        # 992227727.2532595 if no init constrains on charge/discharge\ndef check_solve_and_log(systems: List[IntegratedEnergySystem], model: Model, simulation_name: str):\n    # before all the fuzz...\n    has_conflict = check_conflict(model)  # no conflict?\n    if has_conflict:\n        print(\"MODEL HAS CONFLICT.\")\n        breakpoint()\n    # non-convex quadratic constraint?\n    # please show me!\n    has_quad_cons = False\n    print()\n    print(\"#\"*30)\n    for quadratic_constraint in model.iter_quadratic_constraints():\n        print(\"QUAD CONS?\",quadratic_constraint)\n        if not has_quad_cons:\n            has_quad_cons=True\n    print(\"#\"*30)\n    print()\n    if has_quad_cons:\n        raise Exception(\"You have quadratic constraints in model.\")"
        },
        {
            "comment": "This function appears to take in a list of systems, a model, and a simulation name as parameters. It then calls the solve() method on the model with the given systems, followed by logging the results using the provided simulation_name.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/mini_data_log_utils.py\":92-92",
            "content": "    solve_and_log(systems,model,simulation_name)"
        }
    ]
}