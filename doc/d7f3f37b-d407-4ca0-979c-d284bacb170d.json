{
    "summary": "The code creates a microgrid system, handles configurations and special cases, updates connectivity matrices, manages device parameters, generates and visualizes a device-connectivity graph.",
    "details": [
        {
            "comment": "Creates an IES topology type system with options to plot and save the result. The code uses a version of 2.0 and generates JSON files for device port type mapping, connectivity matrix, and all types structured. It also includes the ability to only save the plot without displaying it, and a Makefile-like structure for specifying inputs and outputs.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_system_v2.py\":0-46",
            "content": "from log_utils import logger_print\n__doc__ = \"\"\"Creating IES topology type system.\nUsage:\n    type_system_v2.py [(-p | --plot_only) | --version]\nOptions:\n    -p --plot_only        Only save the plot picture without showing it.\n    --version             Showing version.\n\"\"\"\nimport rich\ndef generate_filename(hyphen_saved_name, prefix):\n    # banner = hyphen_saved_name.strip().replace(\"_\", \" \").upper().strip()\n    filepath = f\"{prefix}_{hyphen_saved_name.strip()}.json\"\n    return filepath\nSAVE_PREFIX = \"microgrid_v2\"\nfigure_path = \"type_system.png\"\nMAKEFILE = dict(\n    inputs=[],\n    outputs=[\n        figure_path,\n        j1 := generate_filename(\"device_port_type_mapping\", SAVE_PREFIX),\n        j2 := generate_filename(\"connectivity_matrix\", SAVE_PREFIX),\n        j3 := generate_filename(\"all_types_structured\", SAVE_PREFIX),\n    ],\n    args=[\"-p\"],\n)\n# \u98ce\u529b\u3001\u5149\u4f0f\u3001\u67f4\u6cb9\u673a \u589e\u52a0\u4e0d\u53ef\u8fde\u63a5\u7684\u7ebf \u5220\u9664\u53d8\u6d41\u5668\u8282\u70b9\u7684\u4e0d\u53ef\u8fde\u63a5\u7ebf\n# \u589e\u52a0\u53d8\u6d41\u5668\u548c\u4e0d\u53ef\u8fde\u63a5\u6bcd\u7ebf\u7684\u8fde\u63a5\nimport traceback\nimport docopt\nfrom docopt import docopt\n# logger_print(type(__doc__))\n# breakpoint()\noptions = docopt(__doc__, version=\"2.0\")"
        },
        {
            "comment": "This code defines a function check_valid_type_base_name() to validate type base names and a class PrefixSuffixBase() to prefix/suffix type names. The function removes spaces and asserts certain conditions on the type base name, while the class applies prefix or suffix based on user-defined input.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_system_v2.py\":47-80",
            "content": "# from turtle import backward\n# import pandas\nPLOT_ONLY = options.get(\"--plot_only\", False)\n# breakpoint()\ndef check_valid_type_base_name(type_base_name):\n    type_base_name = type_base_name.replace(\" \", \"\").strip()\n    try:\n        assert not type_base_name.startswith(\"\u53ef\u8fde\u63a5\")\n        assert not type_base_name.startswith(\"\u4e0d\u53ef\u8fde\u63a5\")\n        assert \"\u8f93\" not in type_base_name\n        assert \"\u51fa\" not in type_base_name\n        assert \"\u5165\" not in type_base_name\n    except:\n        traceback.print_exc()\n        raise Exception(\"Invalid type base name:\", type_base_name)\n    return type_base_name.strip()\nclass PrefixSuffixBase:\n    def __init__(self, prefix_or_suffix, prefix=False):\n        self.prefix_or_suffix = prefix_or_suffix.strip()\n        self.is_prefix = prefix\n    def __call__(self, name):\n        if not self.is_prefix:\n            name = check_valid_type_base_name(name)\n        else:\n            name = name.strip()\n        if self.is_prefix:\n            return f\"{self.prefix_or_suffix}{name}\"\n        else:\n            return f\"{name}{self.prefix_or_suffix}\""
        },
        {
            "comment": "This code defines two classes, `Prefix` and `Suffix`, which inherit from the base class `PrefixSuffixBase`. The `check` function is used to determine if a given name with prefix or suffix follows certain rules. It checks if the prefix or suffix is present in the input name and counts the number of occurrences. The code also mentions that components cannot connect to themselves, and connections between adders should be treated as special types. Additionally, adders should not connect to components, and component port properties are reset to empty if connected to an adder. Lastly, the code distinguishes between device ports and connection lines, with ports being points and connection lines being edges.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_system_v2.py\":82-123",
            "content": "    def check(self, name_with_prefix_or_suffix):\n        l = len(self.prefix_or_suffix)\n        if self.is_prefix:\n            name = name_with_prefix_or_suffix.strip()[l:]\n        else:\n            name = name_with_prefix_or_suffix.strip()[:-l]\n        sl = set(list(self.prefix_or_suffix))\n        # sl = set(list(name_with_prefix_or_suffix))\n        sld = {e: self.prefix_or_suffix.count(e) for e in sl}\n        nwd = {e: name_with_prefix_or_suffix.count(e) for e in sl}\n        nd = {e: name.count(e) for e in sl}\n        zd = {e: 0 for e in sl}\n        s1 = nd == zd\n        s2 = sld == nwd\n        # logger_print(s1, s2)\n        # breakpoint()\n        return s1 and s2\nclass Prefix(PrefixSuffixBase):\n    def __init__(self, prefix):\n        super().__init__(prefix, prefix=True)\nclass Suffix(PrefixSuffixBase):\n    def __init__(self, suffix):\n        super().__init__(suffix, prefix=False)\n# s0 = Prefix(\"s\")\n# d = \"s1000\"\n# s0.check(d)\n# breakpoint()\n# \u5143\u4ef6\u4e0d\u53ef\u548c\u81ea\u5df1\u76f8\u8fde \u52a0\u6cd5\u5668\u4e4b\u95f4\u5982\u679c\u76f8\u8fde \u8fde\u7ebf\u4e3a\u7279\u6b8a\u7c7b\u578b \u5408\u5e76\u4e3a\u4e00\u4e2a\u52a0\u6cd5\u5668\u4e4b\u540e\u505a\u5408\u7406\u6027\u5224\u65ad\n# \u52a0\u6cd5\u5668\u4e0d\u8fde\u63a5\u5143\u4ef6 \u7aef\u53e3\u5c5e\u6027\u91cd\u7f6e\u4e3a\u7a7a\n# \u533a\u5206\u8bbe\u5907\u7aef\u53e3\u548c\u8fde\u63a5\u7ebf \u7aef\u53e3\u662f\u70b9 \u8fde\u63a5\u7ebf\u662f\u8fb9"
        },
        {
            "comment": "This code includes various dictionary structures that define the connections between different components in a microgrid system. It also includes functions for generating unique hash values and reversing dictionaries. The code uses UUIDs to create random but unique hashes for non-connectable lines, which can be useful for identifying specific elements during debugging or analysis. The primary purpose of this code is to define the connections and types of different components in a microgrid system, such as sources, loads, storage, and switches.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_system_v2.py\":124-189",
            "content": "# \u7ed9\u6240\u6709\u4e0d\u53ef\u8fde\u63a5\u7ebf\u589e\u52a0\u968f\u673ahash\u503c \u65b9\u4fbf\u89c2\u5bdf\nimport uuid\nhash_set = set()\ndef get_uniq_hash(hash_length=3):\n    while True:\n        mhash = str(uuid.uuid4()).split(\"-\")[0][:hash_length]\n        if mhash not in hash_set:\n            hash_set.add(mhash)\n            return mhash\noutput_path = \"microgrid_type_system.xlsx\"\nsheet1_name = \"\u7c7b\u578b\u8fde\u63a5\u77e9\u9635\"\nsheet2_name = \"\u8bbe\u5907\u7aef\u53e3\u7c7b\u578b\u8868\"\n# \u6bcd\u7ebf\u8f93\u5165 = 0\n# \u6bcd\u7ebf\u8f93\u51fa = 0\n# \u50a8\u80fd\u7aef\u8f93\u5165\u8f93\u51fa = 1\n# \u53cc\u5411\u53d8\u6d41\u5668\u8f93\u5165\u8f93\u51fa = 1\n# \u53ef\u8fde\u63a5\u6bcd\u7ebf = 2\n# \u4e0d\u53ef\u8fde\u63a5\u6bcd\u7ebf = 2\n# \u53ef\u8fde\u63a5\u4f9b\u7535\u7aef\u6bcd\u7ebf = 3\n# \u4e0d\u53ef\u8fde\u63a5\u4f9b\u7535\u7aef\u6bcd\u7ebf = 3\n# \u53ef\u8fde\u63a5\u50a8\u80fd\u7aef\u6bcd\u7ebf = 4\n# \u4e0d\u53ef\u8fde\u63a5\u50a8\u80fd\u7aef\u6bcd\u7ebf = 4\n# \u4f9b\u7535\u7aef\u8f93\u51fa,\u53d8\u6d41\u5668\u8f93\u5165 = 0\ndef revert_dict(mdict: dict):\n    result = {e: k for k, v in mdict.items() for e in v}\n    return result\nInput = Suffix(\"\u8f93\u5165\")\nOutput = Suffix(\"\u8f93\u51fa\")\nIO = Suffix(\"\u8f93\u5165\u8f93\u51fa\")\nsource_coax_triplets = {  # Input, Output, ConnectionBaseName\n    \"\u7535\": [(\"\u53d8\u6d41\u5668\", \"\u4f9b\u7535\u7aef\", \"\u4f9b\u7535\u7aef\u6bcd\u7ebf\")],\n}\nsource_and_load_coax_triplets = {\n    \"\u7535\": [(\"\u7535\u6bcd\u7ebf\", \"\u7535\u6bcd\u7ebf\", \"\u7535\u6bcd\u7ebf\")],\n}\nload_coax_triplets = {  # Input, Output, ConnectionBaseName\n    \"\u7535\": [\n        (\"\u8d1f\u8377\u7535\", \"\u53d8\u538b\u5668\", \"\u8d1f\u8377\u7535\u6bcd\u7ebf\"),\n    ],\n    \"\u67f4\u6cb9\": [\n        (\"\u67f4\u6cb9\", \"\u67f4\u6cb9\", \"\u67f4\u6cb9\u6bcd\u7ebf\"),\n    ],\n}\n# IO_1, IO_2, ConnectionBaseName\nio_storage_coax_triplets = {\"\u7535\": [(\"\u7535\u50a8\u80fd\u7aef\", \"\u53cc\u5411\u53d8\u6d41\u5668\u50a8\u80fd\u7aef\", \"\u7535\u50a8\u80fd\u7aef\u6bcd\u7ebf\")]}"
        },
        {
            "comment": "Function `triplets_with_supertype` generates all triplet combinations with a supertype from the given triplet map.\nFunction `get_types` returns either 'types' or 'wire\\_types' based on the boolean input 'is\\_wire'.\nFunction `get_other_sets` retrieves other sets for the given supertype from the specified types dictionary.\nFunction `add_to_types` adds a new type to the dictionary with the given supertype and typename.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_system_v2.py\":191-230",
            "content": "#\nio_to_wire = {\"\u7535\": [(\"\u53cc\u5411\u53d8\u6d41\u5668\u7ebf\u8def\u7aef\", \"\u7535\u6bcd\u7ebf\")]}\ntypes = {}  # {str: set()}\nwire_types = {}\ntypes_connectivity_matrix = {}  # {frozenset([start, end]): generated_type}\ndef triplets_with_supertype(triplet_map, length=3):\n    for supertype, triplet_list in triplet_map.items():\n        for triplet in triplet_list:\n            try:\n                assert len(triplet) == length\n            except:\n                logger_print()\n                logger_print(\"ERROR!\")\n                logger_print()\n                logger_print(triplet_map)\n                raise Exception(\n                    f\"Error when unpacking triplet map with length {length}.\",\n                )\n            yield (*triplet, supertype)\ndef get_types(is_wire):\n    if is_wire:\n        return wire_types\n    else:\n        return types\ndef get_other_sets(supertype, is_wire=False):\n    mtypes = get_types(is_wire)\n    other_sets = set([e for k in mtypes.keys() if k != supertype for e in types[k]])\n    return other_sets\ndef add_to_types(supertype, typename, is_wire=False):"
        },
        {
            "comment": "Code is retrieving type information for either wire or non-wire components and handling potential duplicates by raising exceptions. It also defines prefixes for connectable, mergeable, unconnectable types and handles input/output (io) to adder connections.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_system_v2.py\":231-261",
            "content": "    mtypes = get_types(is_wire)\n    if mtypes.get(supertype, None) is None:\n        mtypes[supertype] = set()\n    if is_wire:\n        other_sets = set([e for k, v in types.items() for e in v])\n        wire_other_sets = get_other_sets(supertype, is_wire=is_wire)\n    else:\n        other_sets = get_other_sets(supertype)\n        wire_other_sets = set([e for k, v in wire_types.items() for e in v])\n    if typename not in other_sets:\n        if typename not in wire_other_sets:\n            mtypes[supertype].add(typename)\n        else:\n            raise Exception(\n                f\"{'Wire ' if is_wire else ''}Type {typename} in category {supertype} appeared to be duplicated with wire types.\"\n            )\n    else:\n        raise Exception(\n            f\"{'Wire ' if is_wire else ''}Type {typename} in category {supertype} appeared to be duplicated with device types.\"\n        )\nConnectable = Prefix(\"\u53ef\u8fde\u63a5\")\nMergeable = Prefix(\"\u53ef\u5408\u5e76\")\nUnconnectable = Prefix(\"\u4e0d\u53ef\u8fde\u63a5\")\n# handle io to adder stuff.\nfor io, wire_name, supertype in triplets_with_supertype(io_to_wire, length=2):"
        },
        {
            "comment": "This code seems to be involved in handling microgrid triplets with different types of configurations, including IO (input/output) and wire connections. It uses transform_triplets function to iterate through the triplets with specific supertype, and add them to the types_connectivity_matrix. The triplets_config list defines various types of triplet configurations, including source_coax_triplets, load_coax_triplets, source_and_load_coax_triplets, and io_storage_coax_triplets. It appears to be related to managing microgrid connectivity in a complex system with multiple components and connections.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_system_v2.py\":262-294",
            "content": "    start = IO(io)\n    end = Connectable(wire_name)\n    created = Unconnectable(IO(wire_name))\n    add_to_types(supertype, start)\n    add_to_types(supertype, end, is_wire=True)\n    add_to_types(supertype, created, is_wire=True)\n    types_connectivity_matrix.update({frozenset([start, end]): created})\n# a = [(e, True) for e in triplets_with_supertype(io_coax_triplets)]\n# logger_print(a)\n# breakpoint()\ndef transform_triplets(triplets, is_io, forward, backward):\n    return [(e, is_io, forward, backward) for e in triplets_with_supertype(triplets)]\n# forward&backward for compatibility issues. just leave it be.\nfrom functools import reduce\ntriplets_config = [  # triplets, is_io, forward, backward\n    (source_coax_triplets, False, False, True),\n    (load_coax_triplets, False, True, False),\n    (source_and_load_coax_triplets, False, True, True),\n    #############################################\n    (io_storage_coax_triplets, True, True, False),\n]\nfor (i, o, wire_name, supertype), is_io, forward, backward in reduce(\n    lambda x, y: x + y,"
        },
        {
            "comment": "This code defines a set of connectable types for wires and adds them to the \"types\" dictionary. It creates different wire names based on their connectability and assigns them to specific variables. The code also checks if a supertype exists, adds it to the \"types\" dictionary, and handles special cases involving energy ends.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_system_v2.py\":295-327",
            "content": "    [transform_triplets(*c) for c in triplets_config],\n):\n    if is_io:\n        start = IO(i)\n        end = IO(o)\n    else:\n        start = Input(i)  # input <- adder_output <- adder\n        end = Output(o)  # output -> adder_input -> adder\n    # logger_print(i,o, start, end,wire_name)\n    # breakpoint()\n    mWireNames = (\n        connectable_wire_name,\n        unconnectable_wire_name,\n        unconnectable_input_wire_name,\n        unconnectable_output_wire_name,\n        unconnectable_io_wire_name,\n        mergeable_wire_name,\n    ) = (\n        Connectable(wire_name),\n        Unconnectable(wire_name),\n        Unconnectable(Input(wire_name)),\n        Unconnectable(Output(wire_name)),\n        Unconnectable(IO(wire_name)),\n        Mergeable(wire_name),\n    )\n    # if types.get(supertype, None) is None:\n    #     types[supertype] = set()\n    # other_sets = set([e for k in types.keys() if k!=supertype for e in types[k]])\n    # if \"\u50a8\u80fd\u7aef\" in start:\n    #     breakpoint()\n    add_to_types(supertype, start)\n    add_to_types(supertype, end)"
        },
        {
            "comment": "The code iterates over a list of wire names and adds them as wires to the type system. It then updates a connectivity matrix based on the specific wire connections, including unconnectable, connectable, and mergeable wires in various orientations (forward or backward). The code also handles updating the connectivity matrix with unconnectable input/output wires, and connectable wires.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_system_v2.py\":329-356",
            "content": "    for wireName in mWireNames:\n        add_to_types(supertype, wireName, is_wire=True)\n    # add_to_types(supertype, connectable_wire_name, is_wire=True)\n    # add_to_types(supertype, unconnectable_wire_name, is_wire=True)\n    # add_to_types(supertype, unconnectable_input_wire_name, is_wire=True)\n    # add_to_types(supertype, unconnectable_output_wire_name, is_wire=True)\n    # add_to_types(supertype, unconnectable_wire_name, is_wire=True)\n    types_connectivity_matrix.update({frozenset([start, end]): unconnectable_wire_name})\n    types_connectivity_matrix.update(\n        {frozenset([connectable_wire_name, connectable_wire_name]): mergeable_wire_name}\n    )\n    # if forward:  # original\n    types_connectivity_matrix.update(\n        {frozenset([start, connectable_wire_name]): unconnectable_output_wire_name}\n    )\n    # if backward:\n    types_connectivity_matrix.update(\n        {frozenset([end, connectable_wire_name]): unconnectable_input_wire_name}\n    )\n# logger_print(types)\n# {\n#     '\u6bcd\u7ebf\u8f93\u5165',\n#     '\u4e0d\u53ef\u8fde\u63a5\u6bcd\u7ebf',"
        },
        {
            "comment": "The code is reading a JSON file, extracting keys, and then opening a CSV file. It counts the number of comma-separated values in each line of the CSV and adjusts them to have the same number as the longest line. The purpose seems to be related to microgrid device parameters, possibly for interface data or configuration.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_system_v2.py\":357-398",
            "content": "#     '\u53ef\u8fde\u63a5\u50a8\u80fd\u7aef\u6bcd\u7ebf',\n#     '\u4e0d\u53ef\u8fde\u63a5\u4f9b\u7535\u7aef\u6bcd\u7ebf',\n#     '\u6bcd\u7ebf\u8f93\u51fa',\n#     '\u4f9b\u7535\u7aef\u8f93\u51fa',\n#     '\u4e0d\u53ef\u8fde\u63a5\u50a8\u80fd\u7aef\u6bcd\u7ebf',\n#     '\u53cc\u5411\u53d8\u6d41\u5668\u8f93\u5165\u8f93\u51fa',\n#     '\u53ef\u8fde\u63a5\u4f9b\u7535\u7aef\u6bcd\u7ebf',\n#     '\u50a8\u80fd\u7aef\u8f93\u5165\u8f93\u51fa',\n#     '\u53ef\u8fde\u63a5\u6bcd\u7ebf',\n#     '\u53d8\u6d41\u5668\u8f93\u5165'\n# }\nimport json\n# keys = []\n# with open(\"microgrid_device_params_intermediate.json\",'r') as f:\n#     data = json.load(f)\n#     for k,v in data.items():\n#         for k0, v0 in v.items():\n#             keys.append(k0)\n# logger_print(keys)\ncsv_path = \"\u8bbe\u5907\u63a5\u53e3-\u79bb\u7f51\u578b\u5fae\u7535\u7f51.csv\"\nfrom csv_utils import fix_csv_and_return_dataframe\nport_df = fix_csv_and_return_dataframe(csv_path)\n# lines = []\n# line_sep_count_list = []\n# with open(csv_path, \"r\") as f:\n#     for line in f.readlines():\n#         line_sep_count = line.count(\",\")\n#         if line_sep_count == 0:\n#             continue\n#         lines.append(line)\n#         line_sep_count_list.append(line_sep_count)\n# line_sep_count_max = max(line_sep_count_list)\n# for index, line_sep_count in enumerate(line_sep_count_list):\n#     lines[index] = lines[index].strip() + \",\" * (line_sep_count_max - line_sep_count)\n# with open(csv_path, \"w+\") as f:"
        },
        {
            "comment": "This code defines dictionaries for energy, load, and storage devices with their single port types. It then creates a device_with_single_port_to_port_type dictionary combining input and output device types.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_system_v2.py\":399-443",
            "content": "#     for line in lines:\n#         f.write(line + \"\\n\")\n# port_df = pandas.read_csv(csv_path, header=None, on_bad_lines=\"warn\")\n# logger_print(port_df)\nimport numpy\nmycat = None\ndevice_port_dict = {}\nmydevice = None\ncontent_split = True\n# \u80fd\u6e90\u7aef\noutput_device_with_single_port_to_port_type = revert_dict(\n    {\n        \"\u67f4\u6cb9\": [\"\u67f4\u6cb9\"],\n        \"\u4f9b\u7535\u7aef\": [\"\u5149\u4f0f\u53d1\u7535\", \"\u98ce\u529b\u53d1\u7535\", \"\u67f4\u6cb9\u53d1\u7535-\u7535\u63a5\u53e3\"],\n        \"\u7535\u6bcd\u7ebf\": [\"\u53d8\u6d41\u5668-\u7535\u8f93\u51fa\", \"\u4f20\u8f93\u7ebf-\u7535\u8f93\u51fa\"],\n        \"\u53d8\u538b\u5668\": [\"\u53d8\u538b\u5668-\u7535\u8f93\u51fa\"],\n    }\n)\n# \u8d1f\u8377\u7aef\ninput_device_with_single_port_to_port_type = revert_dict(\n    {\n        \"\u8d1f\u8377\u7535\": [\"\u7535\u8d1f\u8377\"],\n        \"\u67f4\u6cb9\": [\"\u67f4\u6cb9\u53d1\u7535-\u71c3\u6599\u63a5\u53e3\"],\n        \"\u7535\u6bcd\u7ebf\": [\"\u53d8\u538b\u5668-\u7535\u8f93\u5165\", \"\u4f20\u8f93\u7ebf-\u7535\u8f93\u5165\"],\n        \"\u53d8\u6d41\u5668\": [\"\u53d8\u6d41\u5668-\u7535\u8f93\u5165\"],\n    }\n)\n# \u50a8\u80fd\u7aef\nio_device_with_single_port_to_port_type = revert_dict(\n    {\"\u7535\u50a8\u80fd\u7aef\": [\"\u9502\u7535\u6c60\"], \"\u53cc\u5411\u53d8\u6d41\u5668\u50a8\u80fd\u7aef\": [\"\u53cc\u5411\u53d8\u6d41\u5668-\u50a8\u80fd\u7aef\"], \"\u53cc\u5411\u53d8\u6d41\u5668\u7ebf\u8def\u7aef\": [\"\u53cc\u5411\u53d8\u6d41\u5668-\u7ebf\u8def\u7aef\"]}\n)\ndevice_with_single_port_to_port_type = {\n    k: Input(v) for k, v in input_device_with_single_port_to_port_type.items()\n}\ndevice_with_single_port_to_port_type.update(\n    {k: Output(v) for k, v in output_device_with_single_port_to_port_type.items()}"
        },
        {
            "comment": "Updates device_with_single_port_to_port_type, maps types to devices in a set and dictionary, prints logger for the updated type to port mapping, iterates through each row of port_df, handles NaN or None values, assigns categories and content from rows, checks for existing data and appends ports accordingly, gets device type and ID, and updates device_with_single_port_to_port_type with new information.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_system_v2.py\":444-477",
            "content": ")\ndevice_with_single_port_to_port_type.update(\n    {k: IO(v) for k, v in io_device_with_single_port_to_port_type.items()}\n)\nmapped_types = set()\ntype_to_device_LUT = {}\nlogger_print(device_with_single_port_to_port_type)\nfor index, row in port_df.iterrows():\n    # logger_print(row.tolist())\n    # logger_print(row.tolist())\n    cat, content = row.tolist()[:2]\n    logger_print([cat, content])\n    if not (cat is numpy.nan or cat is None):\n        mycat = cat\n        device_port_dict[mycat] = {}  # init\n    if mycat:\n        if content is numpy.nan or content is None:\n            content_split = True\n        elif content_split:\n            content_split = False\n            mydevice = content.replace(\"\uff08\", \"(\").split(\"(\")[0]\n            device_port_dict[mycat][mydevice] = {}\n        else:\n            # append port?\n            port_type = device_with_single_port_to_port_type.get(mydevice, None)\n            if port_type:\n                device_with_single_port_to_port_type[mydevice] = None\n            else:\n                port_id = f\"{mydevice}-{content}\""
        },
        {
            "comment": "This code checks the port type for a given device and content, adds it to a dictionary if found, and raises an exception if not found. It also updates a LUT with the corresponding device information. The print_with_banner function logs a message and saves it to a file.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_system_v2.py\":478-501",
            "content": "                port_type = device_with_single_port_to_port_type.get(port_id, None)\n                if port_type:\n                    device_with_single_port_to_port_type[port_id] = None\n            if port_type is not None:\n                device_port_dict[mycat][mydevice][content] = port_type\n                mapped_types.add(port_type)\n                type_to_device_LUT[port_type] = type_to_device_LUT.get(\n                    port_type, []\n                ) + [f\"{mydevice}-{content}\"]\n            else:\n                # logger_print(device_port_dict)\n                # breakpoint()\n                raise Exception(\n                    \"No port type definition for:\", (mycat, mydevice, content)\n                )\ndef print_with_banner(content, filepath):\n    # def print_with_banner(content, hyphen_saved_name, prefix):\n    # banner = hyphen_saved_name.strip().replace(\"_\", \" \").upper().strip()\n    logger_print(content)\n    # filepath = f\"{prefix}_{hyphen_saved_name.strip()}.json\"\n    logger_print(\"SAVING TO:\", filepath)"
        },
        {
            "comment": "This code segment is responsible for:\n1. Printing a banner for a file path and writing the content to the file.\n2. Defining a function, `exp_froz`, which takes a frozen set and converts it into a list.\n3. Generating a dictionary, `types_connectivity_matrix_for_json`, with elements from `types_connectivity_matrix` reorganized for JSON output.\n4. Printing a banner for `types_connectivity_matrix_for_json`.\n5. Converting the `wire_types` dictionary into a list of values per key, stored in `wire_types_json`.\n6. Creating a structured representation of all types under the '\u8bbe\u5907' category in `all_types_structured`.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_system_v2.py\":502-534",
            "content": "    logger_print(f\"=========[{filepath}]=========\")\n    with open(filepath, \"w+\") as f:\n        str_content = json.dumps(content, indent=4, ensure_ascii=False)\n        f.write(str_content)\n# logger_print(\"=========[DEVICE PORT TYPE MAPPING]=========\")\nprint_with_banner(device_port_dict, j1)\n# logger_print(\"=========[CONNECTIVITY MATRIX]=========\")\nlogger_print(types_connectivity_matrix)\ndef exp_froz(frz):\n    lf = list(frz)\n    if len(lf) == 1:\n        lf = lf + lf\n    return lf\ntypes_connectivity_matrix_for_json = {\n    \"{}_{}\".format(*exp_froz(k)): v for k, v in types_connectivity_matrix.items()\n}\nprint_with_banner(types_connectivity_matrix_for_json, j2)  # must convert this one.\n# logger_print(\"=========[DEVICE PORT TYPES]=========\")\n# print_with_banner(types,'device_port_types',\"microgrid\")\n# logger_print(\"=========[ALL TYPES STRUCTURED]=========\")\nwire_types_json = {k: list(v) for k, v in wire_types.items()}\n# logger_print(wire_types_json)\n# breakpoint()\nall_types_structured = {\n    \"\u8bbe\u5907\": {k: list(v) for k, v in types.items()},"
        },
        {
            "comment": "This code is checking the types of devices and connections in a microgrid system. It filters them based on specific criteria and creates a dictionary for each type (mother lines, connection lines, merging lines). The code then checks if there are any unique types between the mapped and device types and raises an exception if they are not equal. Finally, it constructs a graph to check reachability of all types in the system.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_system_v2.py\":535-568",
            "content": "    # \u52a0\u6cd5\u5668\u6539\u4e3a\u6bcd\u7ebf\n    \"\u6bcd\u7ebf\": {k: [e for e in v if Connectable.check(e)] for k, v in wire_types.items()},\n    \"\u8fde\u63a5\u7ebf\": {k: [e for e in v if Unconnectable.check(e)] for k, v in wire_types.items()},\n    \"\u5408\u5e76\u7ebf\": {k: [e for e in v if Mergeable.check(e)] for k, v in wire_types.items()},\n}\n# all_types_structured = {\"\u8bbe\u5907\":{k: list(v) for k,v in types.items()},\"\u8fde\u63a5\u7ebf\":{k:list(v) for k,v in wire_types.items()}}\nprint_with_banner(all_types_structured, j3)\nmtypes = set([e for k, v in types.items() for e in v])\ndiff_1 = mapped_types.difference(mtypes)\ndiff_2 = mtypes.difference(mapped_types)\nif not (diff_1 == set() and diff_2 == set()):\n    logger_print(\"MAPPED TYPES UNIQ:\", diff_1)\n    logger_print(\"DEVICE TYPES UNIQ:\", diff_2)\n    raise Exception(\"Mapped types does not equal to existing device types\")\n# now the final: validity check!\n# reachable?\nimport networkx\nG = networkx.Graph()\nall_types = mtypes.union(set([e for k, v in wire_types.items() for e in v]))\n# for node_name in all_types:\n#     G.add_node(node_name)\nimport copy\ndef alter_type_name(type_name):"
        },
        {
            "comment": "This code appears to be involved in the manipulation and addition of nodes and edges to a graph (G) based on a types_connectivity_matrix, potentially for network connectivity analysis. It modifies node names by altering type names if they meet specific conditions, and logs node and neighbor information. The code also utilizes the get_uniq_hash() function and possibly a logger_print function for logging purposes.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_system_v2.py\":569-607",
            "content": "    logger_print(\"ALTER TYPE NAME:\", type_name)\n    if type_name.startswith(\"\u4e0d\u53ef\u8fde\u63a5\"):\n        if type_name.endswith(\"]\"):\n            type_name = type_name[:-4]\n        result = copy.copy(type_name) + f\"[{get_uniq_hash()}]\"\n        # breakpoint()\n    else:\n        result = type_name\n    # logger_print(\"RESULT?\", result)\n    # breakpoint()\n    return result\ndef is_wire(name):\n    return Connectable.check(name) or Unconnectable.check(name)\nfor fzset, wire_name in types_connectivity_matrix.items():\n    # logger_print(fzset, wire_name)\n    start, end = exp_froz(fzset)\n    start = alter_type_name(start)\n    end = alter_type_name(end)\n    wire_name = alter_type_name(wire_name)\n    G.add_edge(start, wire_name)\n    G.add_edge(wire_name, end)\n    # G.add_edge(start, end)\n# logger_print(G.nodes)\nfor node_name in G.nodes:\n    neighbors = G.neighbors(node_name)\n    logger_print(\"NODE:\", node_name)\n    logger_print(\"    NEIGHBOR:\", [n for n in neighbors])\n# import matplotlib.font_manager as fm\n# font_path = \"/Volumes/CaseSensi"
        },
        {
            "comment": "The code defines a function `plot_graph` that takes a graph G, figure path, width, and height as input. It creates a figure with specified size and draws the graph using NetworkX's draw_kamada_kawai function with custom options for node color, font color, etc. If plot_only is False, it saves the figure to the given filepath and displays it. The code also defines a function `lookup_type_to_device` that returns a list of device names for a given type name based on the type_to_device_LUT dictionary.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_system_v2.py\":607-644",
            "content": "tive/pyjom/tests/render_and_recognize_long_text_to_filter_unwanted_characters/get_and_merge_fonts/GoNotoCurrent.ttf\"\n# font_path = \"/Users/jamesbrown/Desktop/works/jubilant-adventure/GoNotoCurrent.ttf\"\n# WRYH = fm.FontProperties(fname = '/Users/liuhuanshuo/Desktop/\u53ef\u89c6\u5316\u56fe\u9274/font/WeiRuanYaHei-1.ttf')\nimport matplotlib\nmatplotlib.rcParams[\"font.sans-serif\"] = [\"Songti SC\"]\nimport matplotlib.pyplot as plt\ndef plot_graph(G, figure_path: str, width=20, height=30, plot_only=False):\n    plt.figure(figsize=(width, height))\n    draw_options = {\n        \"node_color\": \"yellow\",\n        \"node_size\": 0,\n        \"font_color\": \"red\",\n        \"edge_color\": \"blue\",\n        # \"fontproperties\":WRYH\n    }\n    networkx.draw_kamada_kawai(G, with_labels=True, font_weight=\"bold\", **draw_options)\n    logger_print(\"Saving graph figure to:\", figure_path)\n    plt.savefig(figure_path)\n    if not plot_only:\n        plt.show()\nplot_graph(G, figure_path, plot_only=PLOT_ONLY)\nG1 = networkx.Graph()\ndef lookup_type_to_device(type_name):\n    result = [e.split(\"-\") for e in type_to_device_LUT.get(type_name, [])]"
        },
        {
            "comment": "The code is generating a graph using a connectivity matrix and plotting it. It iterates through the types_connectivity_matrix, identifies start and end devices based on type names, and adds edges to the graph G1 between these devices and the wire name. The plot_graph function then generates a visual representation of this graph and saves it as \"device_connectivity_matrix.png\".",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_system_v2.py\":645-672",
            "content": "    if result == []:\n        return [(None, type_name)]\n    return result\nfor fzset, wire_name in types_connectivity_matrix.items():\n    # logger_print(fzset, wire_name)\n    start, end = exp_froz(fzset)\n    for ds, ds_port in lookup_type_to_device(start):\n        for de, de_port in lookup_type_to_device(end):\n            if ds:\n                mstart = ds\n            else:\n                mstart = ds_port\n            if de:\n                mend = de\n            else:\n                mend = de_port\n            mstart = alter_type_name(mstart)\n            mend = alter_type_name(mend)\n            wire_name = alter_type_name(wire_name)\n            G1.add_edge(mstart, wire_name)\n            G1.add_edge(mend, wire_name)\nfigure_path = \"device_connectivity_matrix.png\"\nplot_graph(G1, figure_path, plot_only=PLOT_ONLY)"
        }
    ]
}