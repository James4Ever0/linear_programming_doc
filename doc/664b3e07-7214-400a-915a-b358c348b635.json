{
    "summary": "The code imports modules, defines constants and paths for generating test code using Jinja templates. It reads device type information from JSON files, performs consistency checks, and renders templates. The code generates microgrid and IES optim check codes, updates direction tables, renders templates for device types, and writes generated code to file.",
    "details": [
        {
            "comment": "This code imports necessary modules and defines constants, variables, and paths for generating test code. It uses Jinja templates to generate code based on input parameters, and aims to create topo_check_v2 and ies_optim_legacy code files. The PEF file is also included as an input in the makefile.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/jinja_template_model_generator.py\":0-32",
            "content": "from log_utils import logger_print\n# serialized connectivity matrix -> connectivity matrix -> verify matrix -> calculation model -> calculate\n# to generate the serialized connectivity matrix, you need structures.\nfrom jinja_utils import *\nimport constants\nconstants_dict = {k: v for k, v in constants.__dict__.items() if not k.startswith(\"_\")}\n# the test code may not be generated.\nfrom param_base import *\nfrom render_type_utils import *\n# topo_code_output_path, topo_code_template_path = code_and_template_path(\"topo_check_v1\")\ntopo_code_v2_output_path, topo_code_v2_template_path = code_and_template_path(\n    \"topo_check_v2\"\n)\n# ies_optim_code_output_path, ies_optim_code_template_path = code_and_template_path(\n#     \"ies_optim\"\n# )\nies_optim_code_output_path, ies_optim_code_template_path = code_and_template_path(\n    \"ies_optim_legacy\"\n)\nMAKEFILE = dict(\n    inputs=[\n        topo_code_v2_template_path,\n        ies_optim_code_template_path,\n        (PEF := \"planning_export_format.json\"),\n        TYPE_UTILS_MICROGRID_PORTS,"
        },
        {
            "comment": "The code is reading device type information from JSON files, populating a list of device types and their associated port names. It also creates dictionaries for looking up input/output directions and performs consistency checks using the TypeUtils module. The code then renders templates based on this data.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/jinja_template_model_generator.py\":33-66",
            "content": "        TYPE_UTILS_EXTRA_PORTS,\n    ],\n    outputs=[topo_code_v2_output_path, ies_optim_code_output_path],\n    args=[],\n)\nimport json\n# delegate consistency checks to type utils. (not implemented yet)\n# make portname mappings being used in topo parsing & modeling\n# migrate to topo_check_v2\nwith open(PEF, \"r\") as f:\n    planningExportFormat = json.loads(f.read())\nif __name__ == \"__main__\":\n    # you need to stop rendering it here.\n    # TYPE_UTILS_MICROGRID_PORTS_DATA\n    # TYPE_UTILS_EXTRA_PORTS_DATA\n    \u8bbe\u5907\u7c7b\u578b = []\n    \u8bbe\u5907\u63a5\u53e3\u540d\u79f0\u96c6\u5408 = {}\n    directionTranslationTable = dict(\u8fdb=\"\u8f93\u5165\", \u51fa=\"\u8f93\u51fa\", \u8fdb\u51fa=\"\u8f93\u5165\u8f93\u51fa\")\n    directionLookupTable = {}\n    for dat in [TYPE_UTILS_MICROGRID_PORTS_DATA, TYPE_UTILS_EXTRA_PORTS_DATA]:\n        for supertype, devDict in dat.items():\n            for deviceTypeName, devData in devDict.items():\n                \u8bbe\u5907\u7c7b\u578b.append(deviceTypeName)\n                ports = devData[\"ports\"]\n                portNames = ports.keys()\n                \u8bbe\u5907\u63a5\u53e3\u540d\u79f0\u96c6\u5408[deviceTypeName] = set(portNames)\n                portDirectionLookupTable = {}"
        },
        {
            "comment": "The code generates microgrid topology check code using Jinja templates. It iterates through device types, updates direction lookup tables, and renders the template for each device type. The generated code is sorted based on planning export format.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/jinja_template_model_generator.py\":67-91",
            "content": "                for portName, portDef in ports.items():\n                    energyFlowDirection = portDef[\"\u80fd\u6d41\u65b9\u5411\"]\n                    direction = directionTranslationTable[energyFlowDirection]\n                    portDirectionLookupTable[portName] = direction\n                directionLookupTable[deviceTypeName] = portDirectionLookupTable\n    topo_check_v2_render_params = dict(\n        \u8bbe\u5907\u7c7b\u578b=\u8bbe\u5907\u7c7b\u578b, \u8bbe\u5907\u63a5\u53e3\u540d\u79f0\u96c6\u5408=\u8bbe\u5907\u63a5\u53e3\u540d\u79f0\u96c6\u5408, directionLookupTable=directionLookupTable\n    )\n    load_render_and_format(\n        template_path=topo_code_v2_template_path,\n        output_path=topo_code_v2_output_path,\n        render_params=topo_check_v2_render_params,\n        banner=\"TOPO CHECK CODE V2\",\n    )\n    # load_render_and_format(\n    #     template_path=topo_code_template_path,\n    #     output_path=topo_code_output_path,\n    #     render_params=dict(\u7c7b\u578b\u96c6\u5408\u5206\u7c7b=\u7c7b\u578b\u96c6\u5408\u5206\u7c7b, \u8bbe\u5907\u63a5\u53e3\u96c6\u5408=\u8bbe\u5907\u63a5\u53e3\u96c6\u5408, \u8fde\u63a5\u7c7b\u578b\u6620\u5c04\u8868=\u8fde\u63a5\u7c7b\u578b\u6620\u5c04\u8868),\n    #     banner=\"TOPO CHECK CODE\",\n    # )\n    planningExportFormatList = list(planningExportFormat.items())\n    planningExportFormatList.sort(key=lambda x: 0 if x[0] == \"\u65b9\u6848\u8be6\u60c5\" else 1)"
        },
        {
            "comment": "This code is generating IES optim code using a template and passing various parameters. It also performs a topology check by running test code after rendering the template. The generated code is then written to a file, and logger print statements provide additional information about the process.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/jinja_template_model_generator.py\":93-121",
            "content": "    render_params = dict(\n        \u8bbe\u5907\u5e93=\u8bbe\u5907\u5e93,\n        \u8bbe\u5907\u63a5\u53e3\u96c6\u5408=\u8bbe\u5907\u63a5\u53e3\u96c6\u5408,  # if you want more device models, you have to change here, maybe.\n        # but at least you can pass the topology check now, even if with extra non-existant models.\n        frontend_translation_table=frontend_translation_table,\n        planningExportFormatList=planningExportFormatList,\n        **constants_dict,\n        constants=constants_dict,\n    )\n    load_render_and_format(\n        template_path=ies_optim_code_template_path,\n        output_path=ies_optim_code_output_path,\n        render_params=render_params,\n        banner=\"IES OPTIM CODE\",\n    )\n    # test([\"test_topo_check.py\", \"-f\"])\n    # run test code.\n    test([\"test_topo_check.py\"])\n    # tpl = load_template(ies_optim_code_output_path)\n    # result = tpl.render(type_sys=type_sys, dparam=dparam)\n    # logger_print()\n    # logger_print(\"______________________[{}]\".format(\"IES CODE\"))\n    # logger_print(result)\n    # with open(ies_optim_code_output_path, \"w+\") as f:\n    #     f.write(result)"
        }
    ]
}