{
    "summary": "The code is a microgrid optimization program with data validation and features like macros, constraints, price models, initialization, class definitions, repetition avoidance, efficient handling of complex piecewise functions, solar panel efficiency optimization, renewable energy consumption management, device constraints consideration, transmission line decay handling, error handling, cost estimation, device limit management, and simulation results.",
    "details": [
        {
            "comment": "This code is a part of a larger program related to microgrid optimization. It imports several modules and classes, defines constants and functions. The code uses templates for data validation, unit conversion, and control flows, but has TODO comments to implement StrEnum for literals and separate data models in another template.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":0-27",
            "content": "{# TODO: replace string in templates with literal objects #}\nfrom log_utils import logger_print\nfrom pyomo_environ import *\nfrom typing import cast, Optional\nfrom config import *\nfrom pydantic import ValidationError\nimport cmath\nfrom copy import deepcopy\nimport copy\nfrom error_utils import ErrorManager\n# input: negative\n# output: positive\n# IO: Real\nimport numpy as np\nimport math\n{% set loadEnergyConsumptionRateAndPriceModelUnitMapping = {\n    \"\u7535\u8d1f\u8377\": (\"kW\", \"\u5143/kWh\"),\n    \"\u6c22\u8d1f\u8377\": (\"kg\", \"\u5143/kg\")\n}%}\n    {# \"\u6c22\u8d1f\u8377\": (\"kg/hour\", \"\u5143/kg\") #}\n# TODO: use StrEnum (3rd party library) to replace literals in data validation and control flows.\n# TODO: implement unit conversion of device info in another file with separate datamodels (another template) instead of explicit conversion in this template (create that first (skeleton) to suppress type check error)\n# ref: https://pypi.org/project/StrEnum/\n{% macro IsIterable(it)%}hasattr({{it}}, \"__iter__\"){% endmacro %}\ndef getattr_with_ellipsis_fallback(obj, attrName, default=cmath.nan):"
        },
        {
            "comment": "This code snippet appears to be part of a larger program related to microgrid optimization and simulations. It includes functions, variables, and comments indicating areas for further development and improvement in the codebase. The code also defines macros for handling parameters and includes imports for data types and packages for Pydantic library.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":28-54",
            "content": "    val = getattr(obj, attrName, default)\n    if val is ...:\n        val = default\n    return val\n{% macro applyMacroWithSingleParam(_macro, paramList) %}\n    {% for param in paramList%}\n{{_macro(param)}}\n    {% endfor%}\n{% endmacro%}\n{# VAR_INIT_AS_ZERO = \"VAR_INIT_AS_ZERO\" #}\nimport os\n# TODO: \u5178\u578b\u65e5 \u6700\u7ec8\u8f93\u51fa\u7ed3\u679c\u9700\u8981\u5c55\u5f00\u4e3a8760\n# TODO: add more \"bounds\" to variables\n# TODO: call external processor/parser to handle DSL, simplify expressions.\n{# optional comment flag for our stepwise refactor. #}\n{%set SO = namespace(class_name=\"\")%}\n{% set \u8bbe\u8ba1\u89c4\u5212 = \"if self.\u8ba1\u7b97\u53c2\u6570.\u8ba1\u7b97\u7c7b\u578b == '\u8bbe\u8ba1\u89c4\u5212'\"%}\n{% set \u4eff\u771f\u6a21\u62df = \"if self.\u8ba1\u7b97\u53c2\u6570.\u8ba1\u7b97\u7c7b\u578b == '\u4eff\u771f\u6a21\u62df'\"%}\n{% set \u79d2 = 'if self.\u8ba1\u7b97\u53c2\u6570.\u8ba1\u7b97\u6b65\u957f == \"\u79d2\"'%}\n{% set \u5c0f\u65f6 = 'if self.\u8ba1\u7b97\u53c2\u6570.\u8ba1\u7b97\u6b65\u957f == \"\u5c0f\u65f6\"'%}\n{# {% set needStorageDecayCompensation=true%} #}\n{% macro stepwise_flag(class_name, flag_name) %}{% if SO.class_name == class_name %}{{' STEPWISE FLAG [{}] '.format(flag_name).center(40, \"#\") }}{% endif %}{% endmacro %}\nfrom typing import Dict, List, Tuple, Union, Callable\nfrom pydantic import conlist, conint, confloat, constr"
        },
        {
            "comment": "This code is performing type checking and ensuring that all variable operations are properly typed. It uses pyright global configuration, imports necessary types from typing or typing_extensions, and includes functions for different data types such as non-negative integers and floats. The code also includes a macro double_check_setattr to prevent setting the same variable twice.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":55-88",
            "content": "from constants import *\n{# consider to type check all variable operations #}\n{# cast such type to all variables, to forbid 'var * var' #}\nimport pyomo.core.base\nimport parse\nfrom export_format_units import *\n{% set IndexedVar = \"pyomo.core.base.var.IndexedVar\" %}\n{% set GeneralVarData = \"pyomo.core.base.var._GeneralVarData\" %}\n{# forbid untyped code. #}\n{# mark as pyright global config. #}\n{# also for mypy #}\n{% set normal_str = \"constr(min_length=1)\"%}\n{% set non_neg_float = \"confloat(ge=0)\"%}\n{% set pos_float = \"confloat(gt=0)\"%}\n{% set non_neg_int = \"conint(ge=0)\"%}\n{% set pos_int = \"conint(gt=0)\"%}\n{% macro qstr(mstr)%}\"{{mstr}}\"{%endmacro%}\n{% macro import_type_fallback(symbol)%}\ntry:\n    from typing import {{symbol}}\nexcept:\n    from typing_extensions import {{symbol}}\n{% endmacro %}\n{{import_type_fallback(\"Literal\")}}\n{# \ntry:\n    from typing import Annotated\nexcept:\n    from typing_extensions import Annotated #}\n{# from typing import Tuple #}\n{% macro double_check_setattr(obj, attrName, val) %}\nassert getattr({{obj}},{{attrName}}, None) is None, f\"\u9519\u8bef: \u4e0d\u80fd\u8bbe\u7f6e\u4e24\u6b21\u76f8\u540c\u7684\u53d8\u91cf\u540d\u79f0\\n\u91cd\u590d\u53d8\u91cf: { {{attrName}} }\""
        },
        {
            "comment": "The code snippet is defining macros for creating Pydantic models and importing necessary libraries for microgrid computation. It also includes a function to construct tuple types based on provided literals, and defines constraints for unit conversion using the `pint` library.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":89-116",
            "content": "{{obj}}.__setattr__({{attrName}}, {{val}})\n{% endmacro %}\nimport rich\nfrom pydantic import BaseModel, Field, validator\n# the main code for computing.\n# currently just compute microgrid\n# three computation modes:\n{# shall you define more string literals in enum class, and more pydantic models, union types.#}\n{# from functools import lru_cache #}\n{# item count is for list, length is for string.#}\n{% macro tuple_type_construct(l, t) %}{{\", \".join([t]*l)}}{% endmacro %}\n{% macro PLField(tuple_name,tuple_size_literal,elem_name, description)%}\n{% set elem_type = elem_name%}\n{% if elem_name == \"\u4ef7\u683c\"%}\n    {% set elem_type = \"float\"%}\n{% endif%}\n    {{tuple_name}}:Tuple[{{tuple_type_construct(constants[tuple_size_literal], elem_type)}}] = Field(title = f\"\u957f\u5ea6\u4e3a{{'{'+tuple_size_literal+'}'}}\u7684{{elem_name}}\u6570\u7ec4\", description = \"{{description}}\")\n{% endmacro%}\n{# {% macro item_constraint(l)%}min_item = {{l}}, max_item= {{l}}{% endmacro%} #}\n{# ##########[PINT START]########## #}\n{# import pint #}\nfrom unit_utils import (\n    unitFactorCalculator,"
        },
        {
            "comment": "This code defines a pricing model for energy consumption, with functions to calculate the annual rate, get the fee per unit of power consumed, and convert prices between different units. It also includes functions to determine the current day index and time from the total hours consumed, as well as converting the electricity price into a specified unit.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":117-162",
            "content": "    ureg,\n    standard_units,\n    getSingleUnitConverted,\n    multiplyWithUnit\n)\n{# ##########[PINT END]########## #}\n### \u8ba1\u4ef7\u6a21\u578b ###\nimport math\n# \u51fd\u6570\u53c2\u6570: (power, time_in_day)\n# \u9636\u68af\u7535\u4ef7: \u5bb9\u91cf\u4e0b\u9650\u4ece0\u5f00\u59cb\n# TODO: \u6bcf\u4e2a\u6708\u7684\u90fd\u4e0d\u540c #\ndef \u8ba1\u7b97\u5e74\u5316\u7387(_\u8d34\u73b0\u7387, \u5bff\u547d):\n    # \u9ed8\u8ba4\u8d34\u73b0\u7387\u5355\u4f4d\u4e3a%\n    if _\u8d34\u73b0\u7387 <= 0 or \u5bff\u547d <= 0:\n        {# self.\u5e74\u5316\u7387 = 1/Life #}\n        \u5e74\u5316\u7387 = 0 # \u4eff\u771f\u6a21\u62df\u7684\u65f6\u5019 \u7528\u4e8e\u53bb\u9664\u548c\u5e74\u5316\u7387\u6709\u5173\u7684\u76ee\u6807\n    else:\n        \u8d34\u73b0\u7387 = _\u8d34\u73b0\u7387/100\n        \u5e74\u5316\u7387_CT = (1+\u8d34\u73b0\u7387) ** \u5bff\u547d\n        \u5e74\u5316\u7387 = (\u8d34\u73b0\u7387*\u5e74\u5316\u7387_CT)/(\u5e74\u5316\u7387_CT - 1) \n    return \u5e74\u5316\u7387\n{% set \u7535\u4ef7\u5355\u4f4d = \"\u5143/kWh\"%}\n{% set \u7535\u4ef7\u5355\u4f4d\u63cf\u8ff0 = \"\u5355\u4f4d: \u5143/kWh\"%}\n{% macro getFee() %}\n    def getFee(self, power:float, time_in_day:float) -> float:\n{% endmacro%}\n{% macro getMonthIndexFromTimeInDay()%}\n        current_day_index = time_in_day//\u6bcf\u5929\u5c0f\u65f6\u6570\n        month_index = convertDaysToMonth(current_day_index)\n{% endmacro%}\n{% macro getCurrentTimeFromTimeInDay()%}\n        current_time = math.floor(time_in_day%\u6bcf\u5929\u5c0f\u65f6\u6570)\n{% endmacro%}\n{% macro returnElectricPrice() %}\n        # unit: [currency]/[time]\n        # \u4e07\u5143/h\n        return self.convert(price*power)\n{% endmacro%}\n{% macro getFeeWrapper()%}"
        },
        {
            "comment": "Code calculates electric prices based on the energy type and converts values to standard units. It then creates a model for each energy type with its corresponding price, considering leap years, and provides a function to convert months to days.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":163-200",
            "content": "{{getFee()}}\n{{caller()}}\n{{ returnElectricPrice() }}\n{% endmacro %}\nfrom functools import lru_cache\nclass \u4ef7\u683c\u8f6c\u6362:\n    @staticmethod\n    @lru_cache(maxsize=1)\n    def getMagnitude():\n        magnitude, _ = unitFactorCalculator(ureg, standard_units, \"{{\u7535\u4ef7\u5355\u4f4d}}\")\n        return magnitude\n    @staticmethod\n    def convert(value):\n        # convert to standard unit\n        magnitude = \u4ef7\u683c\u8f6c\u6362.getMagnitude()\n        ret = value * magnitude\n        return ret\n{% for k, v in loadEnergyConsumptionRateAndPriceModelUnitMapping.items() %}\n    {% set energyType = k.strip('\u8d1f\u8377') %}\n    {% set unit = v[1] %}\nclass \u5e38\u6570{{energyType}}\u4ef7(BaseModel, \u4ef7\u683c\u8f6c\u6362):\n    Price:{{pos_float}} = Field(title = \"{{energyType}}\u4ef7\", description = \"{{unit}}\")\n{% call getFeeWrapper() %}\n        price = self.Price\n{% endcall %}\n{% endfor %}\nmonth_days = [31] * \u6bcf\u5e74\u6708\u6570\nmonth_days[1] = 28\nmonth_days[4 - 1] = month_days[6 - 1] = month_days[9 - 1] = month_days[11 - 1] = 30\nassert sum(month_days) == \u6bcf\u5e74\u5929\u6570\ndef convertMonthToDays(month_index:int):\n    {# cursor = month_index -1 #}"
        },
        {
            "comment": "The code defines two classes, `\u5206\u6708\u7535\u4ef7` (MonthlyPrice) and `\u5206\u65f6\u7535\u4ef7` (HourlyPrice), which inherit from the `BaseModel` and `\u4ef7\u683c\u8f6c\u6362` classes. They both have a `PriceList` field containing a tuple of prices for each month or hour in a year. The code also includes utility functions such as `convertDaysToMonth` to get the month index given a day index, and `getFeeWrapper` for fee calculation.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":201-229",
            "content": "    assert month_index in range({{\u6bcf\u5e74\u6708\u6570}})\n    ret = sum(month_days[:month_index])\n    return ret\ndef convertDaysToMonth(day_index:float):\n    acc_days = 0\n    for month_cursor, days_in_month in enumerate(month_days):\n        acc_days += days_in_month\n        if acc_days >= day_index:\n            return month_cursor\n    {# if day_index <365:\n        return month_cursor+1 #}\n    raise Exception(\"Invalid day index:\", day_index)\nclass \u5206\u6708\u7535\u4ef7(BaseModel, \u4ef7\u683c\u8f6c\u6362):\n    {# PriceList:Tuple[{{tuple_type_construct(\u6bcf\u5e74\u6708\u6570, \"float\")}}] = Field(title = f\"\u957f\u5ea6\u4e3a{\u6bcf\u5e74\u6708\u6570}\u7684\u4ef7\u683c\u6570\u7ec4\", description = \"{{\u7535\u4ef7\u5355\u4f4d\u63cf\u8ff0}}\") #}\n{{PLField(\"PriceList\", \"\u6bcf\u5e74\u6708\u6570\", \"\u4ef7\u683c\", \u7535\u4ef7\u5355\u4f4d\u63cf\u8ff0)}}\n{%call getFeeWrapper()%}\n{{getMonthIndexFromTimeInDay()}}\n        price = self.PriceList[month_index]\n{% endcall%}\nclass \u5206\u65f6\u7535\u4ef7(BaseModel, \u4ef7\u683c\u8f6c\u6362):\n    {# PriceList: Tuple[{{tuple_type_construct(\u6bcf\u5929\u5c0f\u65f6\u6570, \"float\")}}] = Field(title = f\"\u957f\u5ea6\u4e3a{\u6bcf\u5929\u5c0f\u65f6\u6570}\u7684\u4ef7\u683c\u6570\u7ec4\", description = \"{{\u7535\u4ef7\u5355\u4f4d\u63cf\u8ff0}}\") #}\n{{PLField(\"PriceList\", \"\u6bcf\u5929\u5c0f\u65f6\u6570\", \"\u4ef7\u683c\", \u7535\u4ef7\u5355\u4f4d\u63cf\u8ff0)}}\n{# \n    @validator(\"PriceList\")\n    def checkPriceList(cls, val):"
        },
        {
            "comment": "This code defines a pricing model for time-of-day and day-ahead energy prices. It uses tuples to represent the pricing data, with each tuple containing hourly prices for a specific month. The code also includes fee wrappers and calculates charges based on power usage and time in the day. Additionally, it defines a tiered pricing model using constant prices and has a lower limit for each tier.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":230-260",
            "content": "        assert len(val) == 24\n        return val #}\n{%call getFeeWrapper()%}\n{{getCurrentTimeFromTimeInDay()}}\n        price = self.PriceList[current_time]\n{% endcall%}\nclass \u5206\u65f6\u5206\u6708\u7535\u4ef7(BaseModel, \u4ef7\u683c\u8f6c\u6362):\n    {# PriceStruct:Tuple[{{tuple_type_construct(\u6bcf\u5e74\u6708\u6570, \"\u5206\u65f6\u7535\u4ef7\")}}] = Field(title = f\"\u957f\u5ea6\u4e3a{\u6bcf\u5e74\u6708\u6570}\u7684\u5206\u65f6\u7535\u4ef7\u6570\u7ec4\", description = \"{{\u7535\u4ef7\u5355\u4f4d\u63cf\u8ff0}}\") #}\n{{PLField(\"PriceStruct\", \"\u6bcf\u5e74\u6708\u6570\", \"\u5206\u65f6\u7535\u4ef7\", \u7535\u4ef7\u5355\u4f4d\u63cf\u8ff0)}}\n{# {%call getFeeWrapper()%} #}\n{{ getFee()}}\n{{getMonthIndexFromTimeInDay()}}\n        _\u5206\u65f6\u7535\u4ef7 = self.PriceStruct[month_index]\n        ret = _\u5206\u65f6\u7535\u4ef7.getFee(power,time_in_day)\n        return ret\n{# {{getCurrentTimeFromTimeInDay()}} #}\n        {# price = _\u5206\u65f6\u7535\u4ef7.PriceList[current_time]\n{% endcall%} #}\nclass \u8ba1\u4ef7\u9636\u68af(\u5e38\u6570\u7535\u4ef7):\n    LowerLimit : {{non_neg_float}} = Field(title = \"\u529f\u7387\u4e0b\u9650\")\nclass \u9636\u68af\u7535\u4ef7(BaseModel):\n    PriceStruct: conlist(\u8ba1\u4ef7\u9636\u68af, min_items=1) = Field(title = \"\u957f\u5ea6\u4e0d\u5b9a\u7684\u8ba1\u4ef7\u9636\u68af\u5217\u8868\", description = \"{{\u7535\u4ef7\u5355\u4f4d\u63cf\u8ff0}}\")\n    @validator(\"PriceStruct\")\n    def checkPriceStruct(cls, v: List[\u8ba1\u4ef7\u9636\u68af]):\n        v.sort(key = lambda x: x.LowerLimit)\n        assert v[0].LowerLimit == 0"
        },
        {
            "comment": "The code defines a class for daytime step-wise electricity pricing with hourly rate structures and handles exceptions when unable to get the electricity price. It also calculates the fee based on the current time and power. The code is related to energy loads like electric and hydro, and input types include diesel.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":261-288",
            "content": "        return v\n{{getFee()}}\n        for index, elem in enumerate(self.PriceStruct):\n            if elem.LowerLimit <= power:\n                if index+1 == len(self.PriceStruct) or self.PriceStruct[index+1].LowerLimit >= power:\n                    return elem.getFee(power, time_in_day)\n        logger_print(self)\n        raise Exception(\"Unable to get electricity price with power:\", power)\nclass \u5206\u65f6\u9636\u68af\u7535\u4ef7(BaseModel):\n    {# PriceStructList:Tuple[{{tuple_type_construct(\u6bcf\u5929\u5c0f\u65f6\u6570, \"\u9636\u68af\u7535\u4ef7\")}}] = Field(title = f\"\u957f\u5ea6\u4e3a{\u6bcf\u5929\u5c0f\u65f6\u6570}\u7684\u9636\u68af\u7535\u4ef7\u5217\u8868\", description = \"{{\u7535\u4ef7\u5355\u4f4d\u63cf\u8ff0}}\") #}\n{{PLField(\"PriceStructList\", \"\u6bcf\u5929\u5c0f\u65f6\u6570\", \"\u9636\u68af\u7535\u4ef7\", \u7535\u4ef7\u5355\u4f4d\u63cf\u8ff0)}}\n{{getFee()}}\n        current_time = math.floor(time_in_day%\u6bcf\u5929\u5c0f\u65f6\u6570)\n        mPriceStruct = self.PriceStructList[current_time]\n        result = mPriceStruct.getFee(power, time_in_day)\n        return result\n{% set load_types = ['\u7535', '\u6c22']%}\n{% set load_class_names = []%}\n{% for load_type in load_types%}\n{% do load_class_names.append(load_type+\"\u8d1f\u8377\")%}\n{% endfor%}\n{% set input_types = ['\u67f4\u6cb9'] %}\n{% macro sum_reduce(seq)%}"
        },
        {
            "comment": "This code defines macros for defining device classes, initializing super classes, and port variable definitions. The macros use Jinja templates to generate Python code for instantiating objects with specific attributes and functionality. This code is used in the context of microgrid optimization.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":289-314",
            "content": " sum({{seq}})\n{# functools.reduce(sequence={{seq}}, function = lambda x,y: x+y) #}\n{% endmacro%}\n{% macro init_super_class(class_name) %}\n    def __init__(self, PD:dict, mw: ModelWrapper, \u8ba1\u7b97\u53c2\u6570\u5b9e\u4f8b: \u8ba1\u7b97\u53c2\u6570, \u8bbe\u5907ID: {{ class_name }}ID, \u8bbe\u5907\u4fe1\u606f: {{ class_name }}\u4fe1\u606f):\n        super().__init__(PD=PD, mw=mw, \u8ba1\u7b97\u53c2\u6570\u5b9e\u4f8b=\u8ba1\u7b97\u53c2\u6570\u5b9e\u4f8b, ID = \u8bbe\u5907ID.ID)\n        self.\u8bbe\u5907ID = \u8bbe\u5907ID\n        self.\u8bbe\u5907\u4fe1\u606f = \u8bbe\u5907\u4fe1\u606f\n{% endmacro %}\n{% macro port_variable_define(class_name) %}\n        ##### PORT VARIABLE DEFINITION ####\n        self.ports = {}\n        {% for port_name, port_type in \u8bbe\u5907\u63a5\u53e3\u96c6\u5408[class_name] %}\n        {% if port_type.endswith(\"\u8f93\u5165\u8f93\u51fa\") or class_name in ['\u53d8\u538b\u5668', \"\u4f20\u8f93\u7ebf\"]%}\n        {% set mt = \"Reals\" %}\n        {% elif port_type.endswith(\"\u8f93\u5165\") %}\n        {# {% set mt = \"NegativeReals\"%} #}\n        {% set mt = \"NonPositiveReals\"%}\n        {% elif port_type.endswith(\"\u8f93\u51fa\") %}\n        {% set mt = \"NonNegativeReals\"%}\n        {% endif %}\n        self.PD[self.\u8bbe\u5907ID.{{port_name}}] = self.ports['{{port_name}}'] = self.{{port_name}} = self.\u53d8\u91cf\u5217\u8868(\"{{port_name}}\", within={{mt}})"
        },
        {
            "comment": "This code is defining a macro that expands unit conversion for device parameters, handling exceptions and assertions. It also sets variables such as the time step parameter and device parameter exception list. The code also mentions the concept of 8760 hours of data, several days of data to compute a year, and 7200 seconds for simulation purposes.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":315-352",
            "content": "        \"\"\"\n        \u7c7b\u578b: {{port_type}}\n        \"\"\"\n        {% endfor %}\n{% endmacro %}\n{%macro expand_unit_conversion(mdigit, exceptionList=[])%}\n        {% if mdigit[4] == 1 or mdigit[0] in exceptionList%}\n        self.{{ mdigit[0] }}: float = \u8bbe\u5907\u4fe1\u606f.{{ mdigit[0] }}\n        \"\"\"\n        \u540d\u79f0: {{ mdigit[1] }}\n        \u5355\u4f4d: {{ mdigit[2] }}\n        \"\"\"\n        {%else%}\n        self.{{ mdigit[0] }}: float = \u8bbe\u5907\u4fe1\u606f.{{ mdigit[0] }} * {{ mdigit[4]}}\n        \"\"\"\n        \u540d\u79f0: {{ mdigit[1] }}\n        \u5355\u4f4d: {{ mdigit[3] }} <- {{ mdigit[2] }}\n        \"\"\"\n        {% endif %}\n        assert self.{{ mdigit[0] }} >=0\n{%endmacro%}\n{% set \u65f6\u95f4\u6b65\u957f\u53c2\u6570='self.\u8ba1\u7b97\u53c2\u6570.\u65f6\u95f4\u53c2\u6570'%}\n{# {% set \u65f6\u95f4\u6b65\u957f\u53c2\u6570='self.\u8ba1\u7b97\u53c2\u6570.\u65f6\u95f4\u53c2\u6570()'%} #}\n{# {% set \u65f6\u95f4\u6b65\u957f\u53c2\u6570='(1 if self.\u8ba1\u7b97\u53c2\u6570.\u8ba1\u7b97\u6b65\u957f == \"\u5c0f\u65f6\" else 3600)'%} #}\n{% set \u5355\u5411\u53d8\u7535\u5668\u5217\u8868 = ['\u53d8\u538b\u5668', '\u53d8\u6d41\u5668']%}\n{%set \u8bbe\u5907\u53c2\u6570\u4f8b\u5916\u5217\u8868 = [\"PowerDeltaLimit\", \"RatedWindSpeed\", \"MaxWindSpeed\", \"MinWindSpeed\", \"BatteryDeltaLimit\", \"BatteryStorageDecay\", \"DeltaLimit\"]%}\n# 8760 hours of data\n# several days of data to compute a year\n# 7200 seconds. simulation\n# device parameters would be the same."
        },
        {
            "comment": "The code defines a base class `\u8bbe\u5907ID` and subclasses for each device type, which inherit from it. These classes have attributes representing the device ID and port IDs for each interface type. The `quicksum_indexed_var` function sums values from an indexed variable, either as a list or its values. The code also uses variables and functions from elsewhere in the codebase.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":354-397",
            "content": "# load and environment might change.\n# so for every device the will change.\n# iterate through all device-port pairs, then retrieve attributes from another dict.\n# string, digits, tables.\n# you can dump and load from json.\n{# \nclass \u52a0\u6cd5\u5668ID(BaseModel):\n    \u8f93\u5165:int\n    \u8f93\u51fa:int\n    \u8f93\u5165\u8f93\u51fa: int #}\n{# {% for super_class, class_name, mstrs, mdigits, mtables in \u8bbe\u5907\u5e93 %} #}\ndef quicksum_indexed_var(indexed_var):\n    if isinstance(indexed_var,list):\n        return sum(indexed_var)\n    return sum(indexed_var.values())\n#############\n# Device ID #\n#############\nfrom pydantic import validator\nclass \u8bbe\u5907ID(BaseModel):\n    ID: {{non_neg_int}} = Field(title = \"\u8bbe\u5907ID\", description = '\u4ece\u62d3\u6251\u56fe\u8282\u70b9ID\u83b7\u53d6')\n{% for class_name in \u8bbe\u5907\u63a5\u53e3\u96c6\u5408.keys()%}\nclass {{class_name}}ID(\u8bbe\u5907ID):\n    {% for port_name, port_type in \u8bbe\u5907\u63a5\u53e3\u96c6\u5408[class_name]%}\n    {{ port_name }}: {{non_neg_int}} = Field(title = \"{{ port_name }}ID\", description = \"\u63a5\u53e3\u7c7b\u578b: {{ port_type }}\")\n    \"\"\"\n    \u7c7b\u578b: {{ port_type }}\n    \"\"\"\n    {% endfor %}\n{% endfor %}\n###############\n# Device Info #\n###############\n{% set deviceBaseIdentifiers = ["
        },
        {
            "comment": "This code defines a `DeviceInfo` class with device base and optional identifiers. It also includes a `toStandard` method that converts the instance data to a standard format by mapping attribute names and handling nonexistent attributes. The method uses ErrorManager for error handling and deep copy for safe attribute retrieval.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":398-425",
            "content": "    \"\u8bbe\u5907\u540d\u79f0\",\n]%}\n{% set deviceOptionalIdentifiers = [\n    \"\u751f\u4ea7\u5382\u5546\",\n    \"\u8bbe\u5907\u578b\u53f7\",\n]%}\n{% set deviceIdentifiers = deviceBaseIdentifiers + deviceOptionalIdentifiers %}\nclass \u8bbe\u5907\u57fa\u7840\u4fe1\u606f(BaseModel):\n{% for i in deviceBaseIdentifiers%}\n    {{i}}: {{normal_str}} = Field(title = \"{{i}}\")\n{# \n    subtype_hidden: Union[None, str] = Field(\n        default=None, title=\"\u8282\u70b9\u539f\u6b21\u7c7b\u578b\", description=\"\u5185\u90e8\u53d8\u91cf\uff0c\u4e0d\u8981\u586b\u5199\"\n    )\n     #}\n    def toStandard(self, attr:str):\n        className = self.__class__.__name__\n        with ErrorManager(default_error = f\"Instance data:\\n{self.dict()}\\nError converting attribute '{attr}' of class '{className}'\"):\n            schema = self.schema()\n            props = schema['properties']\n            attr_alias_dict = {k: v.get('title', None) for k,v in props.items()}\n            attrName= attr if attr in props.keys() else attr_alias_dict[attr]\n            assert attrName, f\"Cannot find attribute name in class '{className}' with query '{attr}'\"\n            val = copy.deepcopy(getattr(self, attrName))\n            if val is None:"
        },
        {
            "comment": "This code is logging a warning for a None attribute, using zero as a placeholder. It then extracts unit information from the description and checks if it matches the variable name length. Afterwards, it iterates through units, calculating conversion rates and converting variables accordingly.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":426-447",
            "content": "                logger_print(\"Warning: Attribute '{attr}' of class '{className}' is None. Using zero instead.\")\n                return 0\n            desc = props[attr]['description']\n            val_units = desc.replace(\"\uff1a\", \":\").split(\":\")[-1].strip()\n            units = []\n            for i, unit in enumerate(val_units.replace(\"\uff0c\", \",\").split(\",\")):\n                u = unit.strip()\n                if u:\n                    units.append(u)\n            varNames = attrName.replace(\"-\",\"_\").split(\"_\")\n            assert len(varNames) == len(units), f\"units length ({units}) does not match varname length ({varNames}).\\nfailed to parse unit for: {className}.{attrName}\"\n            assert len(units)>0, f\"{className}.{attrName} does not have unit definition\"\n            crlist = []\n            for val_unit in units:\n                ConversionRate, StandardUnit = unitFactorCalculator(ureg, standard_units, val_unit)\n                logger_print(f\"Converting param {varNames[i]} at {className}.{attrName}: {val_unit} -> {StandardUnit} (magnitude: {ConversionRate})\")"
        },
        {
            "comment": "Code snippet performs conversion rate calculation based on the shape of input values. It appends ConversionRate to crlist and checks if val has a single element or not. If it does, it asserts that the length of varNames is 1 and multiplies val by crlist[0]. If val has multiple elements, it iterates over them and checks if their lengths match len_varNames. It then calculates the conversion rates for each element and appends them to ret_val. Finally, the class defines device information with optional identifiers, creating fields for each identifier with a normal string data type.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":448-470",
            "content": "                crlist.append(ConversionRate)\n            len_varNames = len(varNames)\n            if not {{ IsIterable('val') }}:\n                assert len_varNames == 1, f\"input value {val} failed to match shape of class {className}.{attrName} (len: {len_varNames})\"\n                ret_val = val*crlist[0]\n            elif not {{ IsIterable('val[0]') }} :\n                assert len_varNames == 1, f\"input value {val} failed to match shape of class {className}.{attrName} (len: {len_varNames})\"\n                ret_val = [v*crlist[0] for v in val]\n            else:\n                # verify shape here.\n                ret_val = []\n                for it in val:\n                    assert len(it) == len_varNames, f\"input value {it} failed to match shape of class {className}.{attrName} (len: {len_varNames})\"\n                    ret_val.append([it[i]*crlist[i] for i in range(len_varNames)])\n            return ret_val\n{% endfor %}\nclass \u8bbe\u5907\u4fe1\u606f(\u8bbe\u5907\u57fa\u7840\u4fe1\u606f):\n{% for i in deviceOptionalIdentifiers%}\n    {{i}}: {{normal_str}} = Field(title = \"{{i}}\")"
        },
        {
            "comment": "This code defines several enumeration classes, including WindPowerTypes, FuelConsumptionPlanningAlgorithms, RenewableEnergyDevices, and others. It also sets default unit conversions for various fuels and renewable energy devices.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":472-532",
            "content": "{% endfor %}\n{# \u8bbe\u5907\u7279\u6709\u7c7b\u578b #}\nfrom enum import auto\nimport sys\n{# \nif sys.version_info >= (3,11):\n    from enum import StrEnum\nelse:\n    from strenum import StrEnum #}\nfrom strenum import StrEnum\nclass \u98ce\u529b\u53d1\u7535\u7c7b\u578b(StrEnum):\n    \u53d8\u6868 = auto()\n    \u5b9a\u6868 = auto()\n    \u6807\u5e7a\u503c = auto()\nclass \u6cb9\u8017\u89c4\u5212\u7b97\u6cd5(StrEnum):\n    \u5e73\u5747= auto()\n    \u6700\u4f73= auto()\nclass \u65b0\u80fd\u6e90\u6d88\u7eb3\u7ea6\u675f(StrEnum):\n    \u65e0 = auto()\n    \u60e9\u7f5a\u4ee3\u4ef7 = auto()\n    \u9650\u5236\u6d88\u7eb3\u7387 = auto()\nclass \u8d1f\u8377\u7c7b\u578b(StrEnum):\n    Normal = auto()\n    Punished = auto()\n    Flexible = auto()\n    Interruptable = auto()\n    InterruptableAndFlexible = auto()\nclass Direction(StrEnum):\n    Directed = auto()\n    Bidirectional = auto()\n{% set NonLoadDeviceDict = {} %}\n{# \u4e0d\u662f\u6807\u51c6\u5355\u4f4d #}\n{% set gasEmissionUnit = \"kg/L\" %}\n{% set fuelEmissionUnits = {} %}\n{% for gas in [\n        \"CO2\",\n        \"NOX\",\n        \"SO2\"\n    ]\n%}\n    {% do fuelEmissionUnits.update({gas: gasEmissionUnit}) %}\n{% endfor %}\n{% set \u71c3\u6599\u80fd\u6e90\u76f8\u5173\u6570\u636e\u9ed8\u8ba4\u5355\u4f4d = {\n    '\u67f4\u6cb9': {\n        \"Price\": \"\u4e07\u5143/L\",\n        \"\u70ed\u503c\": \"kWh/L\",\n        }\n    }\n%}\n{%set RenewableEnergyDevices = ['\u98ce\u529b\u53d1\u7535', '\u5149\u4f0f\u53d1\u7535']%}\n{% for key in \u71c3\u6599\u80fd\u6e90\u76f8\u5173\u6570\u636e\u9ed8\u8ba4\u5355\u4f4d.keys()%}"
        },
        {
            "comment": "This code is initializing data structures for a microgrid simulation. It updates the fuel emission units, creates dictionaries for device classes, and defines a class with fields such as LoadType, PunishmentRate, and Pmin. The code also sets default values and provides descriptions for each field. The code utilizes various data structures and constants to organize and store information about different devices and their properties.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":533-554",
            "content": "    {% do \u71c3\u6599\u80fd\u6e90\u76f8\u5173\u6570\u636e\u9ed8\u8ba4\u5355\u4f4d[key].update(fuelEmissionUnits) %}\n{% endfor %}\n{% for super_class, class_name, mstrs, mdigits, mtables in \u8bbe\u5907\u5e93 %}\n    {% do NonLoadDeviceDict.update({class_name: (super_class, mstrs, mdigits, mtables)})%}\n{% endfor %}\n{% for class_name in \u8bbe\u5907\u63a5\u53e3\u96c6\u5408.keys() %}\nclass {{class_name}}\u4fe1\u606f({{\"\u8bbe\u5907\u57fa\u7840\u4fe1\u606f\" if class_name not in NonLoadDeviceDict.keys() else \"\u8bbe\u5907\u4fe1\u606f\"}}):\n    {% if class_name not in NonLoadDeviceDict.keys() %}\n        {% if class_name in load_class_names %}\n        {% set energyConsumptionRateUnit = loadEnergyConsumptionRateAndPriceModelUnitMapping[class_name][0] %}\n        {% set priceModelUnit = loadEnergyConsumptionRateAndPriceModelUnitMapping[class_name][1] %}\n    LoadType: \u8d1f\u8377\u7c7b\u578b = Field(default = \u8d1f\u8377\u7c7b\u578b.Normal, title = \"\u8d1f\u8377\u7c7b\u578b\", description = f\"\u53ef\u9009: {', '.join(\u8d1f\u8377\u7c7b\u578b.__members__.keys())}\")\n    # \u6b63\u6570\n    PunishmentRate: confloat(ge=0) = Field(default = 0, title = \"\u60e9\u7f5a\u7cfb\u6570\", description=\"\u5355\u4f4d: {{priceModelUnit}}\")\n    \"\"\"\n    \u5355\u4f4d: {{priceModelUnit}}\n    \"\"\"\n    Pmin : confloat(ge = 0) = Field(default = 0,title = \"\u8d1f\u8377\u529f\u7387\u6700\u5c0f\u503c\", description = \"\u5355\u4f4d: {{energyConsumptionRateUnit}}\")"
        },
        {
            "comment": "This code defines a class for a load (possibly electrical) with fields such as Pmax, LoadType, and EnergyConsumption. It also has a validator function to ensure that Pmax is greater than or equal to Pmin if the LoadType is Flexible or InterruptableAndFlexible. The MaxEnergyConsumption field is optional for loads of type '\u7535\u8d1f\u8377' (which might be 'electric load' in English), and is used for typical day calculations. The code also mentions energy consumption rates in terms of a unit, possibly Watts or kWh.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":555-581",
            "content": "    \"\"\"\n    \u5355\u4f4d: {{energyConsumptionRateUnit}}\n    \"\"\"\n    Pmax : confloat(ge = 0) = Field(default = 0,title = \"\u8d1f\u8377\u529f\u7387\u6700\u5927\u503c\", description = \"\u5355\u4f4d: {{energyConsumptionRateUnit}}\")\n    \"\"\"\n    \u5355\u4f4d: {{energyConsumptionRateUnit}}\n    \"\"\"\n    @validator('Pmax')\n    def validate_Pmax(cls, v, values):\n        if values.get('LoadType', None) in [\u8d1f\u8377\u7c7b\u578b.Flexible, \u8d1f\u8377\u7c7b\u578b.InterruptableAndFlexible]:\n            p_min = values.get('Pmin', 0)\n            assert v >= p_min, f\"Pmax must be greater than or equal to Pmin\\nGiven: Pmax={v}, Pmin={p_min}\"\n        return v\n    EnergyConsumption: List[{{non_neg_float}}] = Field(title = '\u8017\u80fd\u529f\u7387\u8868', description='\u5355\u4f4d: {{energyConsumptionRateUnit}}')\n    \"\"\"\n    \u5355\u4f4d: {{energyConsumptionRateUnit}}\n    {# In this way it will be timescale independent. #}\n    \"\"\"\n    {% if class_name in ['\u7535\u8d1f\u8377']%}\n    MaxEnergyConsumption: Union[None, {{pos_float}}] = Field(default = None, title = \"\u6700\u5927\u6d88\u8017\u529f\u7387\", description = '\u5355\u4f4d: {{energyConsumptionRateUnit}}')\n    \"\"\"\n    \u5355\u4f4d: {{energyConsumptionRateUnit}}\n    {# \u7528\u4e8e\u7535\u8d1f\u8377 \u5178\u578b\u65e5\u8ba1\u7b97 #}"
        },
        {
            "comment": "This code defines different price models and default units for various load types. For '\u7535\u8d1f\u8377' (electric load), it has multiple pricing options, while '\u6c22\u8d1f\u8377' (hydrogen load) uses a constant hydrogen price. If the load type is not recognized, an error is thrown. For fuel-related loads, default units are defined using a loop.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":582-607",
            "content": "    \"\"\"\n    {% endif %}\n            {% if class_name in [\"\u7535\u8d1f\u8377\"]%}\n    PriceModel: Union[\u5e38\u6570\u7535\u4ef7, \u9636\u68af\u7535\u4ef7, \u5206\u65f6\u7535\u4ef7, \u5206\u65f6\u9636\u68af\u7535\u4ef7, \u5206\u6708\u7535\u4ef7, \u5206\u65f6\u5206\u6708\u7535\u4ef7] = Field(title = '\u8ba1\u4ef7\u6a21\u578b', description='\u5355\u4f4d: {{priceModelUnit}}')\n            {% elif class_name in ['\u6c22\u8d1f\u8377']%}\n    PriceModel: \u5e38\u6570\u6c22\u4ef7 = Field(title = '\u8ba1\u4ef7\u6a21\u578b', description='\u5355\u4f4d: {{priceModelUnit}}')\n            {% else %}\n                {% error(\"\u672a\u627e\u5230'{}'\u7684\u8ba1\u4ef7\u6a21\u578b\".format(class_name)) %}\n            {% endif %}\n        {% else %}\n            {% if class_name in \u71c3\u6599\u80fd\u6e90\u76f8\u5173\u6570\u636e\u9ed8\u8ba4\u5355\u4f4d.keys() %}\n                {% for attrName, defaultUnit in \u71c3\u6599\u80fd\u6e90\u76f8\u5173\u6570\u636e\u9ed8\u8ba4\u5355\u4f4d[class_name].items()%}\n    {{ attrName}} : Tuple[{{pos_float}}, {{normal_str}}] = Field(title = \"{{attrName}}\", description=\"\u683c\u5f0f: [\u6570\u503c,\u5355\u4f4d]\")\n    \"\"\"\n    \u683c\u5f0f: [\u6570\u503c,\u5355\u4f4d]\n    \"\"\"\n                {% endfor%}\n    class DefaultUnits:\n                {% for attrName, defaultUnit in \u71c3\u6599\u80fd\u6e90\u76f8\u5173\u6570\u636e\u9ed8\u8ba4\u5355\u4f4d[class_name].items()%}\n        {{attrName}} = \"{{defaultUnit}}\"\n                {%endfor%}\n            {% else%}\n                {% error(\"\u672a\u77e5\u8d1f\u8377\u4fe1\u606f\u7c7b\u578b:\", class_name)%}\n            {% endif%}"
        },
        {
            "comment": "Code segment includes definitions for various device classes, with specific properties and default values set based on the class. For example, if the device is a \"\u7535\u89e3\u69fd\", it has a StartupCountLimit and LHVHydrogen property, while a \"\u4f20\u8f93\u7ebf\" has an Optimize, U, Rho, and GivenAveragePower property. The code uses Field() from pydantic library to define these properties with default values and descriptions.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":608-630",
            "content": "        {% endif%}\n    {% else %}\n        {% set super_class, mstrs, mdigits, mtables = NonLoadDeviceDict[class_name] %}\n        {# special variables for non-load device info #}\n        {# {% if class_name in ['\u9502\u7535\u6c60']%} #}\n    {# needStorageDecayCompensation : bool = Field(default=True, title = \"\u662f\u5426\u5141\u8bb8\u53ef\u53d8\u5b58\u50a8\u8870\u51cf\u8865\u507f\", description = \"\u5f00\u542f\u540e\u5b58\u50a8\u8870\u51cf\u8865\u507f\u5c06\u53ef\u53d8\uff0c\u53cd\u4e4b\u5b58\u50a8\u8870\u51cf\u8865\u507f\u7b49\u4e8e\u5b58\u50a8\u8870\u51cf\") #}\n        {% if class_name in ['\u7535\u89e3\u69fd'] %}\n    StartupCountLimit: Optional[int] = Field(default = None, title = \"\u542f\u52a8\u6b21\u6570\u9650\u5236\", description = \"\u9ed8\u8ba4\u4e3anull\")\n    LHVHydrogen:float = Field(default = 33.3, title = \"\u6c22\u6c14\u70ed\u503c\", description = \"\u5355\u4f4d: kWh/kg\")\n    \"\"\"\n    \u5355\u4f4d: kWh/kg\n    \"\"\"\n        {% elif class_name in ['\u4f20\u8f93\u7ebf'] %}\n    Optimize: bool = Field(default = False, title =\"\u662f\u5426\u4f18\u5316\u7ebf\u5f84\", description = \"\u82e5\u9009\u662f\uff0c\u6839\u636e\u7535\u8d1f\u8377\u5cf0\u503c\u786e\u5b9a\u4f20\u8f93\u7535\u529f\u7387; \u9009\u5426\uff0c\u5219\u8f93\u5165\u7ed9\u5b9a\u4f20\u8f93\u7535\u529f\u7387\u503c\")\n    U:confloat(gt=0) = Field(title = \"\u4f20\u8f93\u7535\u538b\", description = \"\u5355\u4f4d: V\")\n    \"\"\"\n    \u5355\u4f4d: V\n    \"\"\"\n    Rho:confloat(gt=0) = Field(title = \"\u4f20\u8f93\u7ebf\u7535\u963b\u7387\", description = \"\u5355\u4f4d: \u03a9*m\")\n    \"\"\"\n    \u5355\u4f4d: \u03a9*m\n    \"\"\"\n    GivenAveragePower:confloat(gt = 0) = Field(title = '\u5e73\u5747\u529f\u7387', description = \"\u5355\u4f4d: kW\")"
        },
        {
            "comment": "This code defines the fields for the `GivenMaxPower`, `Pwire_Asec_Pr`, `RenewableEnergyConsumptionConstraint`, `RenewableEnergyConsumptionPunishmentRate`, and `RenewableEnergyConsumptionRate` in a class. The `Pwire_Asec_Pr` field stores the transmission power limit, cross-sectional area, and per-unit length price for different sections. The `RenewableEnergyConsumptionConstraint`, `RenewableEnergyConsumptionPunishmentRate`, and `RenewableEnergyConsumptionRate` fields define the constraints, punishment rate, and consumption rate for renewable energy. The code also includes a validator function for the `RenewableEnergyConsumptionPunishmentRate` field to check its value based on the `RenewableEnergyConsumptionConstraint`.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":631-662",
            "content": "    \"\"\"\n    \u5355\u4f4d: kW\n    \"\"\"\n    GivenMaxPower:confloat(gt = 0) = Field(title = '\u5cf0\u503c\u529f\u7387', description = \"\u5355\u4f4d: kW\")\n    \"\"\"\n    \u5355\u4f4d: kW\n    \"\"\"\n    Pwire_Asec_Pr: List[Tuple[confloat(gt=0), confloat(gt=0), confloat(gt=0)]] = Field(title = \"\u4f20\u8f93\u7535\u529f\u7387\u4e0a\u9650-\u622a\u9762\u79ef-\u5355\u4f4d\u957f\u5ea6\u4ef7\u683c\", description=\"\u5355\u4f4d\uff1akW\uff0cmm2\uff0c\u4e07\u5143/km\")\n    \"\"\"\n    Pwire\uff08\u4f20\u8f93\u7535\u529f\u7387\u4e0a\u9650\uff09\n    \u5355\u4f4d\uff1akW\n    Asec\uff08\u622a\u9762\u79ef\uff09\n    \u5355\u4f4d\uff1amm2\n    Pr\uff08\u5355\u4f4d\u957f\u5ea6\u4ef7\u683c\uff09\n    \u5355\u4f4d\uff1a\u4e07\u5143/km\n    \"\"\"\n        {% elif class_name in RenewableEnergyDevices%}\n    RenewableEnergyConsumptionConstraint: \u65b0\u80fd\u6e90\u6d88\u7eb3\u7ea6\u675f = Field(default = \u65b0\u80fd\u6e90\u6d88\u7eb3\u7ea6\u675f.\u65e0, title= \"\u65b0\u80fd\u6e90\u6d88\u7eb3\u7ea6\u675f\", description = \"\u65e0\u3001\u60e9\u7f5a\u4ee3\u4ef7\u3001\u9650\u5236\u6d88\u7eb3\u7387\" )\n    RenewableEnergyConsumptionPunishmentRate: confloat(ge=0) = Field(default=0, title = \"\u65b0\u80fd\u6e90\u6d88\u7eb3\u7ea6\u675f\u60e9\u7f5a\u4ee3\u4ef7\", description = \"\u5355\u4f4d: \u5143/kWh\")\n    \"\"\"\n    \u5355\u4f4d: \u5143/kWh\n    \"\"\"\n    RenewableEnergyConsumptionRate: confloat(ge=0, le=100) = Field(default=0, title = \"\u65b0\u80fd\u6e90\u6d88\u7eb3\u7387\",description = \"\u5355\u4f4d: percent\")\n    \"\"\"\n    \u5355\u4f4d: percent\n    \"\"\"\n    @validator(\"RenewableEnergyConsumptionPunishmentRate\")\n    def validate_RenewableEnergyConsumptionPunishmentRate(cls, v, values):\n        if values.get('RenewableEnergyConsumptionConstraint', \u65b0\u80fd\u6e90\u6d88\u7eb3\u7ea6\u675f.\u65e0) == \u65b0\u80fd\u6e90\u6d88\u7eb3\u7ea6\u675f.\u60e9\u7f5a\u4ee3\u4ef7:"
        },
        {
            "comment": "This code segment defines fields for different machine types, including wind and diesel generators. It sets default values and provides titles and descriptions for each field to assist the user. The \"normalizedPower\" field is specific to wind turbines, storing a list of typical daily, yearly, or second-level normalized power values. For diesel and gas generators, it includes an optional annual operating time constraint and maximum limit of operation.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":663-676",
            "content": "            assert v>0, f\"\u4e0d\u5408\u7406\u7684\u60e9\u7f5a\u4ee3\u4ef7\uff1a{v}\"\n        return v\n            {% if class_name in ['\u98ce\u529b\u53d1\u7535'] %}\n    machineType: \u98ce\u529b\u53d1\u7535\u7c7b\u578b = Field(default=\u98ce\u529b\u53d1\u7535\u7c7b\u578b.\u53d8\u6868, title = '\u9009\u62e9\u98ce\u529b\u53d1\u7535\u7c7b\u578b', description = \"\u5b9a\u6868\u3001\u53d8\u6868\uff08\u9ed8\u8ba4\uff09\u3001\u6807\u5e7a\u503c\")\n    normalizedPower: Union[None, List[float]]= Field(default=None, title=\"\u98ce\u529b\u53d1\u7535\u6807\u5e7a\u503c\", description = \"\u7a7a\u6216\u6570\u7ec4(\u5178\u578b\u65e5\u957f\u5ea6\u4e3a24,\u5168\u5e74\u9010\u65f6\u957f\u5ea6\u4e3a8760,\u79d2\u7ea7\u957f\u5ea6\u4e3a7200)\")\n            {%endif%}\n        {% elif class_name in ['\u67f4\u6cb9\u53d1\u7535', '\u71c3\u6c14\u53d1\u7535\u673a']%}\n    {# \u673a\u7ec4\u5e74\u8fd0\u884c\u65f6\u95f4\u7ea6\u675f:bool (\u82e5\u9009\u5426\uff0c\u53d8\u91cf\u7ea6\u675f\u4e0d\u521b\u5efa\uff0c\u53d8\u91cf\u4e3a\u81ea\u7531\u53d8\u91cf\uff0c\u964d\u4f4e\u8ba1\u7b97\u91cf)  #}\n    {# unitAnnualOperatingTimeConstraint:bool #}\n    {# {{cws(\"Unit annual operating time constraint\")}}:bool=Field(default = False, title=\"\u673a\u7ec4\u5e74\u8fd0\u884c\u65f6\u95f4\u7ea6\u675f\", description=\"\u82e5\u9009\u5426\uff0c\u53d8\u91cf\u7ea6\u675f\u4e0d\u521b\u5efa\uff0c\u53d8\u91cf\u4e3a\u81ea\u7531\u53d8\u91cf\uff0c\u964d\u4f4e\u8ba1\u7b97\u91cf\") #}\n    unitAnnualOperatingTimeConstraint:bool=Field(default = False, title=\"\u673a\u7ec4\u5e74\u8fd0\u884c\u65f6\u95f4\u7ea6\u675f\", description=\"\u82e5\u9009\u5426\uff0c\u53d8\u91cf\u7ea6\u675f\u4e0d\u521b\u5efa\uff0c\u53d8\u91cf\u4e3a\u81ea\u7531\u53d8\u91cf\uff0c\u964d\u4f4e\u8ba1\u7b97\u91cf\")\n    {# \u673a\u7ec4\u5e74\u8fd0\u884c\u65f6\u95f4\u6700\u9ad8\u9650\u503c\uff0c\u5355\u4f4d\uff1a\u6b21\u3002 #}\n    maximumAnnualOperatingTimeLimitOfTheUnit:conint(ge=0)=Field(default=0, title=\"\u673a\u7ec4\u5e74\u8fd0\u884c\u65f6\u95f4\u6700\u9ad8\u9650\u503c\", description=\"\u5355\u4f4d\uff1a\u5c0f\u65f6\")\n    {# {{cws(\"Maximum annual operating time limit of the unit\")}}:bool=Field(default = False, title=\"\u673a\u7ec4\u5e74\u8fd0\u884c\u65f6\u95f4\u6700\u9ad8\u9650\u503c\", description=\"\u5355\u4f4d\uff1a\u6b21\") #}"
        },
        {
            "comment": "This code defines several fields including whether to consider unit start-up costs, the unit single start-up cost (in Chinese), and the unit planning algorithm selection. It also includes options for average and best load rate calculations based on the planning algorithm choice. Additionally, it handles bi-directional transformers and sets visited fields to avoid repeating the same field definition.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":677-693",
            "content": "    {# \u8003\u8651\u673a\u7ec4\u542f\u52a8\u8d39\u7528:bool(\u82e5\u9009\u5426\uff0c\u53d8\u91cf\u7ea6\u675f\u4e0d\u521b\u5efa\uff0c\u53d8\u91cf\u4e3a\u81ea\u7531\u53d8\u91cf\uff0c\u964d\u4f4e\u8ba1\u7b97\u91cf) #}\n    considerUnitStartUpCosts:bool=Field(default = False, title=\"\u8003\u8651\u673a\u7ec4\u542f\u52a8\u8d39\u7528\", description=\"\u82e5\u9009\u5426\uff0c\u53d8\u91cf\u7ea6\u675f\u4e0d\u521b\u5efa\uff0c\u53d8\u91cf\u4e3a\u81ea\u7531\u53d8\u91cf\uff0c\u964d\u4f4e\u8ba1\u7b97\u91cf\")\n    {# \u673a\u7ec4\u5355\u6b21\u542f\u52a8\u8d39\u7528\uff0c\u5355\u4f4d\uff1a\u5143/\u6b21 #}\n    unitSingleStartupCost:conint(ge=0) =Field(default =0, title=\"\u673a\u7ec4\u5355\u6b21\u542f\u52a8\u8d39\u7528\", description=\"\u5355\u4f4d\uff1a\u5143/\u6b21\")\n    {# \u673a\u7ec4\u89c4\u5212\u7b97\u6cd5\u9009\u62e9 (\u5e73\u5747\u6cb9\u8017\u89c4\u5212\u7b97\u6cd5\u6216\u8005\u6700\u4f73\u6cb9\u8017\u89c4\u5212\u7b97\u6cd5)\u3002 #}\n    unitPlanningAlgorithmSelection: \u6cb9\u8017\u89c4\u5212\u7b97\u6cd5=Field(default =\u6cb9\u8017\u89c4\u5212\u7b97\u6cd5.\u5e73\u5747 ,title=\"\u673a\u7ec4\u89c4\u5212\u7b97\u6cd5\u9009\u62e9\", description=\"\u5e73\u5747/\u6700\u4f73\")\n    {# \u5e73\u5747\u8d1f\u8f7d\u7387: (\u5982\u679c\u662f\u5e73\u5747\u6cb9\u8017\u89c4\u5212\u7b97\u6cd5\uff0c\u9700\u8981\u586b\u5199\uff0c\u5426\u5219\u9ed8\u8ba4\u4e3a\u7a7a\uff09 #}\n    averageLoadRate : confloat(ge=0, le=100) = Field(default =0, title=\"\u5e73\u5747\u8d1f\u8f7d\u7387\", description=\"\u5355\u4f4d\uff1apercent\")\n            {% elif class_name in ['\u53d8\u538b\u5668'] %}\n    direction: Direction = Field(default= Direction.Directed, title = \"\u5355\u53cc\u5411\u6a21\u5f0f\",description=\"\u9ed8\u8ba4\u4e3a\u5355\u5411\")\n        {% endif %} \n        {% set visited_fields = [] %}\n        {% for psc, mstr in mstrs %}\n            {%if mstr not in deviceIdentifiers %}\n                {% if mstr not in visited_fields %}\n                    {% do visited_fields.append(mstr) %}\n    {{ mstr }}: {{normal_str}} = Field(title = \"{{mstr}}\")"
        },
        {
            "comment": "This code is generating a field in a class with title and description, and defining a validator function for specific fields when their unit is 'percent'. It appends the field names to a list and checks if the value is less than or equal to a threshold. If it is, it generates a warning message. The purpose of this code is to ensure that percent values passed to the class are not too low.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":694-718",
            "content": "                {% endif%}\n            {% endif%}\n        {% endfor %}\n        {% for psc, mdigit in mdigits %}\n            {% set mstr = mdigit[0]%}\n            {% if mstr not in visited_fields%}\n                {% do visited_fields.append(mstr)%}\n    {{ mstr }}: {{non_neg_float}} = Field(title = \"{{mdigit[1]}}\", description =   \"\u540d\u79f0: {{ mdigit[1] }}\\n\u5355\u4f4d: {{ mdigit[2] }}\")\n    \"\"\"\n    \u540d\u79f0: {{ mdigit[1] }}\n    \u5355\u4f4d: {{ mdigit[2] }}\n    \"\"\"\n                {% if mdigit[2] == 'percent'%}\n                {# {% do percent_fields.append(mdigit[1])%} #}\n    @validator({{repr(mstr)}})\n    {# @validator({{validate_params}}) #}\n    def validate_{{mstr}}_for_percent_warning(cls, value):\n        warning_msg = None\n        field_name = {{repr(mstr)}}\n        if value <= ies_env.PERCENT_WARNING_THRESHOLD:\n            warning_msg = f\"Field '{field_name}' (value: {value}; unit: percent) passed to class '{cls.__name__}' is less than or equal to {ies_env.PERCENT_WARNING_THRESHOLD}\"\n        if warning_msg is not None:\n            if ies_env.UNIT_WARNING_AS_ERROR:"
        },
        {
            "comment": "This code defines a field in a class and handles exceptions for invalid input. It creates a field with a title and description, and adds it to the list of visited fields. The code also includes a validator for the \"RatedPower\" attribute when the class name is \"\u98ce\u529b\u53d1\u7535\".",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":719-748",
            "content": "                {# raise ValidationError(warning_msg) #}\n                raise Exception(warning_msg)\n            else:\n                logger_print(warning_msg)\n        return value\n                {%endif%}\n            {% endif%}\n        {% endfor %}\n        {% for psc, main, sub in mtables %}\n            {% set mtable=(main, sub)%}\n            {% set mstr = mtable[0][0]+\"_\"+mtable[1][0] %}\n            {% if mstr not in visited_fields%}\n                {% do visited_fields.append(mstr)%}\n    {{ mstr}} : List[Tuple[{{pos_float}},{{non_neg_float}}]] = Field(title = \"{{ mtable[0][1]}}_{{ mtable[1][1]}}\", description=   \"{{ mtable[0][0]}}: {{ mtable[0][1]}}\\n\u5355\u4f4d: {{ mtable[0][2]}}\\n{{ mtable[1][0]}}: {{ mtable[1][1]}}\\n\u5355\u4f4d: {{ mtable[1][2]}}\")\n    \"\"\"\n    {{ mtable[0][0]}}: {{ mtable[0][1]}}\n    \u5355\u4f4d: {{ mtable[0][2]}}\n    {{ mtable[1][0]}}: {{ mtable[1][1]}}\n    \u5355\u4f4d: {{ mtable[1][2]}}\n    \"\"\"\n            {%endif%}\n        {% endfor %}\n    {# validators #}\n        {%if class_name in ['\u98ce\u529b\u53d1\u7535']%}\n    @validator(\"RatedPower\")"
        },
        {
            "comment": "The code defines a function `checkRatedPower` which checks if the CutoutPower is provided and asserts that it should be less than or equal to the rated power. It also includes a validator for percent fields, validating their values against thresholds and raising exceptions if necessary.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":749-771",
            "content": "    def checkRatedPower(cls, v, values):\n        CutoutPower = values.get('CutoutPower', None)\n        if CutoutPower is None:\n            # instead of Exception, which will make pydantic panic!\n            raise ValidationError(\"\u98ce\u529b\u53d1\u7535\u6ca1\u6709\u4f20\u5165\u5207\u51fa\u529f\u7387\")\n        else:\n            assert CutoutPower <= v, f\"\u5207\u51fa\u529f\u7387({CutoutPower})\u5fc5\u987b\u5c0f\u4e8e\u989d\u5b9a\u529f\u7387({v})\" \n        return v\n        {% endif %}\n        {# {% if percent_fields != []%}\n            {% set validate_params = \"\"%}\n            {% for field_name in percent_fields%}\n                {% set validate_params = validate_params + repr(field_name)+ \",\"%}\n            {%endfor%} #}\n        {# @validator({{validate_params}})\n        def validate_percent_fields(cls, value):\n            warning_msg = None\n            if value <= ies_env.PERCENT_WARNING_THRESHOLD:\n                warning_msg = f\"value '{value}' at field '{field_name}' passed to class '{cls.__name__}'\"\n            if warning_msg is not None:\n                if ies_env.UNIT_WARNING_AS_ERROR:\n                    raise Exception(warning_msg)"
        },
        {
            "comment": "This code is using regular expressions to find and extract parentheses from a given string. It uses the \"find_parentheses\" function to identify the start and end positions of each parenthesis pair, then appends them to a list. The list of parentheses is returned as the final result.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":772-810",
            "content": "                else:\n                    logger_print(warning_msg)\n            return value #}\n        {# {% endif %} #}\n    {% endif %}\n{% endfor %}\n####################\n# model definition #\n####################\n{# from pyomo.environ import * #}\n{# from pyomo.core.expr.sympy_tools import sympyify_expression, sympy2pyomo_expression #}\nfrom sympy.polys.polytools import Poly\nimport re\nfrom sympy import sympify\n# taking too long. recursion.\nfrom progressbar import progressbar\n{# \ndef find_parentheses(s):\n    stack = []\n    result = [] # EIPList\n    for i, c in enumerate(progressbar(s)):\n        if c == '(':\n            stack.append(i) # \u8bb0\u5f55\u5de6\u62ec\u53f7\u7684\u4f4d\u7f6e\n        elif c == ')':\n            if stack: # \u5982\u679c\u6808\u4e0d\u4e3a\u7a7a\n                start = stack.pop() # \u5f39\u51fa\u6700\u8fd1\u7684\u5de6\u62ec\u53f7\u4f4d\u7f6e\n                if not stack: # \u5982\u679c\u6808\u4e3a\u7a7a\uff0c\u8bf4\u660e\u627e\u5230\u4e86\u4e00\u4e2a\u6700\u5916\u5c42\u7684\u62ec\u53f7\u5bf9\n                    result.append(s[start:i+1]) # \u5c06\u62ec\u53f7\u5bf9\u52a0\u5165\u7ed3\u679c\u5217\u8868\n    return result #}\nfrom expr_utils import getExprStrParsedToExprList\n{# mystr = '(1,2,3), (((1+2),2),5,(6,7)) 23'\nlogger_print(find_parentheses(mystr)) #}\ndef withBanner(banner: str = \"\"):"
        },
        {
            "comment": "This code defines a decorator function that logs the execution of wrapped functions and returns their results. It then uses this decorator to create another function, examineSubExprDegree, which processes an expression string by splitting it into sub-expressions within parentheses and replacing them with unique identifiers. The processed string is stored in expr_repr for further manipulation.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":811-841",
            "content": "    def decorator(func):\n        def inner_func(*args, **kwargs):\n            logger_print(f\"_____________{banner}_____________\")\n            val = func(*args, **kwargs)\n            logger_print(f\"_____________{banner}_____________\")\n            return val\n        return inner_func\n    return decorator\n@withBanner(\"ERROR LOG\")\ndef examineSubExprDegree(expr):\n    data = str(expr)\n    exprlist = getExprStrParsedToExprList(data)\n    {# logger_print(\"SPLITING EXPR\")\n    expr_repr = str(expr)\n    regex = re.compile(r'(\\[\\d+\\])')\n    subs = regex.findall(expr_repr)\n    subs = set(subs)\n    for sub in subs:\n        num = sub.strip(\"[\").strip(\"]\")\n        expr_repr = expr_repr.replace(sub, f\"_Array\")\n    EIPList = find_parentheses(expr_repr)\n    elems_in_parentheses = set(EIPList)\n    EIPMAP = {e: f'EIP_{i}' for i, e in enumerate(elems_in_parentheses)}\n    EIPMAP_REV = {v:k for k,v in EIPMAP.items()}\n    for EIP, EIP_CODE in EIPMAP.items():\n        expr_repr = expr_repr.replace(EIP, EIP_CODE)\n    subexpr_strs = expr_repr.replace(\"-\", \"+ -\").split(\"+\") #}"
        },
        {
            "comment": "The code checks the polynomial degree of each subexpression in a list and raises an error if the degree is not 0 or 1. If such a case occurs, it logs a warning message with the abnormal subexpression and its Pyomo representation. The code uses SymPy to convert expressions to polynomials, calculate degrees, and convert back to Pyomo expressions. It also defines a macro for initializing a translation table attribute in a class.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":842-866",
            "content": "    logger_print(\"ANALYSING TERMS\")\n    for subexpr in progressbar(exprlist):\n        {# subexpr_str = subexpr_str.strip()\n        if len(subexpr_str) == 0:\n            continue\n        for k,v in EIPMAP_REV.items():\n            subexpr_str = subexpr_str.replace(k,v)\n        subexpr = sympify(subexpr_str) #}\n        subpoly = Poly(subexpr)\n        subpoly_deg = subpoly.total_degree()\n        if subpoly_deg not in [0,1]:\n            logger_print()\n            logger_print(\"Abnormal subexpression poly degree:\", subpoly_deg)\n            # recover expression representation\n            {# subexpr_pyomo = sympy2pyomo_expression(subexpr, objmap)\n            subexpr_pyomo_repr = str(subexpr_pyomo) #}\n            logger_print(\"Abnormal expression:\", subexpr)\n            {# logger_print(\"Abnormal expression:\", subexpr_pyomo_repr) #}\n    logger_print()\nfrom collections import defaultdict\n{% macro initSubmodelRelatedTranslationTable(attrName)%}\n        self._{{attrName}} = \"default{{pascalize(attrName)}}\"\n        self."
        },
        {
            "comment": "This code defines a macro for creating setter and getter methods for an attribute, along with initializing a dictionary mapping the attribute to a list of variable names. It also includes assertions to ensure that the input is a non-empty string.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":866-880",
            "content": "varNameTo{{pascalize(attrName)}} = cast(Dict[str, str], defaultdict(lambda: \"unknown{{pascalize(attrName)}}\"))\n        self.{{attrName}}ToVarName = cast(Dict[str, List[str]], defaultdict(lambda: []))\n        self.{{attrName}}ToVarName.update({self._{{attrName}}: []})\n        {# self.{{attrName}}ToVarName: Dict[str, List[str]] = {self._{{attrName}}: []} #}\n{% endmacro%}\n{% macro setupSubmodelRelatedProperty(attrName)%}\n    def set{{pascalize(attrName)}}(self, {{attrName}}:str):\n        assert isinstance({{attrName}}, str), f\"{{attrName}} must be a string!\\n{{attrName}}: {repr({{attrName}})}\"\n        assert len({{attrName}})>=1, \"zero length {{attrName}} submitted.\"\n        {{attrName}} = {{attrName}}.strip()\n        self._{{attrName}} = {{attrName}}\n        self.{{attrName}}ToVarName[{{attrName}}] = self.{{attrName}}ToVarName.get({{attrName}}, []) \n    def get{{pascalize(attrName)}}(self):\n        return self._{{attrName}}\n    {{attrName}} = property(fset=set{{pascalize(attrName)}}, fget=get{{pascalize(attrName)}})"
        },
        {
            "comment": "This code is defining two classes, SharedParams and InputParams. SharedParams contains common parameters for both calculations and inputs. InputParams inherits from SharedParams and adds calcParamList as an attribute representing a list of calculation parameters, and calcTarget to store the computation target (economic, environmental, or economic-environmental). The code also uses macros to modify submodel-related attributes and define dynamic properties. It utilizes Flashtext for keyword processing and defines literal types for certain attributes.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":881-913",
            "content": "{% endmacro%}\n{% macro modifySubmodelRelatedTranslationTable(attrName)%}\n        self.varNameTo{{pascalize(attrName)}}[name] = self.{{attrName}}\n        self.{{attrName}}ToVarName\n        self.{{attrName}}ToVarName[self.{{attrName}}].append(name)\n        self.keyword_processor.add_keyword(name)\n{% endmacro%}\n{% macro dynamicProperty(attrName)%}\n{% set getter=attrName+\"Getter\"%}\n{% set setter=attrName+\"Setter\"%}\n    def {{getter}}(self):\n        return self._{{attrName}}\n    def {{setter}}(self, val):\n        self._{{attrName}} = val\n    {{attrName}} = property(fget = {{getter}}, fset = {{setter}})\n{% endmacro%}\n{% set submodelRelatedAttrs = ['submodelName', 'submodelClassName'] %}\n{% set objectiveRelatedAttrs = ['obj', 'obj_expr'] %}\nimport flashtext\nclass SharedParams(BaseModel):\n    \u5178\u578b\u65e5: bool\n    \u8ba1\u7b97\u6b65\u957f: Literal[\"\u5c0f\u65f6\", '\u79d2']\n    \u8ba1\u7b97\u7c7b\u578b: Literal['\u4eff\u771f\u6a21\u62df', '\u8bbe\u8ba1\u89c4\u5212']\n    \u8ba1\u7b97\u76ee\u6807: Literal['\u7ecf\u6d4e','\u73af\u4fdd','\u7ecf\u6d4e_\u73af\u4fdd']\nclass InputParams(SharedParams):\n{# class InputParams(BaseModel): #}\n    calcParamList: List\n    {# calcTarget: str #}\n    {# \u5178\u578b\u65e5"
        },
        {
            "comment": "This code defines a class `ModelWrapper` that wraps around a ConcreteModel object and initializes various attributes including assumptions, keyword processor, and properties related to objective and submodel. It also includes methods for initialization, applying macros, and setting up submodel-related properties.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":914-941",
            "content": "    \u8ba1\u7b97\u6b65\u957f\n    \u8ba1\u7b97\u7c7b\u578b #}\n    rangeDict: Union[None, dict] \n    needResult: bool \n    additional_constraints: dict\nclass ModelWrapper:\n    {# __slots__ = ['obj',\"obj_expr\"] #}\n    inputParams: InputParams\n    {# inputParam: InputParams #}\n    def __init__(self, model:Optional[ConcreteModel]=None, cloned:bool = False):\n        self.model = model if model is not None else ConcreteModel()\n        self.clock = {}\n        self.cloned = cloned\n        self.assumptions: List[Callable] = []\n        self.keyword_processor = flashtext.KeywordProcessor()\n{% for objRelatedAttr in objectiveRelatedAttrs %}\n        self._{{objRelatedAttr}} = ...\n{% endfor %}\n    {# still inside __init__ method #}\n{{applyMacroWithSingleParam(initSubmodelRelatedTranslationTable, submodelRelatedAttrs)}}\n        # TODO: put assumptions into here after any operation using BigM notation (like multiplication)\n    {# still inside __init__ method #}\n{{applyMacroWithSingleParam(dynamicProperty, objectiveRelatedAttrs)}}\n{{applyMacroWithSingleParam(setupSubmodelRelatedProperty, submodelRelatedAttrs)}}"
        },
        {
            "comment": "The code defines several methods for a class. The \"check_assumptions\" method iterates through assumptions and calls each one. The \"word_counter\" method counts occurrences of keywords in a given text using the \"keyword_processor\". The \"__del__\" method deletes model, clock, and self variables when object is deleted. The \"getSpecialName\" method returns a unique name based on key and increments its value each time it's called. Lastly, the \"Disjunct\" method creates a Disjunct object with a unique name for each expression in a list and checks the polynomial degree of expressions.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":942-972",
            "content": "    def check_assumptions(self):\n        # TODO: call this function after model solved.\n        for assumption in self.assumptions:\n            assumption()\n        self.assumptions = [] # clear assumptions\n    def word_counter(self, text: str) -> Dict[str, int]:\n        keywords_found = self.keyword_processor.extract_keywords(text)\n        keyword_counts = {}\n        for keyword in keywords_found:\n            keyword_counts[keyword] = keyword_counts.get(keyword, 0) + 1\n        return keyword_counts\n    def __del__(self):\n        del self.model\n        del self.clock\n        del self\n    def getSpecialName(self, key:str):\n        val = self.clock.get(key,0)\n        name = f\"{key}_{val}\"\n        self.clock[key] = val+1\n        return name\n    def Disjunct(self, expression_disjunct:list):\n        assert isinstance(expression_disjunct, list)\n        name = self.getSpecialName(\"DJ\")\n        DJ = Disjunct()\n        for i, expr in enumerate(expression_disjunct):\n            expr_name = f\"expr_{i}\"\n            self.checkExpressionPolynomialDegree(expr, f'Disjunct_Expression_{i}')"
        },
        {
            "comment": "This code checks the polynomial degree of an expression and performs various actions based on its value. If the degree is not 1, it logs information for debugging and examines subexpressions if the degree is greater than 0.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":973-995",
            "content": "            cons = Constraint(expr = expr)\n            DJ.__setattr__(expr_name, cons)\n        self.model.__setattr__(name, DJ)\n        return DJ\n    @staticmethod\n    def checkExpressionPolynomialDegree(expr, caller):\n        deg = getattr(expr, \"polynomial_degree\", 0)\n        if deg:\n            deg = expr.polynomial_degree()\n        {# deg = expr.polynomial_degree() #}\n        if deg is None: # possibly division found\n            raise Exception(\"invalid polynomial degree for:\", expr.to_string())\n        if deg != 1:\n            logger_print(\"EXPR DEG:\", deg)\n            expr_repr =f\"{str(expr) if len(str(expr))<200 else str(expr)[:200]+'...'}\"\n            logger_print('EXPR:',  expr_repr)\n            # only if deg > 0 we need further inspection.\n            if deg >0:\n                # TODO: use regex to simplify expression here.\n                {# logger_print(\"_____________ERROR LOG_____________\") #}\n                examineSubExprDegree(expr)\n                {# logger_print(\"_____________ERROR LOG_____________\") #}"
        },
        {
            "comment": "This code defines a class with methods for handling constraints, variables, and objectives. It raises an exception if the polynomial degree of an expression is unacceptable. The class also includes a method to set attributes using setattr function.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":996-1019",
            "content": "            error_msg = f\"[{caller}] Unacceptable polynomial degree for expression.\"\n            raise Exception(error_msg)\n    def DisjunctiveConstraints(self, expression_disjunct_list:list[list]):\n        assert isinstance(expression_disjunct_list, list)\n        DJL = []\n        for expression_disjunct in expression_disjunct_list:\n            DJ = self.Disjunct(expression_disjunct)\n            DJL.append(DJ)\n        name = self.getSpecialName(\"DJV\")\n        DJV = Disjunction(expr = DJL)\n        self.model.__setattr__(name, DJV)\n        return DJV, DJL\n    {% for k in ['Constraint', 'Var','Objective']%}\n    {% set mv = \"*args, **kwargs\"%}\n    def {{k}}(self, {{ \"name:str,\" if k == \"Var\" else \"\"}} {{ mv}}):\n        {% if k !=\"Var\" %}\n        expr = kwargs.pop('expr',args[0] if len(args) >0 else None)\n        if expr is None:\n            logger_print(\"ARGS:\", args)\n            logger_print(\"KWARGS:\", kwargs)\n            raise Exception(\"Not passing expression to method '{{k}}'\")\n        self.checkExpressionPolynomialDegree(expr, caller = {{repr(k)}})"
        },
        {
            "comment": "This code snippet sets up an object based on the input argument 'k'. If 'k' is 'Var', it initializes with a value of 0 if the environment variable VAR_INIT_AS_ZERO is set. The 'Objective' function stores the returned value in self.obj and self.obj_expr. The name of the object is set using double_check_setattr with the object's model name as 'ret'.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1020-1041",
            "content": "        name = self.getSpecialName(\"{{k[:3].upper()}}\")\n        {% endif %}\n        {% set init_argname = \"initialize\"%}\n            {# {% if k == 'Var'%}\n        _{{init_argname}} = kwargs.get({{qstr(init_argname)}}, 0)\n        _{{init_argname}} = kwargs.get({{qstr(init_argname)}}, None)\n            {% endif %} #}\n        {# now we refuse to initialize anything. including var.#}\n        if {{qstr(init_argname)}} in kwargs.keys():\n            del kwargs[{{qstr(init_argname)}}]\n        {% if k == 'Var'%}\n        {# if VAR_INIT_AS_ZERO in os.environ.keys(): # test override. #}\n        if ies_env.VAR_INIT_AS_ZERO is not None:\n            kwargs[{{qstr(init_argname)}}] = 0\n        {% endif %}\n        ret = {{k}}({{mv if k == \"Var\" else \"expr = expr, *args[1:], **kwargs\"}})\n        {# ret = {{k}}({{mv+\", {}=_{}\".format(init_argname, init_argname) if k == \"Var\" else \"expr = expr, *args[1:], **kwargs\"}}) #}\n        {% if k == 'Objective'%}\n        self.obj = ret\n        self.obj_expr = expr\n        {% endif%}\n{{double_check_setattr(\"self.model\", \"name\", 'ret') | indent(2*4, true)}}"
        },
        {
            "comment": "The code defines a class called `\u8ba1\u7b97\u53c2\u6570` (ComputationParameters) that inherits from `SharedParams`. It includes attributes such as `\u5178\u578b\u65e5ID`, `\u8ba1\u7b97\u6b65\u957f`, and `\u5206\u65f6\u8ba1\u4ef7\u5f00\u59cb\u65f6\u95f4\u70b9`. The class also has a validator function for `\u5206\u65f6\u8ba1\u4ef7\u5f00\u59cb\u65f6\u95f4\u70b9` to ensure the value is within the expected range.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1042-1074",
            "content": "{{applyMacroWithSingleParam(modifySubmodelRelatedTranslationTable, submodelRelatedAttrs)}}\n        {# self.model.__setattr__(name, ret) #}\n        return ret\n    {% endfor%}\n    def Block(self, model:Optional[ConcreteModel]=None, cloned:bool = False):\n        wrapper = ModelWrapper(model, cloned=cloned)\n        name = self.getSpecialName(\"BLK\")\n        self.model.__setattr__(name, wrapper.model)\n{{applyMacroWithSingleParam(modifySubmodelRelatedTranslationTable, submodelRelatedAttrs)}}\n        return wrapper\n# first convert the unit.\n# assign variables.\n# shall you assign port with variables.\n# \u98ce\u3001\u5149\u7167\n# \u9700\u8981\u660e\u786e\u5355\u4f4d\n{# class \u8ba1\u7b97\u53c2\u6570(BaseModel): #}\nclass \u8ba1\u7b97\u53c2\u6570(SharedParams):\n    \u5178\u578b\u65e5ID: Union[{{non_neg_int}}, None] = None # increse by external loop\n    {# \u8ba1\u7b97\u6b65\u957f: Literal[\"\u5c0f\u65f6\", '\u79d2'] #}\n    {# \u5178\u578b\u65e5: bool #}\n    \u5206\u65f6\u8ba1\u4ef7\u5f00\u59cb\u65f6\u95f4\u70b9: float = Field(default=0, title = '\u79d2\u7ea7\u4eff\u771f\u65f6 \u5f00\u59cb\u65f6\u95f4\u5728\u4e00\u5929\u4e2d\u7684\u54ea\u4e2a\u5c0f\u65f6', description=f\"\u53d6\u503c\u8303\u56f4: 0-{\u6bcf\u5929\u5c0f\u65f6\u6570}\", ge=0, le=\u6bcf\u5929\u5c0f\u65f6\u6570)\n    {# @validator('\u5206\u65f6\u8ba1\u4ef7\u5f00\u59cb\u65f6\u95f4\u70b9')\n    def validate_starting_time(cls, v):\n        assert v>=0, f\"\u5f00\u59cb\u65f6\u95f4\u70b9\u5927\u4e8e\u7b49\u4e8e0\\n\u5b9e\u9645: {v}\""
        },
        {
            "comment": "The code defines fields for various parameters like start time, starting month, typical day weight, and computation type. It also includes validators to ensure these parameters meet certain conditions before processing further. The wind speed and light intensity are also defined with specifications on their units.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1075-1105",
            "content": "        assert v<=24, f\"\u5f00\u59cb\u65f6\u95f4\u70b9\u5c0f\u4e8e\u7b49\u4e8e24\\n\u5b9e\u9645: {v}\"\n        return v #}\n    \u5206\u65f6\u8ba1\u4ef7\u5f00\u59cb\u6708\u4efd: int = Field(default=0, title = '\u79d2\u7ea7\u4eff\u771f\u65f6 \u5f00\u59cb\u65f6\u95f4\u5728\u4e00\u5e74\u4e2d\u7684\u54ea\u4e2a\u6708\u4efd', description=\"\u53d6\u503c\u8303\u56f4: 0-11\", le=11, ge=0)\n    {# @validator('\u5206\u65f6\u8ba1\u4ef7\u5f00\u59cb\u6708\u4efd')\n    def validate_starting_month(cls, v):\n        assert v>=0, f\"\u5f00\u59cb\u6708\u4efd\u5927\u4e8e\u7b49\u4e8e0\\n\u5b9e\u9645: {v}\"\n        assert v<=11, f\"\u5f00\u59cb\u6708\u4efd\u5c0f\u4e8e\u7b49\u4e8e11\\n\u5b9e\u9645: {v}\"\n        return v\n     #}\n    {# \u5178\u578b\u65e5\u6743\u91cd: int = 0 #}\n    \u5178\u578b\u65e5\u4ee3\u8868\u7684\u65e5\u671f: conlist(conint(ge=0, lt=365), min_items=0, max_items=365, unique_items=True)= []\n    @validator('\u5178\u578b\u65e5\u4ee3\u8868\u7684\u65e5\u671f')\n    def validate_typical_day(cls, v, values):\n        if values['\u5178\u578b\u65e5']:\n            len_v = len(v)\n            assert len_v >0\n            assert len_v <= 365\n            {# if len_v <= 0:\n                raise ValidationError(f\"\u5178\u578b\u65e5\u4ee3\u8868\u65e5\u671f\u4e0d\u5e94\u5c0f\u4e8e\u7b49\u4e8e0\\n\u5b9e\u9645\u957f\u5ea6\uff1a{len_v}\")\n            if len_v  >365:\n                raise ValidationError(f\"\u5178\u578b\u65e5\u4ee3\u8868\u65e5\u671f\u4e0d\u5e94\u5927\u4e8e365\\n\u5b9e\u9645\u957f\u5ea6\uff1a{len_v}\") #}\n        return v\n    {# \u8ba1\u7b97\u7c7b\u578b: Literal['\u4eff\u771f\u6a21\u62df', '\u8bbe\u8ba1\u89c4\u5212'] #}\n    {# \u8ba1\u7b97\u76ee\u6807: Literal['\u7ecf\u6d4e','\u73af\u4fdd','\u7ecf\u6d4e_\u73af\u4fdd'] #}\n    \u98ce\u901f: List[{{non_neg_float}}]\n    \"\"\"\n    \u5355\u4f4d: m/s\n    \"\"\"\n    \u5149\u7167: List[{{non_neg_float}}]"
        },
        {
            "comment": "This code defines a class with properties for temperature, discount rate, and calculation step settings. The iteration steps are determined based on the computation step length, whether it's in seconds or hours, and whether it represents a typical day. It also checks the lengths of lists for wind speed, light intensity, and temperature to ensure they match the iteration steps. The time parameter property returns the number of calculation steps per hour depending on the computation step length.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1106-1150",
            "content": "    \"\"\"\n    \u5355\u4f4d: kW/m2\n    \"\"\"\n    \u6c14\u6e29: List[{{non_neg_float}}]\n    \"\"\"\n    \u5355\u4f4d: \u6444\u6c0f\u5ea6\n    \"\"\"\n    \u8d34\u73b0\u7387: confloat(ge=0, le=100) = Field(title = \"\u8d34\u73b0\u7387\", description = \"\u5355\u4f4d: percent\")\n    {# \u5e74\u5229\u7387: float #}\n    \"\"\"\n    \u5355\u4f4d: percent\n    \"\"\"\n    @property\n    def \u8fed\u4ee3\u6b65\u6570(self):\n        {# steps = None #}\n        if self.\u8ba1\u7b97\u6b65\u957f == \"\u79d2\":\n            steps = \u4e24\u5c0f\u65f6\u79d2\u6570\n        elif self.\u8ba1\u7b97\u6b65\u957f == \"\u5c0f\u65f6\" and self.\u5178\u578b\u65e5 is False:\n            steps = \u6bcf\u5e74\u5c0f\u65f6\u6570\n        elif self.\u8ba1\u7b97\u6b65\u957f == \"\u5c0f\u65f6\" and self.\u5178\u578b\u65e5 is True:\n            steps = \u6bcf\u5929\u5c0f\u65f6\u6570\n        else:\n            logger_print(self)\n            raise Exception(\"\u672a\u77e5\u8ba1\u7b97\u53c2\u6570\")\n        errors = []\n        {% for t in ['\u98ce\u901f','\u5149\u7167','\u6c14\u6e29']%}\n        if not len(self.{{t}}) == steps:\n            errors.append(f'{{t}}\u957f\u5ea6\u5e94\u8be5\u662f{steps} \u5b9e\u9645:{len(self.{{t}})}')\n        {% endfor%}\n        if errors:\n            raise Exception(\"\\n\".join(errors))\n        return steps\n    {# @lru_cache(maxsize=1) #}\n    @property\n    def \u65f6\u95f4\u53c2\u6570(self):\n        \"\"\"\n        \u5982\u679c\u8ba1\u7b97\u6b65\u957f\u4e3a\u79d2\uff0c\u90a3\u4e48\u8fd4\u56de3600\n        \u5982\u679c\u8ba1\u7b97\u6b65\u957f\u4e3a\u5c0f\u65f6\uff0c\u90a3\u4e48\u8fd4\u56de1\n        \u76f8\u5f53\u4e8e\u8fd4\u56de\u4e00\u5c0f\u65f6\u5185\u6709\u591a\u5c11\u8ba1\u7b97\u6b65\u957f\n        \"\"\"\n        return (1 if self.\u8ba1\u7b97\u6b65\u957f == \"\u5c0f\u65f6\" else \u6bcf\u5c0f\u65f6\u79d2\u6570)"
        },
        {
            "comment": "This code defines two classes, one for storing simulation parameters and another for representing financial parameters. The first class has properties to calculate the time step and total computation time based on iteration steps and time parameters. It also has a method to generate typical day data. The second class represents financial parameters such as total purchase cost and maintenance costs, and implements a Protocol interface with methods for validation.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1152-1199",
            "content": "    @property\n    def deltaT(self):\n        \"\"\"\n        \u5982\u679c\u8ba1\u7b97\u6b65\u957f\u4e3a\u79d2\uff0c\u90a3\u4e48\u8fd4\u56de1/3600\n        \u5982\u679c\u8ba1\u7b97\u6b65\u957f\u4e3a\u5c0f\u65f6\uff0c\u90a3\u4e48\u8fd4\u56de1\n        \u76f8\u5f53\u4e8e\u8fd4\u56de\u4e00\u4e2a\u8ba1\u7b97\u6b65\u957f\u5185\u6709\u591a\u5c11\u5c0f\u65f6\n        \"\"\"\n        return (1/self.\u65f6\u95f4\u53c2\u6570)\n    @property\n    def \u603b\u8ba1\u7b97\u65f6\u957f(self):\n        \"\"\"\n        \u8fd4\u56de\u8be5\u8ba1\u7b97\u6a21\u5f0f\u4e0b\u603b\u5171\u6709\u591a\u5c11\u5c0f\u65f6\n        \"\"\"\n        return self.\u8fed\u4ee3\u6b65\u6570 / self.\u65f6\u95f4\u53c2\u6570\n    {# @property # \u63d0\u524d\u8ba1\u7b97\u597d\u4e86\n    def \u5178\u578b\u65e5\u5217\u8868(self): # \n        ... #}\n    {# # like: (tday_index, tday_data, tday_count) #}\nclass POSNEG:\n        {% set POSNEGParamNames = [\"x\", \"x_pos\", \"x_neg\", \"b_pos\", \"b_neg\", \"x_abs\"] %}\n    def __init__(self, {{\",\".join(POSNEGParamNames)}}):\n        {%for f in POSNEGParamNames%}\n        self.{{f}} = {{f}}\n        {%endfor%}\n{# from functools import reduce #}\n{# import functools #}\n{% set financial_param_names = [\n            \"\u603b\u91c7\u8d2d\u6210\u672c\",\n            \"\u603b\u5efa\u8bbe\u8d39\u7528\",\n            \"\u603b\u56fa\u5b9a\u7ef4\u62a4\u6210\u672c\",\n            \"\u603b\u56fa\u5b9a\u6210\u672c\u5e74\u5316\",\n            \"\u603b\u6210\u672c\u5e74\u5316\",\n            \"\u603b\u53ef\u53d8\u7ef4\u62a4\u6210\u672c\u5e74\u5316\"\n        ]\n%}\n{{import_type_fallback(\"Protocol\")}}\nclass \u53ef\u8d2d\u4e70\u7c7b(Protocol):\n    \u662f\u5426\u8d2d\u4e70: ...\n    {% for e0 in financial_param_names%}\n    {{e0}}: ...\n    {% endfor%}\n    def BinVarMultiplySingle(self, *args, **kwargs): ..."
        },
        {
            "comment": "Class \"\u8bbe\u5907\u6a21\u578b\" initializes a device model with given Power Distribution (PD), ModelWrapper (mw), \u8ba1\u7b97\u53c2\u6570\u5b9e\u4f8b (\u8ba1\u7b97\u53c2\u6570\u5b9e\u4f8b), and ID. It sets various attributes including BigM, EPS, financial parameters to zero, and yearly rate. The class also includes methods TimeSummation for time-based summation and Interpolate1D for one-dimensional interpolation.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1201-1235",
            "content": "class \u8bbe\u5907\u6a21\u578b:\n    def __init__(self, PD: dict, mw: ModelWrapper, \u8ba1\u7b97\u53c2\u6570\u5b9e\u4f8b: \u8ba1\u7b97\u53c2\u6570, ID: int):\n        logger_print(\"Building Device Model:\", submodelClassName:=self.__class__.__name__)\n        submodelName = f\"{submodelClassName}_{ID}\"\n        self.mw = mw\n{% for attrName in submodelRelatedAttrs %}\n        self.mw.{{attrName}} = {{attrName}}\n{% endfor%}\n        self.PD = PD\n        self.\u8ba1\u7b97\u53c2\u6570 = \u8ba1\u7b97\u53c2\u6570\u5b9e\u4f8b\n        self.ID = ID\n        self.SID = 0\n        {# self.BigM = 1e+8  #}\n        self.BigM = 1e+7 # \u8fd9\u4e2a\u6570\u4e0d\u80fd\u592a\u5927 \u5426\u5219\u5c31\u4f1a\u62a5\u9519\n        {# self.BigM = 1e+12 #}\n        \"\"\"\n        \u4e00\u4e2a\u6781\u5927\u6570\n        \"\"\"\n        self.EPS = 1e-4\n        {# usually you want to use it in initialization, not constraints! #}\n        \"\"\"\n        \u4e00\u4e2a\u6781\u5c0f\u6570\n        \"\"\"\n        {% for e0 in financial_param_names %}\n        self.{{e0}} = 0\n        {% endfor %}\n        self.\u5e74\u5316\u7387 = ...\n    def TimeSummation(self, target:list, source, mrange = None):\n        mrange = self.getRange(mrange)\n        for i in mrange:\n            target[i]+= source[i]\n        return target\n    def Interpolate1D(self, marray:list[float], points = 10):"
        },
        {
            "comment": "The code defines a function `Interpolate2D` that interpolates 2D data and returns the interpolated values. It also contains an undefined method `\u5904\u7406\u6700\u7ec8\u8d22\u52a1\u8f93\u51fa`, which seems to manipulate financial outputs, and a class-specific method `constraints_register`. The latter should be implemented by subclasses according to the NotImplementedError message.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1236-1262",
            "content": "        d = marray\n        interp_d = []\n        for d_start, d_end in zip(d[:-1], d[1:]):\n            sample = np.linspace(d_start, d_end, points).tolist()\n            interp_d += sample[0 if len(interp_d) == 0 else 1:]\n        return interp_d\n    def Interpolate2D(self, marray:list[list[float]], points = 10):\n        dim_count = len(marray[0])\n        dims = [[v[i] for v in marray] for i in range(dim_count)]\n        interp_dims = []\n        for d in dims:\n            interp_d = self.Interpolate1D(d, points = points)\n            interp_dims.append(interp_d)\n        ret = [tuple(it) for it in zip(*interp_dims)]\n        return ret\n    @staticmethod\n    def \u5904\u7406\u6700\u7ec8\u8d22\u52a1\u8f93\u51fa(mclass: \u53ef\u8d2d\u4e70\u7c7b):\n        {% for e0 in financial_param_names%}\n        mclass.{{e0}} = mclass.BinVarMultiplySingle(mclass.\u662f\u5426\u8d2d\u4e70, mclass.{{e0}})\n        {% endfor %}\n    def constraints_register(self):\n        if self.__class__.__name__ == \"\u8bbe\u5907\u6a21\u578b\":\n            raise NotImplementedError(\"Must be implemented by subclasses.\")\n        logger_print(\"REGISTERING: \", self.__class__.__name__)"
        },
        {
            "comment": "This code defines several methods for creating and managing variables in a microgrid simulation. It generates variable names based on specific identifiers, allows defining single or multiple variables with optional ranges and keyword arguments, and supports different types of constraints (DisjunctiveConstraints and Constraint). The code also provides functions to set the range of variables and create variable lists for specific use cases.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1264-1289",
            "content": "    def getVarName(self, varName: str):\n        VN = f\"DI_{self.ID}_VN_{varName}\" # use underscore.\n        if self.\u8ba1\u7b97\u53c2\u6570.\u5178\u578b\u65e5ID is not None: # starting from 0, so be careful!\n            VN = f\"TD_{self.\u8ba1\u7b97\u53c2\u6570.\u5178\u578b\u65e5ID}_\"+VN\n        return VN\n    def getSpecialVarName(self, varName:str):\n        specialVarName = f\"SP_{self.SID}_{varName}\"\n        self.SID +=1\n        return specialVarName\n    def \u5355\u53d8\u91cf(self, varName: str, **kwargs):\n        var = self.mw.Var(self.getVarName(varName) ,**kwargs)\n        return var\n    def getRange(self, mrange:range = None):\n        if mrange is None: mrange = range(self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570)\n        return mrange\n    def \u53d8\u91cf\u5217\u8868(self, varName: str, mrange:range = None, **kwargs):\n        var = self.mw.Var(self.getVarName(varName) ,self.getRange(mrange), **kwargs)\n        return var\n    {% for kr, vr_l in dict(Normal=('mrange:range=None',\"self.getRange(mrange)\"),Custom = ('customRange:range=...', 'customRange')).items()%}\n        {% set vr = vr_l[0]%}\n        {% set vs = vr_l[1]%}\n        {% for k,v in dict(Disjunctive = 'DisjunctiveConstraints', Normal = 'Constraint').items()%}"
        },
        {
            "comment": "This code defines several RangeConstraint functions for different types of constraints, such as Normal, Custom, and Multi. It takes in a pair or list of variables and an expression, and returns a list of values based on the given expression applied to each element of the input variables. It also includes additional helper functions like SumRange and \u5355\u53d8\u91cf\u8f6c\u5217\u8868 for summing ranges and converting single variables into lists.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1290-1313",
            "content": "            {% for k0, v0 in dict(Pair = (\"var_1, var_2\", \"var_1[i], var_2[i]\", \"var_1, var_2, i\"), Multi = ('*vars', '*[var[i] for var in vars]', \"*vars, i\")).items()%}\n                {% set v0_0 = v0[0] %}\n                {% set v0_1 = v0[1] %}\n                {% set v0_2 = v0[2] %}\n    def {{kr if kr =='Custom' else ''}}{{k if k == 'Disjunctive' else ''}}RangeConstraint{{k0 if k0 == 'Multi' else ''}}(self, {{v0_0}}, expression = ..., {{vr}}):\n                {% if kr == 'Custom'%}\n        assert customRange is not ...\n                {% endif%}\n        assert expression is not ...\n        ret_list = []\n        for i in {{vs}}:\n            ret_elem = self.mw.{{v}}(expression({{v0_1 if kr == 'Normal' else v0_2}}))\n            ret_list.append(ret_elem)\n        return ret_list\n            {% endfor %}\n        {% endfor %}\n    {% endfor%}\n    def SumRange(self,var_1,  mrange:range=None):\n        return {{- sum_reduce('[var_1[i] for i in self.getRange(mrange)]')}}\n    def \u5355\u53d8\u91cf\u8f6c\u5217\u8868(self, var,  dup:int=None):\n        if dup is None:"
        },
        {
            "comment": "This code defines several methods: `\u8ba1\u7b97\u53c2\u6570`, `\u5355\u8868\u8fbe\u5f0f\u751f\u6210\u6307\u793a\u53d8\u91cf`, and `\u53d8\u91cf\u5217\u8868_\u5e26\u6307\u793a\u53d8\u91cf`. The first method calculates a parameter, the second generates a variable with an expression, and the third creates a list of variables with optional indicators. These methods use lists, ranges, and various constraints to manipulate and create these variables. The code includes type hints and uses lambda functions for certain operations.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1314-1335",
            "content": "            dup = self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570\n        return [var for _ in range(dup)]\n    def \u5355\u8868\u8fbe\u5f0f\u751f\u6210\u6307\u793a\u53d8\u91cf(self, varName: str, expr):\n        # where to exclude type from type hints?\n        # or what language can express type exclusion?\n        posneg = self.\u53d8\u91cf\u5217\u8868_\u5e26\u6307\u793a\u53d8\u91cf(varName, exprList=[expr], mrange = range(1))\n        ret = POSNEG(posneg.x[0], posneg.x_pos[0], posneg.x_neg[0], posneg.b_pos[0], posneg.b_neg[0], posneg.x_abs[0])\n        return ret\n    def \u53d8\u91cf\u5217\u8868_\u5e26\u6307\u793a\u53d8\u91cf(self, varName:str,  exprList:list=None, within= Reals, mrange:range=None) -> POSNEG:\n        # can replace with disjunctions\n        if exprList:\n            x = exprList\n        else:\n            x = self.\u53d8\u91cf\u5217\u8868(varName,within=within, mrange = mrange)\n        {% for flag in ['pos', 'neg'] %}\n        b_{{flag}} = self.\u53d8\u91cf\u5217\u8868(self.getSpecialVarName(varName), within = Boolean, mrange = mrange)\n        x_{{flag}} = self.\u53d8\u91cf\u5217\u8868(self.getSpecialVarName(varName), within = NonNegativeReals, mrange = mrange)\n        self.RangeConstraint(b_{{flag}}, x_{{flag}}, lambda x,y: x*self.BigM >= y, mrange = mrange)"
        },
        {
            "comment": "This code defines two functions, `RangeConstraintMulti` and `DisjunctivePair`, which implement constraint rules for microgrid optimization. The code sets lower and upper bounds on variables, creates disjunctions, and applies constraints using lambda expressions. It uses the `self.getSpecialVarName` function to define variable names.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1336-1367",
            "content": "        {% endfor %}\n        self.RangeConstraint(b_pos, b_neg, lambda x,y: x+y == 1, mrange = mrange)\n        self.RangeConstraintMulti(x, x_pos, x_neg, expression = lambda x,y,z: x == y-z , mrange = mrange)\n        x_abs = self.\u53d8\u91cf\u5217\u8868(self.getSpecialVarName(varName), within = NonNegativeReals, mrange = mrange)\n        self.RangeConstraintMulti(x_pos, x_neg, x_abs, expression = lambda x,y,z : z == x+y, mrange = mrange)\n        posneg = POSNEG(x, x_pos, x_neg, b_pos, b_neg, x_abs)\n        return posneg\n    def DisjunctivePair(self, x_var, y_var, x_vals:List[float], y_vals:List[float]):\n        assert len(x_vals) == len(y_vals)\n        DJL = []\n        x_lb, x_ub = min(x_vals), max(x_vals)\n        y_lb, y_ub = min(y_vals), max(y_vals)\n        for (x_value, y_value) in zip(x_vals, y_vals):\n            disjunct_name = self.getSpecialVarName(\"DJ\")\n            DJ = Disjunct()\n            x_var.setlb(x_lb)\n            x_var.setub(x_ub)\n            y_var.setlb(y_lb)\n            y_var.setub(y_ub)\n            DJ.cons_x = Constraint(expr = x_var == x_value)"
        },
        {
            "comment": "The code defines functions to create and handle disjunctions and piecewise pairs in a model. It generates lists of disjunctive variables and creates corresponding disjunctions, with the ability to handle ranges. The PiecewisePair function handles piecewise representations, allowing for different types of constraints (EQ or UN) and options for unbounded domains and domain coverage warnings.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1368-1392",
            "content": "            DJ.cons_y = Constraint(expr = y_var == y_value)\n{{double_check_setattr(\"self.mw.model\", \"disjunct_name\", \"DJ\") | indent(3*4, true)}}\n            DJL.append(DJ)\n        disjunctive_name = self.getSpecialVarName(\"DJV\")\n        DJV = Disjunction(expr = DJL)\n{{double_check_setattr(\"self.mw.model\", \"disjunctive_name\", \"DJV\") | indent(2*4, true)}}\n        return DJL, DJV\n    def DisjunctivePairList(self, x_var_list, y_var_list, x_vals:List[float], y_vals:List[float], range_list:Union[List[int], None]=None, \n    ):\n        # TODO: detect and transform model if disjuction is detected in model components\n        range_list = self.getRangeList(range_list)\n        DJV_LIST = []\n        for i in range_list:\n            _, DJV = self.DisjunctivePair(x_var_list[i], y_var_list[i], x_vals, y_vals)\n            DJV_LIST.append(DJV)\n        return DJV_LIST\n    def PiecewisePair(self, x_var, y_var, \n        x_vals: List[float],\n        y_vals: List[float], \n     pw_repn='MC',\n     pw_constr_type='EQ', unbounded_domain_var=True, warn_domain_coverage=False, preprocessed = False):"
        },
        {
            "comment": "This function takes x_vals and y_vals as inputs, checks if preprocessed, then preprocesses the data by expanding it, returns the processed data and creates a Piecewise object. The PreprocessPiecewiseValueList method expands the input lists and the getRangeList method retrieves a range list from an instance's property. The code appears to be related to piecewise functions in a larger context.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1393-1426",
            "content": "        if not preprocessed:\n            _x_vals,_y_vals = self.PreprocessPiecewiseValueList(x_vals, y_vals)\n        else:\n            _x_vals,_y_vals = x_vals, y_vals\n        piecewise_name = self.getSpecialVarName(\"PW\")\n        PW = Piecewise(\n        y_var,\n        x_var,\n        pw_pts=_x_vals,\n        f_rule=_y_vals,\n        pw_repn=pw_repn,\n        pw_constr_type=pw_constr_type,\n        unbounded_domain_var=unbounded_domain_var,\n        warn_domain_coverage=warn_domain_coverage, # to suppress warning\n    )\n{{double_check_setattr(\"self.mw.model\", \"piecewise_name\", \"PW\") | indent(2*4, true)}}\n        return PW\n    @staticmethod\n    def PreprocessPiecewiseValueList(\n        x_vals: List[float],\n        y_vals: List[float],\n        expand_val = 1e+3\n        ):\n        assert x_vals[0] <= x_vals[-1]\n        _x_vals = [x_vals[0]-expand_val] + x_vals +[ x_vals[-1]+expand_val]\n        _y_vals = [y_vals[0]] + y_vals +[ y_vals[-1]]\n        return _x_vals, _y_vals\n    def getRangeList(self, range_list):\n        if range_list is None:"
        },
        {
            "comment": "This code defines a function called \"Piecewise\" that takes input variables, value lists, and optional range list to create piecewise functions or stepwise functions. The code also mentions potential performance overhead with \"MC\" piecewise functions and a bug related to out of bound x-values causing unsolvable problems. Additionally, the code mentions preprocessing for piecewise values and creating PiecewisePair objects within a loop.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1427-1460",
            "content": "            range_list = list(range(self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570))\n        return range_list\n    def Piecewise(self, \n        x_var,\n        y_var,\n        x_vals: List[float],\n        y_vals: List[float],\n     range_list:Union[List[int], None]=None, \n     pw_repn='MC',\n     pw_constr_type='EQ', unbounded_domain_var=True, warn_domain_coverage=False):\n        # TODO: if performance overhead is significant, shall use \"MC\" piecewise functions, or stepwise functions.\n        x_var_list = x_var\n        y_var_list = y_var\n        # BUG: x out of bound, resulting into unsolvable problem.\n        _x_vals, _y_vals = self.PreprocessPiecewiseValueList(x_vals, y_vals)\n        range_list = self.getRangeList(range_list)\n        PWL = []\n        for i in range_list:\n            PW = self.PiecewisePair(\n            x_var_list[i],\n            y_var_list[i],\n            x_vals=_x_vals,\n            y_vals=_y_vals,\n            pw_repn=pw_repn,\n            pw_constr_type=pw_constr_type,\n            unbounded_domain_var=unbounded_domain_var,\n            warn_domain_coverage = warn_domain_coverage,"
        },
        {
            "comment": "The code consists of several methods. The first method, \"breakdownExpression\", is used to decompose a given expression into its linear and non-linear components. It checks the type of the input expression and returns linear results if it's a linear expression; otherwise, it raises an exception for nonlinear expressions. If the expression is a number or a variable, it appends it directly to the results list. The second method, \"BinVarMultiplySingle\", multiplies a binary variable (b_var) by another variable (x_var). It has an optional parameter, recurse, which if set to True, will recursively call itself for any non-linear terms in b_var or x_var. The last method, \"preprocessed\", seems to be a flag indicating whether the code is preprocessed or not.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1461-1491",
            "content": "            preprocessed = True\n        )\n            PWL.append(PW)\n        return PWL\n    @staticmethod\n    def breakdownExpression(expr):\n        expr_type = type(expr)\n        assert expr_type != {{IndexedVar}}, f\"Expression: {repr(expr)[:200]}\\nInvalid expression type.\"\n        {# numeric_types = [float, int]\n        variable_types = [ScalarVar, {{GeneralVarData}}] #}\n        # otherwise, expression types.\n        {# results = [] #}\n        is_linear, results = pyomo.core.expr.current.decompose_term(expr)\n        if is_linear:\n            return results\n        else:\n            examineSubExprDegree(expr)\n            raise Exception(f\"Nonlinear expression found while breaking down.\\nExpression type: {type(expr)}\")\n        {# if expr_type in numeric_types:\n            results.append((expr))\n        else:\n            # implement expression breakdown. usually pyomo expressions.\n            try:\n                results.append(...)\n            except:\n                ... #}\n    def BinVarMultiplySingle(self, b_var, x_var,  recurse=True):"
        },
        {
            "comment": "This function takes two input variables: a binary variable and a continuous variable. It checks if the binary variable is indeed binary, and ensures that the continuous variable is not an IndexedVar or a binary variable itself (can be binary). The function then discusses two approaches to avoid overflow issues, suggesting either dividing by a number first or handling summation expressions elementwise before summing them up. If `recurse` is True, the function performs recursion to handle more complex expressions. It also mentions preserving BigMs in the process. The function handles tuples containing two elements (asserting that the tuple length is exactly 2).",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1492-1514",
            "content": "    {# def BinVarMultiplySingle(self, b_var, x_var, recurse=False): #}\n        assert b_var.is_binary()\n        assert type(x_var) is not {{IndexedVar}}\n        {# assert x_var.is_continuous()  #}\n        {# x_var can be binary. #}\n        {# to eliminate the issue of overflow: #}\n        {# approach 1: first divide variable by some number, then multiply by that. (not working) #}\n        {# approach 2: if the variable/expression is summation, execute the function elementwise then sum them up. #}\n        {# if using APP2, shall do recursion. #}\n        {# and mind all occurance of BigMs #}\n        numeric_types = [float, int]\n        if recurse:\n            # tear down x_var\n            h_list = []\n            for sub_x_var in self.breakdownExpression(x_var):\n                _h = self.BinVarMultiplySingle(b_var,sub_x_var, recurse=False)\n                h_list.append(_h)\n            return sum(h_list)\n        else:\n            if type(x_var) == tuple:\n                assert len(x_var) == 2, f\"Invalid `x_var`: {x_var}\""
        },
        {
            "comment": "This code defines a function that creates a constraint for a variable 'h' based on another variable 'b_var'. It checks if 'x_var' is a constant or a numeric variable, and applies constraints accordingly. The purpose seems to be solving an optimization problem involving these variables in a microgrid context.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1515-1537",
            "content": "                # format: (factor, x_var)\n                assert type(x_var[0]) in [float, int], f\"Invalid `x_var` format: {x_var}\\nShould be: (factor (float), x_var (Var))\"\n                factor, _x_var = x_var\n                if _x_var is None: # constant.\n                    return factor * b_var\n            else:\n                factor = 1\n                _x_var = x_var\n                if type(_x_var) in numeric_types:\n                    return _x_var * b_var\n            h = self.\u5355\u53d8\u91cf(self.getSpecialVarName(\"BVM\"), within=Reals)\n            {# divider = 1e+2 #}\n            self.mw.Constraint(h <= b_var * self.BigM)\n            self.mw.Constraint(h >= -b_var * self.BigM)\n            {# self.mw.Constraint(h <= x_var/divider+(1-b_var)*self.BigM)\n            self.mw.Constraint(h >= x_var/divider-(1-b_var)*self.BigM) #}\n            self.mw.Constraint(h <= _x_var+(1-b_var)*self.BigM)\n            self.mw.Constraint(h >= _x_var-(1-b_var)*self.BigM)\n            return h * factor\n        {# return h*divider #}"
        },
        {
            "comment": "This function performs a continuous multiplication of two variables and calculates the squares of their sum and difference. It asserts that both variables are not binary, creates positive and negative variables for each multiplication case, adds range constraints based on these variables, and defines lower and upper bounds for further calculations.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1539-1557",
            "content": "    def Multiply(self,dict_mx:dict, dict_my:dict, varName:str,  precision = 10, within = Reals): # two continuous multiplication\n        #  (x+y)^2 - (x-y)^2 = 4xy\n        mx, max_mx, min_mx = dict_mx['var'], dict_mx['max'], dict_mx['min']\n        my, max_my, min_my = dict_my['var'], dict_my['max'], dict_my['min']\n        assert not mx[0].is_binary()\n        assert not my[0].is_binary()\n        m1posneg = self.\u53d8\u91cf\u5217\u8868_\u5e26\u6307\u793a\u53d8\u91cf(self.getSpecialVarName(varName))\n        self.RangeConstraintMulti(m1posneg.x, mx, my , expression = lambda x,y,z: x == y+z)\n        mx_my_sum_var = m1posneg.x_abs\n        mx_my_sum_pow2_var = self.\u53d8\u91cf\u5217\u8868(self.getSpecialVarName(varName))\n        m2posneg = self.\u53d8\u91cf\u5217\u8868_\u5e26\u6307\u793a\u53d8\u91cf(self.getSpecialVarName(varName))\n        self.RangeConstraintMulti(m2posneg.x, mx, my, expression = lambda x,y,z: x == y-z)\n        mx_my_minus_var = m2posneg.x_abs\n        mx_my_minus_pow2_var = self.\u53d8\u91cf\u5217\u8868(self.getSpecialVarName(varName))\n        l0, r0 = min_mx + min_my, max_mx+max_my\n        l1, r1 = min_mx - max_my, max_mx-min_my"
        },
        {
            "comment": "This code defines a function `getBound` to obtain lower and upper bounds for linear interpolation, and then computes the squares of these values. It creates two lists of these squared values (`mx_my_sum_pow2`, `mx_my_minus_pow2`) and passes them along with variable names to `Piecewise` constraints. Finally, it creates another constraint by multiplying variables together in a list (`mx_my_multiply`) and applies the RangeConstraintMulti function. The function returns `mx_my_multiply`.\n\nCode review:\n\nThe code seems well-structured and easy to read. However, some improvements could be made for better clarity and efficiency. \n\n1. In the `getBound` function, it would be helpful to rename the parameters from `l0`, `r0`, etc., to something more descriptive, like `lower_bound`, `upper_bound`, etc. This can make the code more self-explanatory and reduce confusion when reading or debugging.\n2. In the line `self.Piecewise(x_var = mx_my_sum_var, y_var = mx_my_sum_pow2_var, x_vals = mx_my_sum, y_vals = mx_my_sum_pow2)`, there seems to be a typo: `mx_my_sum_var` should probably be `mx_my_sum_pow2_var`.\n3. The variable names (`l0`, `r0`, etc.) are not very descriptive and could benefit from more meaningful names that convey their purpose or values.\n4. It would also be beneficial to provide comments explaining the purpose of each function, constraint, and list in the code, particularly for readers unfamiliar with this specific programming language or context.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1558-1585",
            "content": "        def getBound(l0, r0):\n            if l0*r0 >=0:\n                l0,r0 = abs(l0), abs(r0)\n                l, r = min([l0, r0]), max([l0, r0])\n            else:\n                l0, r0 = abs(l0), abs(r0)\n                l, r = 0, max([l0, r0])\n            return l, r\n        mx_my_sum = np.linspace(*getBound(l0, r0), precision).tolist()\n        mx_my_sum_pow2 = [x**2 for x in mx_my_sum]\n        mx_my_minus = np.linspace(*getBound(l1, r1), precision).tolist()\n        mx_my_minus_pow2 = [x**2 for x in mx_my_minus]\n        self.Piecewise(x_var = mx_my_sum_var, y_var = mx_my_sum_pow2_var, x_vals = mx_my_sum, y_vals = mx_my_sum_pow2) # assume it is absolute.\n        self.Piecewise(x_var = mx_my_minus_var, y_var = mx_my_minus_pow2_var, x_vals = mx_my_minus, y_vals = mx_my_minus_pow2)\n        mx_my_multiply = self.\u53d8\u91cf\u5217\u8868(varName, within=within)\n        self.RangeConstraintMulti(mx_my_sum_pow2_var, mx_my_minus_pow2_var, mx_my_multiply, expression =  lambda x,y,z:(x-y)/4 == z)\n        return mx_my_multiply\n{% for super_class, class_name, mstrs, mdigits, mtables in \u8bbe\u5907\u5e93 %}"
        },
        {
            "comment": "This code defines a class and sets some variables based on the class name. If the class is a RenewableEnergyDevice, it adds additional properties related to renewable energy consumption and startup count limit. For the '\u7535\u89e3\u69fd' class specifically, it adds properties for LHVHydrogen and StartupCountLimit.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1586-1608",
            "content": "{% set SO.class_name = class_name %}\nclass {{class_name}}\u6a21\u578b(\u8bbe\u5907\u6a21\u578b):\n{{ init_super_class(class_name)}}\n        {% set mflag = namespace(val=\"\") %}\n        {% if class_name in RenewableEnergyDevices %}\n        self.RenewableEnergyConsumptionPunishmentRate = self.\u8bbe\u5907\u4fe1\u606f.toStandard(\"RenewableEnergyConsumptionPunishmentRate\")\n        self.RenewableEnergyConsumptionConstraint = self.\u8bbe\u5907\u4fe1\u606f.RenewableEnergyConsumptionConstraint\n        self.RenewableEnergyConsumptionRate = self.\u8bbe\u5907\u4fe1\u606f.toStandard(\"RenewableEnergyConsumptionRate\")\n        self.discardedRenewableEnergyPower = self.\u53d8\u91cf\u5217\u8868('discardedRenewableEnergyPower', within=NonNegativeReals)\n        self.punishRate = 0\n        \"\"\"\n        \u60e9\u7f5a\u4ee3\u4ef7\n        \u5355\u4f4d\uff1a\u4e07\u5143/h\n        \"\"\"\n        {% endif %}\n        {% if class_name in ['\u7535\u89e3\u69fd']%}\n            {% for e in ['LHVHydrogen'] %}\n        self.{{e}} = self.\u8bbe\u5907\u4fe1\u606f.toStandard({{repr(e)}})\n            {% endfor %}\n        self.StartupCountLimit = self.\u8bbe\u5907\u4fe1\u606f.StartupCountLimit\n        self.HasStartupCountLimit = self.StartupCountLimit is not None"
        },
        {
            "comment": "This code is part of a class initializer that assigns default values to variables based on the device type. If the class_name is '\u67f4\u6cb9\u53d1\u7535' or '\u71c3\u6c14\u53d1\u7535\u673a', it sets the fuel heat value to 0, and retrieves unitSingleStartupCost and averageLoadRate from the device information. For '\u4f20\u8f93\u7ebf' devices, it retrieves U, Rho, GivenAveragePower, GivenMaxPower, and Pwire_Asec_Pr. It also initializes some variables based on the planning simulation type. If unbounded, it checks if the class name is not a transmission line and prints an error.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1609-1631",
            "content": "        {% elif class_name in ['\u67f4\u6cb9\u53d1\u7535', '\u71c3\u6c14\u53d1\u7535\u673a'] %}\n        self.\u71c3\u6599\u70ed\u503c:float = 0 # \u9700\u8981\u62d3\u6251\u89e3\u6790\u4e4b\u540e\u8fdb\u884c\u8d4b\u503c\n            {% for e in ['unitSingleStartupCost', 'averageLoadRate'] %}\n        self.{{e}} = self.\u8bbe\u5907\u4fe1\u606f.toStandard({{repr(e)}})\n            {% endfor %}\n        {% elif class_name in ['\u4f20\u8f93\u7ebf'] %}\n        # params added later\n            {% for lateinit_varname in [\"U\", \"Rho\", \"GivenAveragePower\", \"GivenMaxPower\",\"Pwire_Asec_Pr\"] %}\n        self.{{lateinit_varname}} = self.\u8bbe\u5907\u4fe1\u606f.toStandard({{repr(lateinit_varname)}})\n            {% endfor %}\n        {% endif%}\n        {% for psc, mdigit in mdigits %}\n        {% if psc in [\"\u4eff\u771f\u6a21\u62df\", \"\u8bbe\u8ba1\u89c4\u5212\"] %}\n        {# # psc: {{psc}} mflag: {{mflag}} #}\n        {% if mflag.val != psc %}\n        {% set mflag.val = psc %}\n        {# # after: psc: {{psc}} mflag: {{mflag}} #}\n        {% set psc2 = \"if self.\u8ba1\u7b97\u53c2\u6570.\u8ba1\u7b97\u7c7b\u578b == '{}'\".format(psc) %}\n        {{psc2}}:\n        {% if psc2 == \u8bbe\u8ba1\u89c4\u5212 %}\n            # BUG: if unbounded, then we get some error.\n            {% if class_name not in ['\u4f20\u8f93\u7ebf'] %}\n                {# {% if class_name not in ['\u9502\u7535\u6c60','\u5149\u4f0f\u53d1\u7535']%}"
        },
        {
            "comment": "This code sets the DeviceCount for different simulated devices, using different conditions to calculate it. It also provides comments suggesting alternative calculations and handling of errors or invalid branches. The code includes unit conversion and exception handling based on the device type and simulation scenario.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1632-1652",
            "content": "                    {% set mbounds = \"bounds = (self.\u8bbe\u5907\u4fe1\u606f.MinDeviceCount, self.\u8bbe\u5907\u4fe1\u606f.MaxDeviceCount)\" %}\n                {% endif%} #}\n            self.DeviceCount = self.\u5355\u53d8\u91cf('DeviceCount', within=NonNegativeIntegers) # type: ignore\n            {# self.DeviceCount = self.\u5355\u53d8\u91cf('DeviceCount', within=NonNegativeIntegers, {{mbounds}}) # type: ignore #}\n            \"\"\"\n            \u5355\u4f4d\uff1a \u4e2a\n            \"\"\"\n            {% endif %}\n        {% elif psc2 == \u4eff\u771f\u6a21\u62df %}\n            {% if class_name == '\u9502\u7535\u6c60' %}\n            self.DeviceCount = round(self.\u8bbe\u5907\u4fe1\u606f.TotalCapacity / self.\u8bbe\u5907\u4fe1\u606f.RatedCapacity) # for better user experience.\n            {# self.DeviceCount = math.floor(self.\u8bbe\u5907\u4fe1\u606f.TotalCapacity / self.\u8bbe\u5907\u4fe1\u606f.RatedCapacity) #}\n            {% endif %}\n        {% else %}\n            {% error \"[ERROR] invalid branch: {}\".format(psc)%}\n        {% endif %}\n        {%endif%}\n{{ expand_unit_conversion(mdigit) | indent(4, true) }}\n        {# {{expand_unit_conversion(mdigit) | indent(4, True)}} #}\n        {% else %}\n{{ expand_unit_conversion(mdigit,\u8bbe\u5907\u53c2\u6570\u4f8b\u5916\u5217\u8868) }}"
        },
        {
            "comment": "This code defines a class and its attributes. It iterates through a set of tables and calculates values based on the device information provided. The code sets up two lists of float numbers, defines strings for display purposes, and sorts one list by the second element. There are also some special cases defined for specific device classes like gas turbine and diesel generator.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1653-1682",
            "content": "        {% endif %}\n        {% endfor %}\n        {# {%endwith%} #}\n        {% for psc, main, sub in mtables %}\n        {% set mtable=(main, sub)%}\n        self.{{ mtable[0][0]}}_{{ mtable[1][0]}} : List[List[float]] = [[v1 * {{mtable[0][4]}}, v2 * {{mtable[1][4]}}] for v1, v2 in \u8bbe\u5907\u4fe1\u606f.{{ mtable[0][0]}}_{{ mtable[1][0]}}]\n        \"\"\"\n        {{ mtable[0][0]}}: {{ mtable[0][1]}}\n        \u5355\u4f4d: {{ mtable[0][3]}} <- {{ mtable[0][2]}}\n        {{ mtable[1][0]}}: {{ mtable[1][1]}}\n        \u5355\u4f4d: {{ mtable[1][3]}} <- {{ mtable[1][2]}}\n        \"\"\"\n        self.{{ mtable[0][0]}}_{{ mtable[1][0]}}.sort(key=lambda x: x[1])\n        {% endfor %}\n{{ port_variable_define(class_name)}}\n        # \u8bbe\u5907\u7279\u6709\u7ea6\u675f\uff08\u53d8\u91cf\uff09\n        {% if class_name in ['\u5149\u4f0f\u53d1\u7535', '\u98ce\u529b\u53d1\u7535', '\u67f4\u6cb9\u53d1\u7535', '\u71c3\u6c14\u53d1\u7535\u673a'] %}\n        self.\u7535\u8f93\u51fa = self.\u7535\u63a5\u53e3\n            {% if class_name in [\"\u67f4\u6cb9\u53d1\u7535\"]%}\n        self.\u67f4\u6cb9\u8f93\u5165 = self.\u71c3\u6599\u63a5\u53e3\n            {% elif class_name in ['\u71c3\u6c14\u53d1\u7535\u673a']%}\n        self.\u5929\u7136\u6c14\u8f93\u5165 =  self.\u67f4\u6cb9\u8f93\u5165 = self.\u71c3\u6599\u63a5\u53e3\n        {# self.\u67f4\u6cb9\u8f93\u5165 = self.\u5929\u7136\u6c14\u8f93\u5165 = self.\u71c3\u6599\u63a5\u53e3 #}\n            {% elif class_name in ['\u98ce\u529b\u53d1\u7535']%}"
        },
        {
            "comment": "This code segment is part of an optimization problem for a microgrid. It defines and constrains power input and output variables for specific device types, such as transformers and transmission lines. For transformers, additional constraints are applied based on the device's direction. The code also handles load balancing at the exchange nodes between transformers and loads by setting the maximum allowed load power.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1683-1706",
            "content": "        self.\u5355\u53f0\u53d1\u7535\u529f\u7387 = ...\n            {% endif%}\n        {% endif%}\n        {% if class_name in ['\u53d8\u538b\u5668', '\u4f20\u8f93\u7ebf'] %}\n        self.PowerInput_ = self.\u53d8\u91cf\u5217\u8868_\u5e26\u6307\u793a\u53d8\u91cf(\"PowerInput_\")\n        self.PowerOutput_ = self.\u53d8\u91cf\u5217\u8868_\u5e26\u6307\u793a\u53d8\u91cf(\"PowerOutput_\")\n        self.RangeConstraint(self.\u7535\u8f93\u5165, self.PowerInput_.x, expression=lambda x,y: x==y)\n        self.RangeConstraint(self.\u7535\u8f93\u51fa, self.PowerOutput_.x, expression=lambda x,y: x==y)\n        self.RangeConstraint(self.PowerInput_.b_pos, self.PowerOutput_.b_pos, expression = lambda x,y: x + y <=1)\n        self.RangeConstraint(self.PowerInput_.b_neg, self.PowerOutput_.b_neg, expression = lambda x,y: x + y <=1)\n            {%if class_name in ['\u53d8\u538b\u5668']%}\n        if self.\u8bbe\u5907\u4fe1\u606f.direction == Direction.Directed:\n            self.RangeConstraintMulti(self.PowerInput_.x_pos, expression=lambda x: x == 0)\n            self.RangeConstraintMulti(self.PowerOutput_.x_neg, expression=lambda x: x == 0)\n        {{\u8bbe\u8ba1\u89c4\u5212}}: # \u5728\u53d8\u538b\u5668\u548c\u8d1f\u8377\u7684\u4ea4\u6362\u8282\u70b9\u5904\u505a\u5904\u7406\n            self.\u6700\u5927\u5141\u8bb8\u7684\u8d1f\u8f7d\u603b\u529f\u7387 = self.DeviceCount*(self.RatedPower"
        },
        {
            "comment": "This code defines a transmission line class and sets up optimization constraints for power and angle variables. The transmission line's power is optimized using a disjunction constraint, with the power and angle values sorted into separate arrays. If optimizing, it creates variables for the power and angle within non-negative real numbers, and applies range constraints to ensure the sum of input and output powers doesn't exceed the total line power. Lastly, it applies a disjunctive pair constraint to enforce that the power value corresponds to one of the sorted power array values.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1706-1724",
            "content": "*self.Efficiency)*self.PowerParameter/(1 if 0 == self.LoadRedundancyParameter else self.LoadRedundancyParameter) # type: ignore\n            {%elif class_name in ['\u4f20\u8f93\u7ebf']%}\n        # TODO: use Disjunction instead of Piecewise\n        self.Pwire_Asec_Pr.sort(key=lambda x: x[0])\n        self.Pwire_arr = [e[0] for e in self.Pwire_Asec_Pr]\n        self.Asec_arr = [e[1] for e in self.Pwire_Asec_Pr]\n        self.Pr_arr = [e[2] for e in self.Pwire_Asec_Pr]\n        if self.\u8bbe\u5907\u4fe1\u606f.Optimize:\n            self.Pwire = self.\u5355\u53d8\u91cf('Pwire', within=NonNegativeReals)\n            self.RangeConstraintMulti(self.PowerInput_.x_neg, self.PowerOutput_.x_neg, expression = lambda x,y: x+y<=self.Pwire)\n            self.Asec = self.\u5355\u53d8\u91cf('Asec', within=NonNegativeReals)\n            self.Asec_inv = self.\u5355\u53d8\u91cf('Asec_inv', within=NonNegativeReals)\n            {# self.Piecewise(x_var = [self.Pwire], y_var = [self.Asec],x_vals = self.Pwire_arr, y_vals = self.Asec_arr,range_list = [0])[0] #}\n            self.DisjunctivePair(x_var = self.Pwire, y_var = self.Asec,x_vals = self.Pwire_arr, y_vals = self.Asec_arr)"
        },
        {
            "comment": "The code defines a variable \"Pr\" and sets it to be within non-negative real values. If the given maximum power is valid, it finds the closest value in Pwire_arr that matches this power. Else, it raises an exception if no valid Pwire is found.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1725-1745",
            "content": "            self.DisjunctivePair(x_var = self.Pwire, y_var = self.Asec_inv,x_vals = self.Pwire_arr, y_vals = [1/e for e in self.Asec_arr])\n            self.Pr = self.\u5355\u53d8\u91cf('Pr', within=NonNegativeReals)\n            {# self.Piecewise(x_var = [self.Pwire], y_var = [self.Pr], x_vals = self.Pwire_arr, y_vals = self.Pr_arr ,range_list = [0])[0] #}\n            self.DisjunctivePair(x_var = self.Pwire, y_var = self.Pr, x_vals = self.Pwire_arr, y_vals = self.Pr_arr )\n        else:\n            self.Pwire = self.GivenMaxPower\n            ind = -1\n            dis = -1\n            for _ind, val in enumerate(self.Pwire_arr):\n                _dis = val - self.GivenMaxPower\n                if _dis >= 0:\n                {# if _dis > 0: #}\n                    if dis <0 or dis > _dis:\n                        dis = _dis\n                        ind = _ind\n            if ind == -1:\n                raise Exception(f\"No valid Pwire found!\\nGivenMaxPower: {self.GivenMaxPower}\\nPwire_arr: {self.Pwire_arr}\")\n            else:\n                self.Pwire = self.Pwire_arr[ind]"
        },
        {
            "comment": "1. Assigns Asec and Pr values from arrays based on index\n2. Optionally calculates Asec and Pr using interpolation based on Pwire\n3. Calculates line resistance (R) using length, Rho, and Asec_inv\n4. Computes power loss (Ploss) based on given average power and resistance\n5. Preserves CostPerKilometer value without applying any formula\n6. Optionally computes CostPerYearPerKilometer and BuildCostPerKilometer",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1746-1772",
            "content": "                self.Asec = self.Asec_arr[ind]\n                self.Asec_inv = 1/self.Asec\n                self.Pr = self.Pr_arr[ind]\n            {# self.Pwire = self.GivenAveragePower #}\n            {# self.Asec = np.interp(self.Pwire, self.Pwire_arr, self.Asec_arr)\n            self.Pr = np.interp(self.Pwire, self.Pwire_arr, self.Pr_arr) #}\n        self.R =(self.Rho*self.Length) * self.Asec_inv\n        {# self.R =(self.Rho*self.Length) / self.Asec #}\n        \"\"\"\n        \u4f20\u8f93\u7ebf\u7535\u963b\n        \"\"\"\n        self.Ploss = self.R * ((self.GivenAveragePower/self.U) **2)\n        # unit please?\n        # overriding passed parameters.\n        # let's preserve this.\n        self.CostPerKilometer = self.Pr\n        {# no formula! #}\n        {# self.CostPerYearPerKilometer = ...  #}\n        {# self.BuildCostPerKilometer =  #}\n        self.inputIndicators = self.\u53d8\u91cf\u5217\u8868_\u5e26\u6307\u793a\u53d8\u91cf('inputIndicators')\n        self.outputIndicators = self.\u53d8\u91cf\u5217\u8868_\u5e26\u6307\u793a\u53d8\u91cf('outputIndicators')\n            {% endif %}\n        {% endif %}\n        {% if class_name in ['\u5149\u4f0f\u53d1\u7535'] %}"
        },
        {
            "comment": "Sets the maximum and minimum device count based on install area for certain components.\nDefines the number of run indicators, machine runtime, and yearly operation hours.\nFor fuel cells, adds a range constraint for startup behavior.\nFor diesel generators and natural gas generators, sets DieselToPower_Load equal to NaturalGasToPower_Load and adds a range constraint for electric output based on hot water production rate.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1773-1792",
            "content": "        {{\u8bbe\u8ba1\u89c4\u5212}}:\n            # TODO\uff1a\u6807\u51c6\u5149\u7167\u4e0b\u51fa\u529b\n            self.MaxDeviceCount = math.ceil(self.MaxInstallArea/self.Area)\n            self.MinDeviceCount = math.floor(self.MinInstallArea/self.Area)\n            assert self.MinDeviceCount>=0\n            assert self.MaxDeviceCount>=self.MinDeviceCount\n        {% elif class_name in [\"\u7535\u89e3\u69fd\", \"\u67f4\u6cb9\u53d1\u7535\", '\u71c3\u6c14\u53d1\u7535\u673a'] %}\n        self.Nrun_indicators = self.\u53d8\u91cf\u5217\u8868_\u5e26\u6307\u793a\u53d8\u91cf(\"Nrun_indicators\")\n        self.\u673a\u7ec4\u5e74\u8fd0\u884c\u65f6\u95f4 = (quicksum_indexed_var(self.Nrun_indicators.b_pos) / self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570) * 8760\n            {% if class_name in [\"\u7535\u89e3\u69fd\"] %}\n        self.RangeConstraint(self.\u7535\u63a5\u53e3, self.Nrun_indicators.x, expression = lambda x,y: -( x + self.RatedInputPower * self.HydrogenGenerationStartupRate) - self.EPS == y)\n        self.\u673a\u7ec4\u5e74\u542f\u52a8\u6b21\u6570 = 0\n            {% elif class_name in [\"\u67f4\u6cb9\u53d1\u7535\", '\u71c3\u6c14\u53d1\u7535\u673a'] %}\n                {% if class_name in ['\u71c3\u6c14\u53d1\u7535\u673a'] %}\n        self.DieselToPower_Load = self.NaturalGasToPower_Load\n        self.RangeConstraint(self.\u7535\u8f93\u51fa, self.\u7f38\u5957\u6c34\u4f59\u70ed\u63a5\u53e3, expression = lambda x,y: x * self.HotWaterToElectricityRate == y)"
        },
        {
            "comment": "Defines variables with expressions, creates range constraints for Nrun and Nstart, sets initial value of Nstart to 0, uses CustomRangeConstraintMulti for Nstart.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1793-1816",
            "content": "        self.RangeConstraint(self.\u7535\u8f93\u51fa, self.\u9ad8\u6e29\u70df\u6c14\u4f59\u70ed\u63a5\u53e3, expression = lambda x,y: x * self.HotGasToElectricityRate == y)\n                {% endif %}\n        # TODO: define some variables with expression\n        {# self.\u7535\u529f\u7387\u4e2d\u8f6c = self.\u53d8\u91cf\u5217\u8868_\u5e26\u6307\u793a\u53d8\u91cf(\"\u7535\u529f\u7387\u4e2d\u8f6c\") #}\n        {# self.\u5355\u53f0\u53d1\u7535\u529f\u7387 = self.\u53d8\u91cf\u5217\u8868(\"\u5355\u53f0\u53d1\u7535\u529f\u7387\", within=NonNegativeReals)\n        self.\u5355\u53f0\u67f4\u6cb9\u8f93\u5165 = self.\u53d8\u91cf\u5217\u8868(\"\u5355\u53f0\u67f4\u6cb9\u8f93\u5165\", within=NonPositiveReals) #}\n        {# self.Nrun_indicators = self.\u53d8\u91cf\u5217\u8868_\u5e26\u6307\u793a\u53d8\u91cf(\"Nrun_indicators\") #}\n        self.Nrun = self.\u53d8\u91cf\u5217\u8868(\"Nrun\", within=NonNegativeIntegers)\n        \"\"\"\n        \u673a\u7ec4\u5f00\u542f\u53f0\u6570\n        \"\"\"\n        self.RangeConstraint(self.Nrun, self.Nrun_indicators.x, expression = lambda x,y: x == y + 0.5)\n        self.RangeConstraintMulti(self.Nrun, expression = lambda x: x <= self.DeviceCount)\n        self.Nstart = self.\u53d8\u91cf\u5217\u8868_\u5e26\u6307\u793a\u53d8\u91cf(\"Nstart\")\n        \"\"\"\n        \u673a\u7ec4\u5f00\u542f\u53f0\u6570\u6c42\u5bfc\n        \"\"\"\n        self.mw.Constraint(expr = self.Nstart.x[0] == 0)\n        self.CustomRangeConstraintMulti(self.Nstart.x, self.Nrun, expression = lambda x,y,i: x[i+1] == y[i+1] - y[i], customRange = range(self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570 - 1))"
        },
        {
            "comment": "This code is calculating the annual operating hours for a generator based on the start-up count, runtime indicators, and power constraints. It also interpolates the diesel to power load data and handles special cases like startup limit and zero loads. The Interpolate2D function is called to ensure accurate calculations of the diesel to power load data.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1818-1840",
            "content": "        self.\u673a\u7ec4\u5e74\u542f\u52a8\u6b21\u6570 = quicksum_indexed_var(self.Nstart.x_pos) * (8760/self.\u8ba1\u7b97\u53c2\u6570.\u603b\u8ba1\u7b97\u65f6\u957f)\n        {# self.\u673a\u7ec4\u5e74\u8fd0\u884c\u65f6\u95f4 = (quicksum_indexed_var(self.Nrun_indicators.b_pos) / self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570) * 8760 #}\n        min_diesel_to_power, min_load = self.DieselToPower_Load[0]\n        max_diesel_to_power, max_load = self.DieselToPower_Load[-1]\n        if min_load > self.PowerStartupLimit:\n            if self.PowerStartupLimit not in [e[1] for e in self.DieselToPower_Load]:\n                self.DieselToPower_Load.insert(0, (min_diesel_to_power, self.PowerStartupLimit))\n        if min_load>0:\n            self.DieselToPower_Load.insert(0, (min_diesel_to_power,0))\n            {# self.DieselToPower_Load.insert(0, (0,0)) #}\n        {# self.DieselToPower_Load.insert(1, (min_diesel_to_power, self.EPS)) #}\n        if max_load <1:\n            self.DieselToPower_Load.append((max_diesel_to_power,1))\n        self.DieselToPower_Load = self.Interpolate2D(self.DieselToPower_Load)\n        if self.\u8bbe\u5907\u4fe1\u606f.unitAnnualOperatingTimeConstraint:"
        },
        {
            "comment": "The code snippet represents the implementation of unit-level constraints and cost calculations in a microgrid optimization model. It considers annual operating time limits, startup costs, and diesel/gas consumption for different types of generators based on user-selected planning algorithms (average or best oil consumption). The code handles sorting, interpolation, and sub-model initialization accordingly.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1841-1861",
            "content": "            self.mw.Constraint(expr = self.\u673a\u7ec4\u5e74\u8fd0\u884c\u65f6\u95f4 <= self.\u8bbe\u5907\u4fe1\u606f.maximumAnnualOperatingTimeLimitOfTheUnit)\n        self.annualUnitStartupCosts = 0\n        if self.\u8bbe\u5907\u4fe1\u606f.considerUnitStartUpCosts:\n            self.annualUnitStartupCosts = self.\u673a\u7ec4\u5e74\u542f\u52a8\u6b21\u6570 * self.unitSingleStartupCost\n        if self.\u8bbe\u5907\u4fe1\u606f.unitPlanningAlgorithmSelection == \u6cb9\u8017\u89c4\u5212\u7b97\u6cd5.\u5e73\u5747:\n            x = self.averageLoadRate\n            {# already sorted. #}\n            {# xfp = list(sorted(self.\u8bbe\u5907\u4fe1\u606f.DieselToPower_Load, key = lambda e: e[1])) #}\n            xp = [e[1] for e in self.DieselToPower_Load]\n            fp = [e[0] for e in self.DieselToPower_Load]\n            {{ \"self.averageGasConsumptionRate = \" if class_name in [\"\u71c3\u6c14\u53d1\u7535\u673a\"] else \"\" }}self.averageDieselConsumptionRate = np.interp(x, xp, fp)\n        elif self.\u8bbe\u5907\u4fe1\u606f.unitPlanningAlgorithmSelection == \u6cb9\u8017\u89c4\u5212\u7b97\u6cd5.\u6700\u4f73:\n            self.\u5b50\u673a\u7ec4\u5217\u8868 = []\n            {% set subModelParamsAndRanges = [\n                [\"\u67f4\u6cb9\u8f93\u5165\", \"NonPositiveReals\"],\n                [\"\u7535\u8f93\u51fa\", \"NonNegativeReals\"],\n                [\"\u662f\u5426\u5f00\u542f\", \"Boolean\"],"
        },
        {
            "comment": "The code initializes a list of sub-generator models, iterates through the number of generators to be purchased based on the computation type, and creates each sub-model for the generator. It also defines variables for parameters like \"\u5b50\u673a\u7ec4\u662f\u5426\u8d2d\u4e70\" within specified ranges and appends them to their respective lists. If an unknown fuel consumption planning algorithm is detected, it raises an exception.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1862-1885",
            "content": "                [\"\u662f\u5426\u771f\u7684\u5f00\u542f\", \"Boolean\"],\n            ] %}\n            {% for p, r in subModelParamsAndRanges%}\n            self.\u5b50\u673a\u7ec4{{p}}\u5217\u8868 = []\n            {% endfor%}\n            {# self.\u67f4\u6cb9\u5b50\u673a\u7ec4\u57fa\u7840\u6a21\u578b = self.Block() # modelwrapper #}\n            self.\u5b50\u673a\u7ec4\u6570\u76ee = self.MaxDeviceCount if self.\u8ba1\u7b97\u53c2\u6570.\u8ba1\u7b97\u7c7b\u578b == '\u8bbe\u8ba1\u89c4\u5212' else self.DeviceCount\n            self.\u5b50\u673a\u7ec4\u6570\u76ee = int(self.\u5b50\u673a\u7ec4\u6570\u76ee)\n            self.\u5b50\u673a\u7ec4\u662f\u5426\u8d2d\u4e70 = self.\u53d8\u91cf\u5217\u8868('\u5b50\u673a\u7ec4\u662f\u5426\u8d2d\u4e70', mrange = range(self.\u5b50\u673a\u7ec4\u6570\u76ee), within=Boolean)\n            for i in range(self.\u5b50\u673a\u7ec4\u6570\u76ee):\n                logger_print(f\"\u6b63\u5728\u521b\u5efa\u7b2c{i+1}\u4e2a{{class_name.split('\u53d1\u7535')[0]}}\u5b50\u673a\u7ec4\u6a21\u578b\")\n                subModelWrapper = self.mw.Block()\n                \u5b50\u673a\u7ec4\u6a21\u578b = \u8bbe\u5907\u6a21\u578b({}, subModelWrapper, self.\u8ba1\u7b97\u53c2\u6570, i)\n                self.\u5b50\u673a\u7ec4\u5217\u8868.append(\u5b50\u673a\u7ec4\u6a21\u578b)\n            {% for p, r in subModelParamsAndRanges%}\n                \u5b50\u673a\u7ec4{{p}} = \u5b50\u673a\u7ec4\u6a21\u578b.\u53d8\u91cf\u5217\u8868('\u5b50\u673a\u7ec4{{p}}', within={{r}})\n                self.\u5b50\u673a\u7ec4{{p}}\u5217\u8868.append(\u5b50\u673a\u7ec4{{p}})\n            {% endfor%}\n            # define series of submodels\n        else:\n            raise Exception(\"\u672a\u77e5\u6cb9\u8017\u89c4\u5212\u7b97\u6cd5\uff1a\", self.\u8bbe\u5907\u4fe1\u606f.unitPlanningAlgorithmSelection)"
        },
        {
            "comment": "This code is a part of a class that handles the power generation and consumption in a microgrid system. It checks if the generator device is present or not, and then calculates the electrical output based on the device count and rated power. It also calculates the diesel input and applies constraints using RangeConstraint function for both electrical output and diesel input.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1887-1905",
            "content": "        {# \n        {{\u8bbe\u8ba1\u89c4\u5212}}:\n            self.\u6700\u5927\u6cb9\u8017\u7387 = max([x[0] for x in self.DieselToPower_Load])\n            self.\u539f\u7535\u8f93\u51fa = self.Multiply(dict(var=self.\u5355\u53f0\u53d1\u7535\u529f\u7387,max=self.RatedPower, min=0), dict(var=self.\u5355\u53d8\u91cf\u8f6c\u5217\u8868(self.DeviceCount),max=self.MaxDeviceCount, min=self.MinDeviceCount), \"\u539f\u7535\u8f93\u51fa\", within = NonNegativeReals)\n            self.\u67f4\u6cb9\u8f93\u5165_ = self.Multiply(dict(var=self.\u5355\u53f0\u67f4\u6cb9\u8f93\u5165, max=0, min=-self.RatedPower*self.\u6700\u5927\u6cb9\u8017\u7387), dict(var=self.\u5355\u53d8\u91cf\u8f6c\u5217\u8868(self.DeviceCount),max=self.MaxDeviceCount, min=self.MinDeviceCount), \"\u67f4\u6cb9\u8f93\u5165_\", within = NonPositiveReals)\n            self.RangeConstraint(self.\u67f4\u6cb9\u8f93\u5165_, self.\u67f4\u6cb9\u8f93\u5165, lambda x,y: x == y)\n        else:\n            self.\u539f\u7535\u8f93\u51fa = self.\u53d8\u91cf\u5217\u8868(\"\u539f\u7535\u8f93\u51fa\", within = NonNegativeReals)\n            self.RangeConstraint(self.\u539f\u7535\u8f93\u51fa, self.\u5355\u53f0\u53d1\u7535\u529f\u7387, lambda x,y: x == y*self.DeviceCount)\n            self.RangeConstraint(\n                self.\u67f4\u6cb9\u8f93\u5165,\n                self.\u5355\u53f0\u67f4\u6cb9\u8f93\u5165,\n                expression=lambda x, y: x == y * self.DeviceCount,\n            ) \n        #}\n            {% endif%}\n        {% elif class_name  == '\u9502\u7535\u6c60' %}"
        },
        {
            "comment": "This code is initializing a microgrid device with storage decay compensation, setting initial SOC and capacity per unit, defining maximum and minimum values for SOC and device count, asserting the limits on SOC, defining positive and negative charge/discharge interfaces, and calculating the actual capacity per unit.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1907-1933",
            "content": "        {# self.needStorageDecayCompensation:bool = self.\u8bbe\u5907\u4fe1\u606f.needStorageDecayCompensation\n        \"\"\"\n        \u5f00\u542f\u540e\u5b58\u50a8\u8870\u51cf\u8865\u507f\u5c06\u53ef\u53d8\uff0c\u53cd\u4e4b\u5b58\u50a8\u8870\u51cf\u8865\u507f\u7b49\u4e8e\u5b58\u50a8\u8870\u51cf\n        \"\"\" #}\n        assert self.InitSOC >= self.MinSOC\n        assert self.InitSOC <= self.MaxSOC\n        {# self.InitActualCapacityPerUnit = (self.InitSOC - self.MinSOC) * self.RatedCapacity #}\n        self.InitCapacityPerUnit = self.InitSOC * self.RatedCapacity\n        {{\u8bbe\u8ba1\u89c4\u5212}}:\n            #  \u521d\u59cbSOC\n            self.MaxDeviceCount = math.floor(self.MaxTotalCapacity / self.RatedCapacity)\n            self.MinDeviceCount = math.ceil(self.MinTotalCapacity / self.RatedCapacity)\n            self.TotalCapacity = self.DeviceCount * self.RatedCapacity # type: ignore\n        assert self.MaxSOC >= self.MinSOC\n        assert self.MaxSOC <= 1\n        {# assert self.MaxSOC < 1 #}\n        assert self.MinSOC >= 0\n        {# assert self.MinSOC > 0 # to ensure that battery will not be drained. #}\n        self.\u539f\u7535\u63a5\u53e3 = self.\u53d8\u91cf\u5217\u8868_\u5e26\u6307\u793a\u53d8\u91cf(\"\u539f\u7535\u63a5\u53e3\") # \u6b63 \u653e\u7535 \u8d1f \u5145\u7535\n        {# self.ActualCapacityPerUnit = self.RatedCapacity * (self.MaxSOC - self.MinSOC) #}"
        },
        {
            "comment": "Calculates the SOC (State of Charge) based on CurrentTotalCapacity and TotalCapacity. Imposes design planning and simulation constraints on CurrentTotalCapacity using setlb, setub, and RangeConstraintMulti functions.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1935-1950",
            "content": "        self.CurrentTotalCapacity = self.\u53d8\u91cf\u5217\u8868('CurrentTotalCapacity', within=NonNegativeReals)\n        # reserved expression list. do not use it in any constraints.\n        self.SOC = [self.CurrentTotalCapacity[i]/self.TotalCapacity for i in self.CurrentTotalCapacity]\n        {# {{\u8bbe\u8ba1\u89c4\u5212}}:\n            self.CurrentTotalCapacity.setlb(self.MinDeviceCount*self.MinSOC*self.RatedCapacity)\n            self.CurrentTotalCapacity.setub(self.MaxDeviceCount*self.MaxSOC*self.RatedCapacity) #}\n        self.RangeConstraintMulti(self.CurrentTotalCapacity, expression = lambda x: x >= self.TotalCapacity * self.MinSOC)\n        self.RangeConstraintMulti(self.CurrentTotalCapacity, expression = lambda x: x <= self.TotalCapacity * self.MaxSOC)\n        {# else: # \u4eff\u771f\u6a21\u62df\n            self.CurrentTotalCapacity.setlb(self.DeviceCount*self.MinSOC*self.RatedCapacity)\n            self.CurrentTotalCapacity.setub(self.DeviceCount*self.MaxSOC*self.RatedCapacity) #}\n        {# self.CurrentTotalActualCapacity = self.\u53d8\u91cf\u5217\u8868('CurrentTotalActualCapacity', within=NonNegativeReals) #}"
        },
        {
            "comment": "This code calculates the total capacity, maximum total charge or discharge rate, and decay rate for a battery system. The total capacity is based on device count and actual capacity per unit. The maximum total charge or discharge rate is calculated using the battery delta limit and total capacity. The decay rate is derived from the battery storage decay percentage and multiplied by the total capacity. The code also mentions that there might be a need for storage decay compensation, but it seems incomplete.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1952-1980",
            "content": "        {# self.TotalActualCapacity = self.DeviceCount * self.ActualCapacityPerUnit # type: ignore #}\n        {# self.MaxTotalCapacityDeltaPerStep = self.BatteryDeltaLimit * self.TotalCapacity / ({{\u65f6\u95f4\u6b65\u957f\u53c2\u6570}})\n        \"\"\"\n        \u5355\u4f4d: kWh\n        \"\"\" #}\n        self.MaxTotalChargeOrDischargeRate = self.BatteryDeltaLimit * self.TotalCapacity \n        \"\"\"\n        \u6700\u5927\u603b\u5145\u653e\u529f\u7387\n        \u5355\u4f4d: kW\n        \"\"\"\n        {# self.TotalStoragePowerOfDecay = (self.BatteryStorageDecay / 100) * self.TotalCapacity\n        \"\"\"\n        \u5355\u4f4d: kW\n        \"\"\" #}\n        self.sigma = (self.BatteryStorageDecay / 100) \n        \"\"\"\n        \u8870\u51cf\u7387\n        \u5355\u4f4d: 1/h\n        \"\"\"\n            {# {% if needStorageDecayCompensation%} #}\n        {# if self.needStorageDecayCompensation: \n            # TODO: Verify if \"compensated decay rate\" works.\n            {{\u8bbe\u8ba1\u89c4\u5212}}:\n                self.CurrentTotalPowerOfDecayCompensated = self.\u53d8\u91cf\u5217\u8868('\u603b\u8865\u507f\u8870\u51cf\u7387', bounds = (0,(self.BatteryStorageDecay/100)*self.MaxTotalCapacity), within=NonNegativeReals) # the greater the val"
        },
        {
            "comment": "This code appears to be part of a larger program that is defining and setting constraints for a device or component within a microgrid system. The code is generating variables, applying constraints based on the type of device (such as decay compensated devices or two-way converters), and setting bounds and limits for certain parameters such as device count and power levels. This seems to be part of a larger optimization problem in the context of the IEEE 809 standard.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":1980-2001",
            "content": "ue, the less our compensation is, the greater the real discharge by decay is (will not emit to external ports).\n                # constraint.\n                self.RangeConstraintMulti(self.CurrentTotalPowerOfDecayCompensated, expression=lambda x: x<=self.TotalStoragePowerOfDecay)\n            else: # \u4eff\u771f\u6a21\u62df\n                self.CurrentTotalPowerOfDecayCompensated = self.\u53d8\u91cf\u5217\u8868('\u603b\u8865\u507f\u8870\u51cf\u7387', bounds = (0,self.TotalStoragePowerOfDecay), within=NonNegativeReals) #}\n        {%elif class_name in ['\u53cc\u5411\u53d8\u6d41\u5668']%}\n        self.\u7ebf\u8def\u7aef_ = self.\u53d8\u91cf\u5217\u8868_\u5e26\u6307\u793a\u53d8\u91cf(\"\u7ebf\u8def\u7aef_\")\n        self.\u50a8\u80fd\u7aef_ = self.\u53d8\u91cf\u5217\u8868_\u5e26\u6307\u793a\u53d8\u91cf(\"\u50a8\u80fd\u7aef_\")\n{# \n        {% elif class_name in ['\u4f20\u8f93\u7ebf']%}\n        self.\u7535\u8f93\u5165_\u53bb\u9664\u635f\u8017 = self.\u53d8\u91cf\u5217\u8868_\u5e26\u6307\u793a\u53d8\u91cf('\u7535\u8f93\u5165_\u53bb\u9664\u635f\u8017')  #}\n        {%endif%}\n        {% if class_name not in [\"\u4f20\u8f93\u7ebf\"]%}\n        self.POSNEG_\u662f\u5426\u8d2d\u4e70 = self.\u5355\u8868\u8fbe\u5f0f\u751f\u6210\u6307\u793a\u53d8\u91cf('POSNEG_\u662f\u5426\u8d2d\u4e70', self.DeviceCount - 0.5)\n        self.\u662f\u5426\u8d2d\u4e70 = self.POSNEG_\u662f\u5426\u8d2d\u4e70.b_pos\n        if isinstance(self.DeviceCount, Var): # \u8bbe\u5907\u53f0\u6570\u7ea6\u675f\n            self.DeviceCount.setlb(self.MinDeviceCount)\n            self.DeviceCount.setub(self.MaxDeviceCount)"
        },
        {
            "comment": "This code defines device-specific constraints for the microgrid and checks if certain parameters are fully filled. For gas and diesel generators, it asserts that the fuel heat value is not zero. For wind turbines, it defines a piecewise function based on rated wind speed and checks if minimum and maximum wind speeds are set correctly. The code also fixes a bug where wind speed was previously declared as \"np.int64\" instead of \"np.float64\".",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2002-2031",
            "content": "        {% endif%}\n    def constraints_register(self):\n        super().constraints_register()\n        # \u8bbe\u5907\u7279\u6709\u7ea6\u675f\uff08\u975e\u53d8\u91cf\uff09\n        {# \u68c0\u9a8c\u89e3\u6790\u65f6\u53c2\u6570\u662f\u5426\u586b\u5199\u5b8c\u5168 #}\n        {% if class_name in ['\u67f4\u6cb9\u53d1\u7535', '\u71c3\u6c14\u53d1\u7535\u673a'] %}\n        assert self.\u71c3\u6599\u70ed\u503c!=0\n        assert type(self.\u71c3\u6599\u70ed\u503c) in [int,float]\n        {% endif%}\n        {% if class_name == \"\u98ce\u529b\u53d1\u7535\" %}\n        # define a single-variate piecewise function\n        # \n        #         ____\n        #        /    |\n        #       /     | ax^3\n        #  ----/      |______\n        #\n        assert self.RatedWindSpeed >=self.MinWindSpeed\n        assert self.MaxWindSpeed >=self.RatedWindSpeed\n        if self.\u8bbe\u5907\u4fe1\u606f.machineType in [\u98ce\u529b\u53d1\u7535\u7c7b\u578b.\u53d8\u6868, \u98ce\u529b\u53d1\u7535\u7c7b\u578b.\u5b9a\u6868]:\n            \u53d1\u7535\u66f2\u7ebf\u53c2\u6570 = self.RatedPower / ( (self.RatedWindSpeed - self.MinWindSpeed) ** 3)\n            # windspeed (m/s) -> current power per device (kW)\n            WS = np.array(self.\u8ba1\u7b97\u53c2\u6570.\u98ce\u901f, dtype=np.float64) # BUG: before that it was \"np.int64\", which introduce errors.\n            {# self.\u5355\u53f0\u53d1\u7535\u529f\u7387 = \u5355\u53f0\u53d1\u7535\u529f\u7387 = np.piecewise(WS, [WS<=self.MinWindSpeed"
        },
        {
            "comment": "The code defines a power curve for wind turbines, taking into account various wind speed conditions and different machine types (pitch-controlled or fixed-pitch). The function calculates the output power based on the actual wind speed using piecewise linear interpolation.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2031-2047",
            "content": ", np.logical_and(WS >self.MinWindSpeed,WS <= self.RatedWindSpeed) , np.logical_and(WS >self.RatedWindSpeed, WS <=self.MaxWindSpeed) , WS > self.MaxWindSpeed], [0,\n            lambda x: \u53d1\u7535\u66f2\u7ebf\u53c2\u6570 * ((x - self.MinWindSpeed) ** 3), \n            self.RatedPower, 0]) #}\n            if self.\u8bbe\u5907\u4fe1\u606f.machineType == \u98ce\u529b\u53d1\u7535\u7c7b\u578b.\u5b9a\u6868:\n                # \u989d\u5b9a\u529f\u7387 +( (\u5207\u51fa\u529f\u7387 - \u989d\u5b9a\u529f\u7387)*(\u5b9e\u9645\u98ce\u901f-\u989d\u5b9a\u98ce\u901f)) / (\u5207\u51fa\u98ce\u901f-\u989d\u5b9a\u98ce\u901f)\n                \u5b9a\u6868\u98ce\u673a\u7279\u6709\u51fd\u6570 = lambda \u5b9e\u9645\u98ce\u901f: self.RatedPower +((self.CutoutPower - self.RatedPower)*(\u5b9e\u9645\u98ce\u901f-self.RatedWindSpeed)) / (self.MaxWindSpeed-self.RatedWindSpeed)\n            self.\u5355\u53f0\u53d1\u7535\u529f\u7387 = \u5355\u53f0\u53d1\u7535\u529f\u7387 = np.piecewise(\n            WS,\n            [\n                WS <= self.MinWindSpeed,\n                np.logical_and(WS > self.MinWindSpeed, WS <= self.RatedWindSpeed),\n                np.logical_and(WS > self.RatedWindSpeed, WS <= self.MaxWindSpeed),\n                WS > self.MaxWindSpeed,\n            ],\n            [   0, \n                lambda x: \u53d1\u7535\u66f2\u7ebf\u53c2\u6570 * ((x - self.MinWindSpeed) ** 3),\n                self.RatedPower if self.\u8bbe\u5907\u4fe1\u606f.machineType == \u98ce\u529b\u53d1\u7535\u7c7b\u578b.\u53d8\u6868 else \u5b9a\u6868\u98ce\u673a\u7279\u6709\u51fd\u6570, "
        },
        {
            "comment": "This code sets the rated power for a machine based on its type and normalizes the power values. If the machine type is unknown, an exception will be raised. It also adds constraints for device count and output input power for certain types of machines (e.g., batteries).",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2048-2073",
            "content": "                0 \n            ],\n            )\n            self.\u5355\u53f0\u53d1\u7535\u529f\u7387 = \u5355\u53f0\u53d1\u7535\u529f\u7387 = \u5355\u53f0\u53d1\u7535\u529f\u7387.tolist()\n        elif self.\u8bbe\u5907\u4fe1\u606f.machineType in [\u98ce\u529b\u53d1\u7535\u7c7b\u578b.\u6807\u5e7a\u503c]:\n            assert self.\u8bbe\u5907\u4fe1\u606f.normalizedPower is not None, \"\u6807\u5e7a\u503c\u98ce\u673a\u4e0d\u80fd\u4f20\u7a7a\u7684\u6807\u5e7a\u503c\"\n            assert (length:= len(self.\u8bbe\u5907\u4fe1\u606f.normalizedPower)) == (required_length:= self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570), f'\u6807\u5e7a\u503c\u957f\u5ea6\u4e0d\u5408\u7406\\n\u8fed\u4ee3\u6b65\u6570: {required_length}\\n\u5b9e\u9645: {length}'\n            self.\u5355\u53f0\u53d1\u7535\u529f\u7387 = \u5355\u53f0\u53d1\u7535\u529f\u7387 = [self.RatedPower*normalizedPower for normalizedPower  in self.\u8bbe\u5907\u4fe1\u606f.normalizedPower]\n        else:\n            raise Exception(f\"\u672a\u77e5\u98ce\u673a\u7c7b\u578b\uff1a{self.\u8bbe\u5907\u4fe1\u606f.machineType}\")\n        {% endif %}\n        {# \n        # \u8bbe\u5907\u53f0\u6570\u7ea6\u675f\n        {% if class_name not in ['\u4f20\u8f93\u7ebf'] %}\n        {{\u8bbe\u8ba1\u89c4\u5212}}:\n            self.mw.Constraint(self.DeviceCount <= self.MaxDeviceCount)\n            self.mw.Constraint(self.DeviceCount >= self.MinDeviceCount)\n        {% endif %}\n        #}\n        # \u8f93\u51fa\u8f93\u5165\u529f\u7387\u7ea6\u675f\n        {% if class_name in ['\u7535\u89e3\u69fd']%}\n        self.RangeConstraintMulti(self.\u7535\u63a5\u53e3, expression = lambda x: -x <= self.DeviceCount * self.RatedInputPower)"
        },
        {
            "comment": "This code adds disjunctive and range constraints for electrical, hydrogen generation, and waste heat interfaces in a microgrid optimization model. It also creates a starting indicator variable, sets constraints on its values, and calculates the number of annual starts for each unit using quicksum_indexed_var function.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2075-2087",
            "content": "        self.DisjunctiveRangeConstraintMulti(self.\u7535\u63a5\u53e3, expression = lambda x: [[x == 0], [-x >= self.RatedInputPower * self.HydrogenGenerationStartupRate]])\n        self.RangeConstraint(self.\u7535\u63a5\u53e3, self.\u5236\u6c22\u63a5\u53e3, expression = lambda x, y: y == -(x*self.HydrogenGenerationEfficiency)/self.LHVHydrogen)\n        self.RangeConstraint(self.\u7535\u63a5\u53e3, self.\u8bbe\u5907\u4f59\u70ed\u63a5\u53e3, expression = lambda x, y: y == -(x * (1-self.HydrogenGenerationEfficiency))* self.HeatRecycleEfficiency)\n        {# self.RangeConstraint(self.\u7535\u63a5\u53e3, self.\u8bbe\u5907\u4f59\u70ed\u63a5\u53e3, expression = lambda x, y: y == -(x * self.HydrogenGenerationEfficiency)* self.HeatRecycleEfficiency) #}\n        \u542f\u52a8\u6307\u793a\u53d8\u91cf = self.\u53d8\u91cf\u5217\u8868_\u5e26\u6307\u793a\u53d8\u91cf('\u542f\u52a8\u6307\u793a\u53d8\u91cf')\n        self.__setattr__('\u542f\u52a8\u6307\u793a\u53d8\u91cf', \u542f\u52a8\u6307\u793a\u53d8\u91cf)\n        self.mw.Constraint(expr = \u542f\u52a8\u6307\u793a\u53d8\u91cf.x[self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570 - 1] == self.Nrun_indicators.x_pos[0])\n        self.CustomRangeConstraintMulti(self.Nrun_indicators.x_pos, \u542f\u52a8\u6307\u793a\u53d8\u91cf.x, expression = lambda x, y, i: (x[i+1] - x[i]) - 0.5 == y[i], customRange = range(self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570 - 1))\n        self.\u673a\u7ec4\u5e74\u542f\u52a8\u6b21\u6570 = quicksum_indexed_var(self.\u542f\u52a8\u6307\u793a\u53d8\u91cf.x_pos) * (8760/self.\u8ba1\u7b97\u53c2\u6570.\u603b\u8ba1\u7b97\u65f6\u957f)"
        },
        {
            "comment": "The code differentiates between specific cases of devices and constraints. For devices with startup count limit, it ensures the startup count is less than the defined limit. If the computation step size is in seconds, it applies delta limits to the device power input at each iteration. For transmission lines, it calculates total decay per step and sets constraints for power input and output.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2089-2106",
            "content": "        if self.HasStartupCountLimit:\n            # differentiation?\n            startupCount = self.SumRange(\u542f\u52a8\u6307\u793a\u53d8\u91cf.x_pos)\n            self.mw.Constraint(expr = startupCount < self.StartupCountLimit)\n        if self.\u8ba1\u7b97\u53c2\u6570.\u8ba1\u7b97\u6b65\u957f == \"\u79d2\":\n            # TODO: \u5982\u679c\u4f4d\u4e8e\u542f\u52a8\u6216\u8005\u5173\u95ed\u65f6\u523b \u81ea\u52a8\u53bb\u6389\u9650\u5236\n            deltaLimit = self.DeviceCount * self.RatedInputPower * self.\u8bbe\u5907\u4fe1\u606f.DeltaLimit / 100\n            self.CustomRangeConstraintMulti(self.\u7535\u63a5\u53e3, expression = lambda x, i: (x[i+1] - x[i]) >= deltaLimit, customRange = range(self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570 - 1))\n            self.CustomRangeConstraintMulti(self.\u7535\u63a5\u53e3, expression = lambda x, i: (x[i+1] - x[i]) <= deltaLimit, customRange = range(self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570 - 1))\n        {% elif class_name in ['\u4f20\u8f93\u7ebf'] %}\n{# \n        TotalDecayPerStep = self.Length * self.PowerTransferDecay / {{\u65f6\u95f4\u6b65\u957f\u53c2\u6570}}\n        self.RangeConstraint(self.\u7535\u8f93\u5165_\u53bb\u9664\u635f\u8017.x, self.\u7535\u8f93\u5165, lambda x,y: x == y+TotalDecayPerStep )\n        self.RangeConstraint(self.\u7535\u8f93\u5165_\u53bb\u9664\u635f\u8017.x_neg, self.\u7535\u8f93\u51fa,lambda x,y: x == y ) #}\n{#         \n        self.RangeConstraint(self.\u7535\u8f93\u5165, self.PowerInput_.x, expression = lambda x,y: x==y)"
        },
        {
            "comment": "This code defines several RangeConstraint and RangeConstraintMulti constraints for variables related to power input, output, and losses. The lambda functions in the constraints ensure that specific conditions are met, such as equality or inequality between different variable values. There is also a direction constraint using RangeConstraint to limit the sum of two boolean variables to be less than or equal to 1.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2107-2119",
            "content": "        self.RangeConstraint(self.\u7535\u8f93\u51fa, self.PowerOutput_.x, expression = lambda x,y: x==y) #}\n        self.RangeConstraint(self.\u7535\u8f93\u5165, self.inputIndicators.x, expression = lambda x,y: x == y-self.Ploss)\n        self.RangeConstraint(self.\u7535\u8f93\u51fa, self.outputIndicators.x, expression = lambda x,y: x == y-self.Ploss)\n        self.RangeConstraintMulti(self.PowerOutput_.x_pos, self.inputIndicators.x_neg, expression = lambda x,y: x==y)\n        {# self.RangeConstraintMulti(self.PowerOutput_.x_pos, self.inputIndicators.x_neg, self.inputIndicators.b_neg, expression = lambda x,y,z: x==y - 2* z * self.Ploss) #}\n        self.RangeConstraintMulti(self.PowerInput_.x_pos, self.outputIndicators.x_neg, expression = lambda x,y: x==y)\n        {# self.RangeConstraintMulti(self.PowerInput_.x_pos, self.outputIndicators.x_neg, self.outputIndicators.b_neg, expression = lambda x,y,z: x==y - 2* z * self.Ploss) #}\n        {# direction constraint#}\n        self.RangeConstraint(self.PowerInput_.b_pos, self.PowerOutput_.b_pos, expression = lambda x,y: x + y <=1)"
        },
        {
            "comment": "This code segment appears to be working with a class-based structure and implementing range constraints for different types of devices (bidirectional converters, unidirectional converters) in an optimized legacy system. It defines a number of RangeConstraints and DisjunctiveRangeConstraints using lambda functions with the relevant variables. However, there are some incorrect negative input constraints which need to be fixed. Additionally, it seems that there are TODO comments indicating potential issues related to PowerParameter and efficiency that need to be addressed.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2120-2138",
            "content": "        self.RangeConstraint(self.PowerInput_.b_neg, self.PowerOutput_.b_neg, expression = lambda x,y: x + y <=1)\n        {% elif class_name in ['\u53cc\u5411\u53d8\u6d41\u5668'] %}\n        self.RangeConstraint(self.\u7ebf\u8def\u7aef_.x , self.\u7ebf\u8def\u7aef, lambda x,y: x==y)\n        self.RangeConstraint(self.\u50a8\u80fd\u7aef_.x , self.\u50a8\u80fd\u7aef, lambda x,y: x==y)\n        self.DisjunctiveRangeConstraint(self.\u7ebf\u8def\u7aef,self.\u50a8\u80fd\u7aef, expression = lambda x,y: [[x>=0, y<=0, x == -y *self.Efficiency], [x<=0, y>=0, x*self.Efficiency == -y]])\n        # wrong! negative is input.\n        {# self.RangeConstraint(self.\u7ebf\u8def\u7aef_.x_neg, self.\u50a8\u80fd\u7aef_.x_pos,lambda x,y: x == y*self.Efficiency)\n        self.RangeConstraint(self.\u50a8\u80fd\u7aef_.x_neg, self.\u7ebf\u8def\u7aef_.x_pos,lambda x,y: x == y*self.Efficiency) #}\n        {# self.RangeConstraint(self.\u7ebf\u8def\u7aef_.x_neg, self.\u50a8\u80fd\u7aef_.x_pos,lambda x,y: y == x *self.Efficiency)\n        self.RangeConstraint(self.\u50a8\u80fd\u7aef_.x_neg, self.\u7ebf\u8def\u7aef_.x_pos,lambda x,y: y == x *self.Efficiency) #}\n        {% elif class_name in \u5355\u5411\u53d8\u7535\u5668\u5217\u8868 %}\n        # TODO: figure out what \"PowerParameter\" does\n        # TODO: fix efficiency issue"
        },
        {
            "comment": "This code checks the class name and applies specific constraints based on whether it is a transformer or renewable energy device. If not a transformer, it sets power input and output constraints with efficiency and power parameter. If a transformer, it sets separate power input and output constraints and additional multi constraints for both inputs and outputs. For renewable energy devices, it applies the appropriate constraints based on the class name.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2139-2162",
            "content": "        {% if class_name not in ['\u53d8\u538b\u5668']%}\n        self.RangeConstraint(self.\u7535\u8f93\u5165, self.\u7535\u8f93\u51fa, lambda x,y: x * self.Efficiency {{\"* self.PowerParameter\" if class_name in ['\u53d8\u538b\u5668'] else \"\"}} == -y)\n        self.RangeConstraintMulti(self.\u7535\u8f93\u5165, expression=lambda x: -x<=self.RatedPower * self.DeviceCount)\n        {% else %}\n        self.RangeConstraint(\n            self.PowerInput_.x_neg,\n            self.PowerOutput_.x_pos,\n            lambda x, y: x * self.Efficiency * self.PowerParameter == y,\n        )\n        self.RangeConstraint(\n            self.PowerOutput_.x_neg,\n            self.PowerInput_.x_pos,\n            lambda x, y: x * self.Efficiency * self.PowerParameter == y,\n        )\n        self.RangeConstraintMulti(\n            self.PowerInput_.x_neg, expression=lambda x: x <= self.RatedPower * self.DeviceCount\n        )\n        self.RangeConstraintMulti(\n            self.PowerOutput_.x_neg, expression=lambda x: x <= self.RatedPower * self.DeviceCount\n        )\n        {% endif%}\n        {% elif class_name in RenewableEnergyDevices %}"
        },
        {
            "comment": "This code calculates the solar panel efficiency and checks if it falls within the expected range. It then computes the total maximum power and area based on device count, applies constraints to the output, and handles wind turbine power constraints. Additionally, it considers penalties for renewable energy consumption constraints.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2163-2180",
            "content": "            {% if class_name in ['\u5149\u4f0f\u53d1\u7535'] %}\n        \u5149\u7535\u8f6c\u6362\u6548\u7387 = self.MaxPower / self.Area # 1kW/m2\u5149\u7167\u4e0b\u80fd\u4ea7\u751f\u7684\u80fd\u91cf \u7701\u7565\u9664\u4ee51 \u5355\u4f4d: one\n        assert \u5149\u7535\u8f6c\u6362\u6548\u7387<=1, f\"\u5149\u7535\u8f6c\u6362\u6548\u7387\u6570\u503c\u4e0d\u6b63\u5e38: {\u5149\u7535\u8f6c\u6362\u6548\u7387} (\u5e94\u5f53\u57280-1\u4e4b\u95f4)\\n\u5149\u7535\u8f6c\u6362\u6548\u7387 = \u5355\u5757\u6700\u5927\u529f\u7387 / \u5355\u5757\u9762\u79ef\"\n        \u603b\u6700\u5927\u529f\u7387 = self.MaxPower * self.DeviceCount\n        \u603b\u9762\u79ef = self.Area * self.DeviceCount\n        # \u5149\u7167\u5f3a\u5ea6 * \u603b\u9762\u79ef * \u5149\u7535\u8f6c\u6362\u6548\u7387 * \u7535\u7535\u8f6c\u6362\u6548\u7387\n        # (kW/m2) * m2 * one * one -> kW\n        self.RangeConstraintMulti(self.\u8ba1\u7b97\u53c2\u6570.\u5149\u7167, self.\u7535\u8f93\u51fa, self.discardedRenewableEnergyPower, expression = lambda x,y,z: x*\u603b\u9762\u79ef*\u5149\u7535\u8f6c\u6362\u6548\u7387*self.PowerConversionEfficiency == y+z)\n        # BUG: \u9650\u5236\u6700\u5927\u529f\u7387\u8f93\u51fa\uff08\u6807\u51c6\u5149\u7167\u4e0b\uff09\n        self.RangeConstraintMulti(self.\u7535\u8f93\u51fa, expression = lambda x: x <= self.MaxPower*self.DeviceCount*self.PowerConversionEfficiency)\n            {% elif class_name in ['\u98ce\u529b\u53d1\u7535'] %}\n        self.RangeConstraintMulti(\u5355\u53f0\u53d1\u7535\u529f\u7387, self.\u7535\u8f93\u51fa, self.discardedRenewableEnergyPower, expression = lambda x,y,z: x*self.DeviceCount ==y+z)\n            {% endif%}\n        if self.RenewableEnergyConsumptionConstraint == \u65b0\u80fd\u6e90\u6d88\u7eb3\u7ea6\u675f.\u60e9\u7f5a\u4ee3\u4ef7:\n            self.p"
        },
        {
            "comment": "This code is setting up constraints for renewable energy consumption and generator power limits. The constraints are based on the RenewableEnergyConsumptionConstraint parameter, which can be one of three types: limited intake rate, no limit, or unknown (which raises an exception). For certain generator classes like diesel or gas, there are further power limitations set up using RangeConstraintMulti and RangeConstraint functions.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2180-2193",
            "content": "unishRate =(quicksum_indexed_var(self.discardedRenewableEnergyPower)/self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570)* self.RenewableEnergyConsumptionPunishmentRate\n        elif self.RenewableEnergyConsumptionConstraint == \u65b0\u80fd\u6e90\u6d88\u7eb3\u7ea6\u675f.\u9650\u5236\u6d88\u7eb3\u7387:\n            self.mw.Constraint(expr = (1-self.RenewableEnergyConsumptionRate)*quicksum_indexed_var(self.\u7535\u8f93\u51fa) > self.RenewableEnergyConsumptionRate*quicksum_indexed_var(self.discardedRenewableEnergyPower))\n        elif self.RenewableEnergyConsumptionConstraint == \u65b0\u80fd\u6e90\u6d88\u7eb3\u7ea6\u675f.\u65e0:\n            ...\n        else:\n            raise Exception(f\"\u672a\u77e5\u65b0\u80fd\u6e90\u6d88\u7eb3\u7ea6\u675f\uff1a{self.RenewableEnergyConsumptionConstraint}\\n\u5143\u4ef6\u6a21\u578b: {self.__class__.__name__}\")\n        {% elif class_name in ['\u67f4\u6cb9\u53d1\u7535', '\u71c3\u6c14\u53d1\u7535\u673a'] %}\n        {# \u603b\u6700\u5c0f\u542f\u52a8\u529f\u7387 = self.RatedPower * self.PowerStartupLimit * self.DeviceCount #}\n        {# \u603b\u6700\u5c0f\u542f\u52a8\u529f\u7387 = self.RatedPower * self.PowerStartupLimit #}\n        {# \u603b\u6700\u5927\u8f93\u51fa\u529f\u7387 = self.RatedPower * self.DeviceCount #}\n{# \n        self.RangeConstraintMulti(self.\u5355\u53f0\u53d1\u7535\u529f\u7387, expression = lambda x: x <= self.RatedPower)\n        self.RangeConstraint(self.\u539f\u7535\u8f93\u51fa, self.\u7535\u529f\u7387\u4e2d\u8f6c.x, lambda x,y: x == y + \u603b\u6700\u5c0f\u542f\u52a8\u529f\u7387)"
        },
        {
            "comment": "The code is part of a microgrid optimization process, defining constraints and relationships between various variables such as power output, diesel input, and unit planning algorithm selection. It uses functions like Piecewise, RangeConstraintMulti, BinVarMultiplySingle, and RangeConstraint to enforce these constraints and calculate the optimal values for each variable based on the selected algorithm. The code also sets initial values for subModelParamsNeeded and counts the number of sub-unit purchases.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2195-2211",
            "content": "        self.Piecewise(y_var = self.\u5355\u53f0\u67f4\u6cb9\u8f93\u5165, x_var = self.\u5355\u53f0\u53d1\u7535\u529f\u7387, y_vals = [-x[0]*self.RatedPower*x[1] for x in self.DieselToPower_Load], x_vals = [self.RatedPower*x[1] for x in self.DieselToPower_Load])\n        # \u67f4\u6cb9\u8f93\u5165\u7387: L/h\n        self.RangeConstraintMulti(self.\u7535\u529f\u7387\u4e2d\u8f6c.x_pos, self.\u7535\u8f93\u51fa, self.\u7535\u529f\u7387\u4e2d\u8f6c.b_pos, expression = lambda x,y,z: x + self.BinVarMultiplySingle(z,\u603b\u6700\u5c0f\u542f\u52a8\u529f\u7387) == y) #}\n        if self.\u8bbe\u5907\u4fe1\u606f.unitPlanningAlgorithmSelection == \u6cb9\u8017\u89c4\u5212\u7b97\u6cd5.\u5e73\u5747:\n            self.RangeConstraint(self.\u7535\u8f93\u51fa, self.Nrun_indicators.b_pos, lambda x,y: x >= y * self.RatedPower * self.PowerStartupLimit)\n            self.RangeConstraint(self.\u7535\u8f93\u51fa, self.Nrun, lambda x, y: x <= y * self.RatedPower)\n            self.RangeConstraint(self.\u7535\u8f93\u51fa, self.Nrun, lambda x, y: x >= (y-1) * self.RatedPower)\n            self.RangeConstraint(self.\u67f4\u6cb9\u8f93\u5165, self.\u7535\u8f93\u51fa, lambda x, y: -x == self.averageDieselConsumptionRate * y)\n        elif self.\u8bbe\u5907\u4fe1\u606f.unitPlanningAlgorithmSelection == \u6cb9\u8017\u89c4\u5212\u7b97\u6cd5.\u6700\u4f73:\n            \u5b50\u673a\u7ec4\u8d2d\u4e70\u6570\u76ee = 0\n            {% set subModelParamsNeeded = [] %}"
        },
        {
            "comment": "This code is part of a larger script that appears to be optimizing a microgrid. It is iterating through sub-models, creating constraints for each diesel sub-model, and checking the on/off status and power output for those models. The code creates constraints based on whether the sub-model is turned on or off, the rated power of the model, and a BigM value which seems to be used in expressions for some constraints. It also calculates the total sum of all sub-models' parameters and appends them to a list called subModelParamsNeeded. The code appears to be written in Python using the Jinja2 templating engine (judging by the {% %} syntax).",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2212-2237",
            "content": "            {% for p, r in subModelParamsAndRanges %}\n                {% if p not in ['\u662f\u5426\u5f00\u542f'] %}\n                    {% do subModelParamsNeeded.append(p) %}\n                {% endif %}\n            {% endfor %}\n            {% for p in subModelParamsNeeded%}\n            \u5b50\u673a\u7ec4{{p}}\u6c42\u548c = [0]* self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570\n            {% endfor%}\n            for i in range(self.\u5b50\u673a\u7ec4\u6570\u76ee):\n                logger_print(f\"\u6b63\u5728\u4e3a\u7b2c{i+1}\u4e2a\u67f4\u6cb9\u5b50\u673a\u7ec4\u6a21\u578b\u521b\u5efa\u7ea6\u675f\")\n                \u5b50\u673a\u7ec4\u6a21\u578b:\u8bbe\u5907\u6a21\u578b = self.\u5b50\u673a\u7ec4\u5217\u8868[i]\n            {% for p, r in subModelParamsAndRanges%}\n                \u5b50\u673a\u7ec4{{p}} = self.\u5b50\u673a\u7ec4{{p}}\u5217\u8868[i]\n            {% endfor%}\n                \u5b50\u673a\u7ec4\u662f\u5426\u8d2d\u4e70 = self.\u5b50\u673a\u7ec4\u662f\u5426\u8d2d\u4e70[i]\n                \u5b50\u673a\u7ec4\u6a21\u578b.RangeConstraintMulti(\u5b50\u673a\u7ec4\u7535\u8f93\u51fa, expression = lambda x: x <= \u5b50\u673a\u7ec4\u662f\u5426\u8d2d\u4e70 * self.BigM)\n                \u5b50\u673a\u7ec4\u6a21\u578b.RangeConstraint(\u5b50\u673a\u7ec4\u7535\u8f93\u51fa, \u5b50\u673a\u7ec4\u662f\u5426\u5f00\u542f, expression = lambda x,y: x <= y * self.RatedPower)\n                \u5b50\u673a\u7ec4\u6a21\u578b.RangeConstraint(\u5b50\u673a\u7ec4\u7535\u8f93\u51fa, \u5b50\u673a\u7ec4\u662f\u5426\u5f00\u542f, expression = lambda x,y: x >= y * self.RatedPower * self.PowerStartupLimit)\n                \u5b50\u673a\u7ec4\u6a21\u578b.RangeConstraint(\u5b50\u673a\u7ec4\u662f\u5426\u5f00\u542f, \u5b50\u673a\u7ec4\u662f\u5426\u771f\u7684\u5f00\u542f, expression = lambda x,y: \u5b50\u673a\u7ec4\u6a21\u578b.BinVarMultiplySingle(\u5b50\u673a\u7ec4\u662f\u5426\u8d2d\u4e70, x) == y)"
        },
        {
            "comment": "This code is calculating the summation of subModelParamsNeeded for a subgroup model, setting constraints on the electrical output power delta based on the PowerDeltaLimit and the computation parameters' iteration steps. It also adds piecewise functions to the diesel input based on the electrical output power and rate.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2238-2256",
            "content": "                {# for j in range(self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570): #}\n                    {# \u5b50\u673a\u7ec4\u662f\u5426\u771f\u7684\u5f00\u542f\u6c42\u548c[j] += \u5b50\u673a\u7ec4\u662f\u5426\u771f\u7684\u5f00\u542f[j] #}\n                if self.\u8ba1\u7b97\u53c2\u6570.\u8ba1\u7b97\u6b65\u957f == \"\u79d2\":\n                    # deltalimit\n                    subModelElectricityPowerDeltaLimit = self.RatedPower * self.PowerDeltaLimit / 100\n                    \u5b50\u673a\u7ec4\u6a21\u578b.CustomRangeConstraintMulti(\u5b50\u673a\u7ec4\u7535\u8f93\u51fa,\u5b50\u673a\u7ec4\u662f\u5426\u771f\u7684\u5f00\u542f, customRange = range(self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570), expression = lambda x,y,i: x[i+1] - x[i]>= -subModelElectricityPowerDeltaLimit*y)\n                    \u5b50\u673a\u7ec4\u6a21\u578b.CustomRangeConstraintMulti(\u5b50\u673a\u7ec4\u7535\u8f93\u51fa,\u5b50\u673a\u7ec4\u662f\u5426\u771f\u7684\u5f00\u542f, customRange = range(self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570), expression = lambda x,y,i: x[i+1] - x[i]<=subModelElectricityPowerDeltaLimit*y)\n            {% for p in subModelParamsNeeded %}\n                \u5b50\u673a\u7ec4{{p}}\u6c42\u548c = \u5b50\u673a\u7ec4\u6a21\u578b.TimeSummation(\u5b50\u673a\u7ec4{{p}}\u6c42\u548c, \u5b50\u673a\u7ec4{{p}})\n            {% endfor %}\n                \u5b50\u673a\u7ec4\u6a21\u578b.Piecewise(\n                    y_var=\u5b50\u673a\u7ec4\u67f4\u6cb9\u8f93\u5165,\n                    x_var=\u5b50\u673a\u7ec4\u7535\u8f93\u51fa,\n                    y_vals=[-x[0] * self.RatedPower * x[1] for x in self.DieselToPower_Load],\n                    x_vals=[self.RatedPower * x[1] for x in self.DieselToPower_Load],"
        },
        {
            "comment": "This code is setting constraints for a microgrid device based on its type. It checks the device's planning algorithm and applies appropriate constraints such as total count, power input/output sums, and capacity limitations. If the algorithm is unknown or if it's a lithium battery, it sets constraints on current total capacity and initial capacity per unit. There are also conditional comments related to storage decay compensation.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2257-2278",
            "content": "                )\n            \u5b50\u673a\u7ec4\u8d2d\u4e70\u6570\u76ee = quicksum_indexed_var(self.\u5b50\u673a\u7ec4\u662f\u5426\u8d2d\u4e70)\n            self.mw.Constraint(expr = \u5b50\u673a\u7ec4\u8d2d\u4e70\u6570\u76ee == self.DeviceCount)\n            self.RangeConstraint(self.Nrun, \u5b50\u673a\u7ec4\u662f\u5426\u771f\u7684\u5f00\u542f\u6c42\u548c, expression = lambda x,y: x==y)\n            {% for p in ['\u67f4\u6cb9\u8f93\u5165', '\u7535\u8f93\u51fa'] %}\n            self.RangeConstraint(self.{{p}}, \u5b50\u673a\u7ec4{{p}}\u6c42\u548c, expression = lambda x,y: x==y)\n            {% endfor %}\n        else:\n            raise Exception(f\"\u672a\u77e5\u6cb9\u8017\u89c4\u5212\u7b97\u6cd5\uff1a{self.\u8bbe\u5907\u4fe1\u606f.unitPlanningAlgorithmSelection}\") \n        {% elif class_name in ['\u9502\u7535\u6c60'] %}\n        {# self.RangeConstraintMulti(self.CurrentTotalActualCapacity, expression = lambda x: x <= self.TotalActualCapacity) #}\n        self.mw.Constraint(self.CurrentTotalCapacity[0] == self.InitCapacityPerUnit * self.DeviceCount)\n        {# self.mw.Constraint(self.CurrentTotalActualCapacity[0] == self.InitActualCapacityPerUnit * self.DeviceCount) #}\n            {# {% if needStorageDecayCompensation%} #}\n        {# if self.needStorageDecayCompensation: #}\n            {# S(t) - (1-sigma*deltaT)*S(t-1) = (p0_pos - p0_neg)*deltaT #}"
        },
        {
            "comment": "This code section sets the deltaT value and defines two constraint functions for the microgrid model. The CustomRangeConstraintMulti function applies a constraint to the original interface's x values, while RangeConstraintMulti enforces constraints on the interface's x_pos and x_neg values. The functions use lambda expressions to calculate the differences between time-step values based on specified parameters such as deltaT, sigma, ChargeEfficiency, DischargeEfficiency, and TotalStoragePowerOfDecay.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2279-2299",
            "content": "            {# deltaT = 1 if \u8ba1\u7b97\u6b65\u957f == \u5c0f\u65f6 else 1/3600 #}\n        self.CustomRangeConstraintMulti(\n            self.\u539f\u7535\u63a5\u53e3.x,\n            self.CurrentTotalCapacity,\n            {# self.CurrentTotalPowerOfDecayCompensated, #}\n            customRange = range(self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570 - 1),\n            expression = \n            lambda x, y, i: x[i] *self.\u8ba1\u7b97\u53c2\u6570.deltaT == (y[i] * (1- self.\u8ba1\u7b97\u53c2\u6570.deltaT * self.sigma)  - y[i + 1])\n            {# lambda x, y, z, i: x[i] - z[i] == (y[i] - y[i + 1]) * self.\u8ba1\u7b97\u53c2\u6570.\u65f6\u95f4\u53c2\u6570, #}\n        )\n        self.RangeConstraintMulti(\n            self.\u539f\u7535\u63a5\u53e3.x_pos,\n            self.\u539f\u7535\u63a5\u53e3.x_neg,\n            self.\u7535\u63a5\u53e3,\n            {# self.CurrentTotalPowerOfDecayCompensated,  #}\n            expression=lambda x_pos, x_neg, y: x_pos * self.DischargeEfficiency - (x_neg) / self.ChargeEfficiency == y,\n            {# expression=lambda x_pos, x_neg, y, z: x_pos * self.DischargeEfficiency- (x_neg + (self.TotalStoragePowerOfDecay - z)) / self.ChargeEfficiency== y, #}\n        )\n        {# {% else%} #}\n{#             \n        else:"
        },
        {
            "comment": "This code defines a range constraint for a microgrid base and adds constraints to ensure the total capacity and power flow within certain limits. The constraints include a custom range constraint, a range constraint multi, and two range constraint single. It also checks for storage decay compensation and sets a range constraint multi for absolute charging/discharging rates. The code iterates through steps in the calculation parameters.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2300-2313",
            "content": "            self.CustomRangeConstraint(self.\u539f\u7535\u63a5\u53e3.x, self.CurrentTotalCapacity, customRange = range(self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570-1),expression =  lambda x,y,i: x[i] == (y[i] - y[i+1]) * {{\u65f6\u95f4\u6b65\u957f\u53c2\u6570}})\n            self.RangeConstraintMulti(self.\u539f\u7535\u63a5\u53e3.x_pos, self.\u539f\u7535\u63a5\u53e3.x_neg, self.\u7535\u63a5\u53e3,expression = lambda x_pos, x_neg, y: x_pos * self.DischargeEfficiency - (x_neg + self.TotalStoragePowerOfDecay)/self.ChargeEfficiency == y) \n         #}\n            {# {% endif%} #}\n        {# power = delta(capacity)/delta(time)#}\n            {# {% if needStorageDecayCompensation%} #}\n            {# {%else%} #}\n            {# {% endif%} #}\n        {# for i in range(self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570): #}\n        self.RangeConstraintMulti(self.\u539f\u7535\u63a5\u53e3.x_abs, expression = lambda x: x <= self.MaxTotalChargeOrDischargeRate)\n        {# for i in range(self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570-1): #}\n            {# \n            self.mw.Constraint(self.CurrentTotalCapacity[i+1] - self.CurrentTotalCapacity[i] <= self.MaxTotalCapacityDeltaPerStep)\n            self.mw.Constraint(self.CurrentTotalCapacity[i+1] - self.CurrentTotalCapacity[i] >= -self.MaxTotalCapacityDeltaPerStep)"
        },
        {
            "comment": "If self.\u8bbe\u5907\u4fe1\u606f.\u5faa\u73af\u8fb9\u754c\u6761\u4ef6 is '\u65e5\u95f4\u72ec\u7acb', set the original interface's x[0] to EPS, and override any suspicious constraints with init values. If self.\u8bbe\u5907\u4fe1\u606f.\u5faa\u73af\u8fb9\u754c\u6761\u4ef6 is '\u65e5\u95f4\u8fde\u63a5', add constraints for the CurrentTotalCapacity changes. If needStorageDecayCompensation, add a constraint for the original interface's x[0] equal to the difference between current total capacity and decay compensated power at step 0.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2314-2333",
            "content": "            #}\n{# \n        {{\u8bbe\u8ba1\u89c4\u5212}}:\n            # if self.\u8bbe\u5907\u4fe1\u606f.\u5faa\u73af\u8fb9\u754c\u6761\u4ef6 == '\u65e5\u95f4\u72ec\u7acb':\n                # self.mw.Constraint(self.\u539f\u7535\u63a5\u53e3.x[0] == self.EPS)\n                # BUG: override suspicious constraints with init values.\n                # self.\u539f\u7535\u63a5\u53e3.x[0].set_value(self.EPS)\n            if self.\u8bbe\u5907\u4fe1\u606f.\u5faa\u73af\u8fb9\u754c\u6761\u4ef6 == '\u65e5\u95f4\u8fde\u63a5':\n                self.mw.Constraint(self.CurrentTotalCapacity[0] - self.CurrentTotalCapacity[self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570-1] <=self.MaxTotalCapacityDeltaPerStep)\n                self.mw.Constraint(self.CurrentTotalCapacity[0] - self.CurrentTotalCapacity[self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570-1] >=-self.MaxTotalCapacityDeltaPerStep)\n                if self.needStorageDecayCompensation:\n            # {% if needStorageDecayCompensation%}\n                    self.mw.Constraint(\n                        self.\u539f\u7535\u63a5\u53e3.x[0] - self.CurrentTotalPowerOfDecayCompensated[0]\n                        == (\n                            self.CurrentTotalCapacity[self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570 - 1]\n                            - self.CurrentTotalCapacity[0]\n                        )"
        },
        {
            "comment": "This code checks the simulation type and the iteration number to set constraints for power output and perform calculations. It also includes a time step parameter and applies deltaT for power adjustment, and applies constraints for certain device types (like solar, wind, diesel, or gas generators). If the computation type is simulation, it sets the value directly. The code also checks if the typical day option is enabled and imposes constraints accordingly. It includes a condition to limit second-level power changes with specific variable limits for certain device classes.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2334-2356",
            "content": "                        * self.\u8ba1\u7b97\u53c2\u6570.\u65f6\u95f4\u53c2\u6570\n                    )\n            # {%else%}\n                else:\n                    self.mw.Constraint(self.\u539f\u7535\u63a5\u53e3.x[0] == (self.CurrentTotalCapacity[self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570-1] - self.CurrentTotalCapacity[0]) * {{\u65f6\u95f4\u6b65\u957f\u53c2\u6570}})\n            # {% endif%} \n            else:\n                raise Exception(\"\u672a\u77e5\u5faa\u73af\u8fb9\u754c\u6761\u4ef6:\", self.\u8bbe\u5907\u4fe1\u606f.\u5faa\u73af\u8fb9\u754c\u6761\u4ef6)\n        else: # \u4eff\u771f\u6a21\u62df\n        # elif self.\u8ba1\u7b97\u53c2\u6570.\u8ba1\u7b97\u7c7b\u578b == \"\u4eff\u771f\u6a21\u62df\": \n            # self.mw.Constraint(self.\u539f\u7535\u63a5\u53e3.x[0] == self.EPS) \n            self.\u539f\u7535\u63a5\u53e3.x[0].set_value(self.EPS) #}\n        if self.\u8ba1\u7b97\u53c2\u6570.\u5178\u578b\u65e5:\n            self.mw.Constraint(self.CurrentTotalCapacity[self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570 - 1] == self.CurrentTotalCapacity[0])\n            {# self.mw.Constraint((lambda x, y: x[self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570 - 1] *self.\u8ba1\u7b97\u53c2\u6570.deltaT == (y[self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570 - 1] * (1- self.\u8ba1\u7b97\u53c2\u6570.deltaT * self.sigma)  - y[0])) (self.\u539f\u7535\u63a5\u53e3.x, self.CurrentTotalCapacity)) #}\n        {% endif %}\n        {# \u79d2\u7ea7\u529f\u7387\u53d8\u5316\u9650\u5236\uff0c\u6709\u7279\u5b9a\u7684\u53d8\u91cf\u9650\u5236 #}\n        {% if class_name in ['\u5149\u4f0f\u53d1\u7535', '\u98ce\u529b\u53d1\u7535', '\u67f4\u6cb9\u53d1\u7535', '\u71c3\u6c14\u53d1\u7535\u673a'] %}\n            {% set extraDeltaLimitConditions = {"
        },
        {
            "comment": "This code checks the device type and applies power delta limit conditions accordingly. It calculates the maximum power and power change limits for different device types, then sets constraints on the output power for each time step using lambda expressions.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2357-2369",
            "content": "                \"\u98ce\u529b\u53d1\u7535\":\" and self.\u8bbe\u5907\u4fe1\u606f.machineType != \u98ce\u529b\u53d1\u7535\u7c7b\u578b.\u6807\u5e7a\u503c\",\n                \"\u67f4\u6cb9\u53d1\u7535\":\" and self.\u8bbe\u5907\u4fe1\u606f.unitPlanningAlgorithmSelection != \u6cb9\u8017\u89c4\u5212\u7b97\u6cd5.\u6700\u4f73\",\n                \"\u71c3\u6c14\u53d1\u7535\u673a\":\" and self.\u8bbe\u5907\u4fe1\u606f.unitPlanningAlgorithmSelection != \u6cb9\u8017\u89c4\u5212\u7b97\u6cd5.\u6700\u4f73\"\n            }%}\n        {{\u79d2}} {{extraDeltaLimitConditions.get(class_name, \"\")}}:\n            \u603b\u6700\u5927\u529f\u7387 = {{'self.MaxPower' if class_name in ['\u5149\u4f0f\u53d1\u7535'] else 'self.RatedPower'}} * self.DeviceCount\n            \u6700\u5927\u529f\u7387\u53d8\u5316 = \u603b\u6700\u5927\u529f\u7387 * self.PowerDeltaLimit / 100\n            {% if class_name in ['\u67f4\u6cb9\u53d1\u7535', '\u71c3\u6c14\u53d1\u7535\u673a'] %}\n            \u6700\u5927\u4e0b\u884c\u529f\u7387\u53d8\u5316\u751f\u6210 = lambda Nrun_t: Nrun_t * self.RatedPower * self.PowerDeltaLimit / 100\n            {% endif %}\n            self.CustomRangeConstraintMulti(self.\u7535\u8f93\u51fa , customRange = range(self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570-1), expression = lambda x,i: x[i+1] - x[i] <= \u6700\u5927\u529f\u7387\u53d8\u5316)\n            {% if class_name in ['\u67f4\u6cb9\u53d1\u7535', '\u71c3\u6c14\u53d1\u7535\u673a']%}\n            self.CustomRangeConstraintMulti(self.\u7535\u8f93\u51fa, self.Nrun, customRange = range(self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570-1), expression = lambda x,y,i: x[i+1] - x[i] >= -\u6700\u5927\u4e0b\u884c\u529f\u7387\u53d8\u5316\u751f\u6210(y[i]))"
        },
        {
            "comment": "Code calculates the lifetime discharge capacity for a lithium battery, using rated capacity and lifecycle count. It also computes the average power over the simulation range and estimates the annual energy output based on hourly energy output and yearly hours.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2370-2401",
            "content": "            {% else %}\n            self.CustomRangeConstraintMulti(self.\u7535\u8f93\u51fa, customRange =  range(self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570-1),expression = lambda x,i: x[i+1] - x[i] >= -\u6700\u5927\u529f\u7387\u53d8\u5316)\n            {% endif %}\n        {% endif %}\n        {# elif self.\u8ba1\u7b97\u53c2\u6570.\u8ba1\u7b97\u6b65\u957f == \"\u5c0f\u65f6\":\n            ... # skip it.\n        else:\n            raise Exception(\"\u672a\u77e5\u8ba1\u7b97\u6b65\u957f:\", self.\u8ba1\u7b97\u53c2\u6570.\u8ba1\u7b97\u6b65\u957f) #}\n        # \u8ba1\u7b97\u5e74\u5316\n        # unit: one\n        {# if \u8ba1\u7b97\u53c2\u6570.\u8ba1\u7b97\u7c7b\u578b == \"\u89c4\u5212\u8bbe\u8ba1\": #}\n        {# \u89c4\u5212\u8bbe\u8ba1\u548c\u4eff\u771f\u6a21\u62df\u90fd\u9700\u8981\u8ba1\u7b97\u5e74\u5316 #}\n        {%with%}\n        {% if class_name in ['\u9502\u7535\u6c60'] %} \n        # TODO: to get LifetimeDischargeCapacityPerUnit working\n        self.LifetimeDischargeCapacityPerUnit = self.LifetimeCycleCount * self.RatedCapacity\n        \"\"\"\n        \u5355\u5757\u7535\u6c60\u751f\u547d\u5468\u671f\u603b\u653e\u7535\u91cf\n        \u5355\u4f4d: kWh\n        \"\"\"\n        \u8ba1\u7b97\u8303\u56f4\u5185\u603b\u5e73\u5747\u653e\u7535\u529f\u7387 = (self.SumRange(self.\u539f\u7535\u63a5\u53e3.x_pos)/self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570)# kW\n        {# \u8ba1\u7b97\u8303\u56f4\u5185\u603b\u5e73\u5747\u529f\u7387 = (self.SumRange(self.\u539f\u7535\u63a5\u53e3.x_abs)/self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570)+ self.TotalStoragePowerOfDecay # kW #}\n        # avg power\n        \u4e00\u5c0f\u65f6\u603b\u7535\u53d8\u5316\u91cf = \u8ba1\u7b97\u8303\u56f4\u5185\u603b\u5e73\u5747\u653e\u7535\u529f\u7387 # \u7701\u7565\u4e581\n        {# \u4e00\u5c0f\u65f6\u603b\u7535\u53d8\u5316\u91cf = \u8ba1\u7b97\u8303\u56f4\u5185\u603b\u5e73\u5747\u529f\u7387 #}\n        # kWh\n        \u4e00\u5e74\u603b\u7535\u53d8\u5316\u91cf = \u4e00\u5c0f\u65f6\u603b\u7535\u53d8\u5316\u91cf * \u6bcf\u5e74\u5c0f\u65f6\u6570"
        },
        {
            "comment": "This code sets the lifespan of a battery-based device and calculates its annual rate. If the device is a solar PV, it assigns specific variables for maximum power, units, etc. If the device is a wind turbine or unidirectional transformer, it uses the rated power multiplied by the number of devices. For diesel generators, electrolysis cells, and gasoline engines, it considers the device count. The code also defines variables for different power units and types.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2403-2426",
            "content": "        self.mw.Constraint(\u4e00\u5e74\u603b\u7535\u53d8\u5316\u91cf * self.BatteryLife <= self.DeviceCount * self.LifetimeDischargeCapacityPerUnit * 0.85)\n        assert self.BatteryLife >=1\n        assert self.Life >= self.BatteryLife\n        Life = self.BatteryLife\n        {%else%}\n        Life = self.Life\n        {%endif%}\n        self.\u5e74\u5316\u7387 = \u8ba1\u7b97\u5e74\u5316\u7387(self.\u8ba1\u7b97\u53c2\u6570.\u8d34\u73b0\u7387, Life)\n        {# self.\u5e74\u5316\u7387 = ((1+(self.\u8ba1\u7b97\u53c2\u6570.\u5e74\u5229\u7387/100)) ** Life) / Life #}\n        {% if class_name in ['\u5149\u4f0f\u53d1\u7535'] %}\n            {% set m = '\u603b\u6700\u5927\u529f\u7387' %}\n            {% set vi = 'Kilowatt' %}\n            {% set vm = 'Kilowatt' %}\n            {% set vb = 'Kilowatt' %}\n            {% set vv = 'Work' %}\n        {% elif class_name in ['\u98ce\u529b\u53d1\u7535'] + \u5355\u5411\u53d8\u7535\u5668\u5217\u8868 + ['\u53cc\u5411\u53d8\u6d41\u5668'] %}\n            {% set m = 'self.DeviceCount * self.RatedPower' %}\n            {% set vi = 'Kilowatt' %}\n            {% set vm = 'Kilowatt' %}\n            {% set vb = 'Kilowatt' %}\n            {% set vv = 'Work' %}\n        {% elif class_name in ['\u67f4\u6cb9\u53d1\u7535', '\u7535\u89e3\u69fd', '\u71c3\u6c14\u53d1\u7535\u673a'] %}\n            {% set m='self.DeviceCount' %}\n            {% set vi = 'Machine' %}"
        },
        {
            "comment": "This code is dynamically setting variables based on the device type. For 'Machine' devices, it sets capacity as the variable; for '\u9502\u7535\u6c60', it calculates cost and capacity based on rated capacity; for '\u4f20\u8f93\u7ebf', it sets kilometer as the variable; for unsupported types, it raises an error. It then calculates total purchase cost, fixed maintenance cost, build costs, and annualized fixed cost based on these variables and other factors.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2427-2452",
            "content": "            {% set vm = 'Machine' %}\n            {% set vb = 'Machine' %}\n            {% set vv = 'Work' %}\n        {% elif class_name in [\"\u9502\u7535\u6c60\"] %}\n            {% set m='self.DeviceCount * self.RatedCapacity' %}\n            {% set vi = 'Capacity' %}\n            {% set vm = 'Capacity' %}\n            {% set vb = 'Capacity' %}\n            {% set vv = 'Work' %}\n        {% elif class_name in ['\u4f20\u8f93\u7ebf'] %}\n            {% set m='self.Length' %}\n            {% set vi = 'Kilometer' %}\n            {% set vm = 'Kilometer' %}\n            {% set vb = 'Kilometer' %}\n        {% else %}\n            {% error(\"\u4e0d\u652f\u6301\u7684\u8bbe\u5907\u7c7b\u578b:\", class_name) %}\n        {% endif %}\n        self.\u603b\u91c7\u8d2d\u6210\u672c = self.CostPer{{vi}} * ({{ m}}) \n        self.\u603b\u56fa\u5b9a\u7ef4\u62a4\u6210\u672c = self.CostPerYearPer{{vm}} * ({{ m}})\n        self.\u603b\u5efa\u8bbe\u8d39\u7528 = self.BuildCostPer{{vb}} * ({{ m}}) + self.BuildBaseCost\n        self.\u603b\u56fa\u5b9a\u6210\u672c\u5e74\u5316 = (self.\u603b\u91c7\u8d2d\u6210\u672c + self.\u603b\u5efa\u8bbe\u8d39\u7528) * self.\u5e74\u5316\u7387 + self.\u603b\u56fa\u5b9a\u7ef4\u62a4\u6210\u672c\n        {# self.\u603b\u56fa\u5b9a\u6210\u672c\u5e74\u5316 = (self.\u603b\u91c7\u8d2d\u6210\u672c + self.\u603b\u56fa\u5b9a\u7ef4\u62a4\u6210\u672c + self.\u603b\u5efa\u8bbe\u8d39\u7528) * self.\u5e74\u5316\u7387 #}\n        {% if class_name in ['\u5149\u4f0f\u53d1\u7535', '\u98ce\u529b\u53d1\u7535', '\u67f4\u6cb9\u53d1\u7535', '\u71c3\u6c14\u53d1\u7535\u673a']%}"
        },
        {
            "comment": "This code sets the value of `m1` depending on the class_name. For '\u7535\u89e3\u69fd', it is -SumRange(self.\u7535\u63a5\u53e3). For '\u9502\u7535\u6c60', it calculates the average discharging power * self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570. For single-direction transformer or transmission line, it sets m1 accordingly based on whether it's a transformer or a transmission line. If class_name is '\u53cc\u5411\u53d8\u6d41\u5668', it sums the ranges of \u50a8\u80fd\u7aef_.x_neg and \u7ebf\u8def\u7aef_.x_neg. For '\u4f20\u8f93\u7ebf', m1 is set to 0. If class_name is not '\u4f20\u8f93\u7ebf', it throws an error for unsupported types.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2453-2474",
            "content": "            {% set m1=\"self.SumRange(self.\u7535\u8f93\u51fa)\" %}\n        {% elif class_name in ['\u7535\u89e3\u69fd'] %}\n            {% set m1=\"-self.SumRange(self.\u7535\u63a5\u53e3)\" %}\n        {% elif class_name in ['\u9502\u7535\u6c60'] %}\n            {% set m1=\"\u8ba1\u7b97\u8303\u56f4\u5185\u603b\u5e73\u5747\u653e\u7535\u529f\u7387*self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570\"%}\n            {# {% set m1=\"\u8ba1\u7b97\u8303\u56f4\u5185\u603b\u5e73\u5747\u529f\u7387*self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570\"%} #}\n        {% elif class_name in \u5355\u5411\u53d8\u7535\u5668\u5217\u8868 %}\n        {# {% elif class_name in \u5355\u5411\u53d8\u7535\u5668\u5217\u8868+['\u4f20\u8f93\u7ebf']%} #}\n            {% if class_name in ['\u53d8\u538b\u5668'] %}\n            {# {% if class_name in ['\u53d8\u538b\u5668', '\u4f20\u8f93\u7ebf']%} #}\n            {% set m1 = '(self.SumRange(self.PowerInput_.x_neg) + self.SumRange(self.PowerOutput_.x_neg))'%}\n            {% else%}\n            {% set m1='-self.SumRange(self.\u7535\u8f93\u5165)'%}\n            {% endif%}\n        {% elif class_name in ['\u53cc\u5411\u53d8\u6d41\u5668'] %}\n            {% set m1='(self.SumRange(self.\u50a8\u80fd\u7aef_.x_neg)+self.SumRange(self.\u7ebf\u8def\u7aef_.x_neg))'%}\n        {%elif class_name in ['\u4f20\u8f93\u7ebf'] %}\n            {% set m1='0' %}\n        {% else %}\n            {% error(\"\u4e0d\u652f\u6301\u7684\u7c7b\u578b:\", class_name) %}\n        {% endif %}\n        {% if class_name not in ['\u4f20\u8f93\u7ebf'] %}"
        },
        {
            "comment": "Calculates the total annualized variable maintenance cost for microgrid devices, including startup costs for some generators. The final output is processed if the class name is not a transmission line.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2475-2506",
            "content": "        {# \u603b\u53ef\u53d8\u7ef4\u62a4\u6210\u672c\u5e74\u5316 = ({{m1}}) * (8760 / self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570) * ({{\u65f6\u95f4\u6b65\u957f\u53c2\u6570}}) *self.VariationalCostPer{{vv}} #}\n        self.\u603b\u53ef\u53d8\u7ef4\u62a4\u6210\u672c\u5e74\u5316 = (({{m1}}) / self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570) * \u6bcf\u5e74\u5c0f\u65f6\u6570 * self.VariationalCostPer{{vv}}\n        # avg_power * 8760 = annual_work\n        {% if class_name in ['\u67f4\u6cb9\u53d1\u7535', '\u71c3\u6c14\u53d1\u7535\u673a'] %}\n        self.\u603b\u53ef\u53d8\u7ef4\u62a4\u6210\u672c\u5e74\u5316 += self.annualUnitStartupCosts\n        {% endif %}\n        self.\u603b\u6210\u672c\u5e74\u5316 = self.\u603b\u56fa\u5b9a\u6210\u672c\u5e74\u5316 + self.\u603b\u53ef\u53d8\u7ef4\u62a4\u6210\u672c\u5e74\u5316\n        {% else %}\n        self.\u603b\u6210\u672c\u5e74\u5316 = self.\u603b\u56fa\u5b9a\u6210\u672c\u5e74\u5316\n        {% endif %}\n        {% endwith %}\n        {% if class_name != \"\u4f20\u8f93\u7ebf\" %}\n        {# \u5ffd\u7565\u4f20\u8f93\u7ebf #}\n        self.\u5904\u7406\u6700\u7ec8\u8d22\u52a1\u8f93\u51fa(self)\n        {% endif %}\n        return self.\u603b\u6210\u672c\u5e74\u5316\n{% endfor %}\n{% set load_class_names = [] %}\n{% for v in load_types %}\n    {% do load_class_names.append(v+\"\u8d1f\u8377\")%}\n{% endfor %}\n{% set input_class_names = input_types%}\n{% set special_classes = {\"load_class\": load_class_names, \"input_class\": input_class_names} %}\n{# check for coverage #}\n{% for class_name in \u8bbe\u5907\u63a5\u53e3\u96c6\u5408.keys() %}\n    {% if class_name not in NonLoadDeviceDict.keys() %}\n        {% if class_name not in input_class_names+load_class_names%}"
        },
        {
            "comment": "This code is creating a class for load models, checking if the name ends with \"load\" and setting load attributes based on device information. It also performs error handling and asserts the number of energy consumption values in the device information matches the number of iterations specified by the computing parameters.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2507-2534",
            "content": "            {% error(\"\u672a\u8986\u76d6\u7684\u975e\u8bbe\u5907\u7c7b\u578b:\", class_name)%}\n        {% endif%}\n    {% endif%}\n{% endfor%}\n{% for k,clist in special_classes.items() %}\n    {% for class_name in clist %}\nclass {{class_name}}\u6a21\u578b(\u8bbe\u5907\u6a21\u578b):\n{{ init_super_class(class_name) }}\n{{ port_variable_define(class_name)}}\n    {% if k == \"load_class\"%}\n        {% if not class_name.endswith('\u8d1f\u8377') %}\n            {% error(\"\u9519\u8bef\u7684\u8d1f\u8377\u7c7b\u540d:\", class_name) %}\n        {% else %}\n            {% set v = class_name.strip(\"\u8d1f\u8377\") %}\n        {% endif %}\n        assert len(self.\u8bbe\u5907\u4fe1\u606f.EnergyConsumption) == self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570\n        {% set loadInfoAttrNameList = ['Pmin', 'Pmax', 'PunishmentRate', 'EnergyConsumption'] %}\n        {% for loadInfoAttrName in loadInfoAttrNameList %}\n        self.{{loadInfoAttrName}} = self.\u8bbe\u5907\u4fe1\u606f.toStandard({{repr(loadInfoAttrName)}})\n        {% endfor %}\n        # deal with MaxEnergyConsumption & PriceModel separately\n        if self.\u8bbe\u5907\u4fe1\u606f.LoadType == \u8d1f\u8377\u7c7b\u578b.Punished:\n            self.UnsatisfiedEnergyConsumption = self.\u53d8\u91cf\u5217\u8868(\n            \"UnsatisfiedEnergyConsumption\", within=NonNegativeReals"
        },
        {
            "comment": "Code is setting the default value for MaxEnergyConsumption based on the EnergyConsumption values, and initializing IncomeRates, punishRate, and PriceModel. For input_class, it defines a class with attributes for each default unit in \u71c3\u6599\u80fd\u6e90\u76f8\u5173\u6570\u636e\u9ed8\u8ba4\u5355\u4f4d[class_name].",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2535-2569",
            "content": "        )\n        if \u8d1f\u8377\u7c7b\u578b.Interruptable in self.\u8bbe\u5907\u4fe1\u606f.LoadType:\n            self.Interrupted = self.\u53d8\u91cf\u5217\u8868(\n            \"Interrupted\", within=Boolean)\n            # Binary is ok.\n        {% if v in ['\u7535'] %}\n        MaxEnergyConsumptionDefault = max(self.EnergyConsumption)\n        if self.\u8bbe\u5907\u4fe1\u606f.MaxEnergyConsumption is None:\n            self.MaxEnergyConsumption = MaxEnergyConsumptionDefault\n        else:\n            assert self.\u8bbe\u5907\u4fe1\u606f.MaxEnergyConsumption >= MaxEnergyConsumptionDefault\n            self.MaxEnergyConsumption = self.\u8bbe\u5907\u4fe1\u606f.toStandard('MaxEnergyConsumption')\n        {% endif %}\n        self.IncomeRates = ...\n        self.punishRate = 0\n        self.PriceModel = self.\u8bbe\u5907\u4fe1\u606f.PriceModel\n    {% elif k == 'input_class' %}\n        class _Units(BaseModel):\n        {% for attrName, defaultUnit in \u71c3\u6599\u80fd\u6e90\u76f8\u5173\u6570\u636e\u9ed8\u8ba4\u5355\u4f4d[class_name].items() %}\n            {{attrName}}: str\n        {% endfor %}\n        UnitsDict = {}\n        {% for attrName, defaultUnit in \u71c3\u6599\u80fd\u6e90\u76f8\u5173\u6570\u636e\u9ed8\u8ba4\u5355\u4f4d[class_name].items() %}\n        ## PROCESSING: {{attrName}}\n        ### UNIT COMPATIBILITY CHECK ###"
        },
        {
            "comment": "This code is performing unit conversion and compatibility checks for variables in a microgrid system. It first checks if the value unit is compatible with the default unit, then calculates the conversion rate between them using the 'unitFactorCalculator' function. The converted value is stored in the object's attribute, while the standard unit information is updated in the 'Units' dictionary.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2570-2600",
            "content": "        default_unit = self.\u8bbe\u5907\u4fe1\u606f.DefaultUnits.{{attrName}}\n        val_unit = self.\u8bbe\u5907\u4fe1\u606f.{{attrName}}[1]\n        has_exception, _ = getSingleUnitConverted(default_unit = default_unit, val_unit = val_unit)\n        if has_exception:\n            raise Exception(f\"Unit '{val_unit}' is not compatible with default unit '{default_unit}'\")\n        ### UNIT COMPATIBILITY CHECK ###\n        ### UNIT CONVERSION ###\n        ConversionRate, StandardUnit = unitFactorCalculator(ureg, standard_units, val_unit)\n        ### UNIT CONVERSION ###\n        self.{{attrName}} = self.\u8bbe\u5907\u4fe1\u606f.{{attrName}}[0] * ConversionRate\n        \"\"\"\n        \u5355\u4f4d: \u6807\u51c6\u5355\u4f4d <- \u73b0\u7528\u5355\u4f4d\n        \"\"\"\n        UnitsDict.update(dict({{attrName}}= str(StandardUnit)))\n        {% endfor%}\n        self.Units = _Units.parse_obj(UnitsDict)\n    {% else %}\n        {% error(\"Unknown special class:\", k) %}\n    {% endif %}\n    def constraints_register(self):\n        super().constraints_register()\n    {% if k == \"load_class\" %}\n        {% if v in ['\u7535'] %}\n            {% set port_name = '\u7535\u63a5\u53e3' %}"
        },
        {
            "comment": "This code is filtering the load type and applying different constraints based on it. If the load type is '\u6c22', then the port name is set as '\u6c22\u6c14\u63a5\u53e3'. If the load type is Normal, a RangeConstraint is applied to the port. If the load type is Punished, a RangeConstraintMulti is applied along with calculating punishment rates. For Flexible load types, it throws an error. Additionally, there is a TODO comment suggesting that the code will calculate average hourly prices for typical days in the future.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2601-2617",
            "content": "        {% elif v in ['\u6c22'] %}\n            {% set port_name = '\u6c22\u6c14\u63a5\u53e3' %}\n        {% else %}\n            {% error(\"\u672a\u77e5\u8d1f\u8377\u7c7b\u578b:\", class_name) %}\n        {% endif %}\n        # TODO: \u5178\u578b\u65e5\u7684\u5206\u65f6\u5206\u6708\u7535\u4ef7\u53d6\u6bcf\u5929\u540c\u4e00\u5c0f\u65f6\u7684\u5e73\u5747\uff0c\u5728\u7535\u4ef7\u6a21\u578b\u5185\u5b9e\u73b0\n        getTimeInDay = lambda index: index {{\u5c0f\u65f6}} else self.\u8ba1\u7b97\u53c2\u6570.\u5206\u65f6\u8ba1\u4ef7\u5f00\u59cb\u65f6\u95f4\u70b9 + \u6bcf\u5929\u5c0f\u65f6\u6570 * convertMonthToDays(self.\u8ba1\u7b97\u53c2\u6570.\u5206\u65f6\u8ba1\u4ef7\u5f00\u59cb\u6708\u4efd) + (index/\u6bcf\u5c0f\u65f6\u79d2\u6570)\n        self.IncomeRates = [self.PriceModel.getFee(power, getTimeInDay(index)) for index, power in enumerate(self.{{port_name}}.values())] # negative, means income\n        punishmentRates = [0]\n        if self.\u8bbe\u5907\u4fe1\u606f.LoadType == \u8d1f\u8377\u7c7b\u578b.Normal:\n            self.RangeConstraint(self.{{port_name}}, self.EnergyConsumption, lambda x,y: x == -y)\n        elif self.\u8bbe\u5907\u4fe1\u606f.LoadType == \u8d1f\u8377\u7c7b\u578b.Punished:\n            self.RangeConstraintMulti(self.{{port_name}}, self.UnsatisfiedEnergyConsumption, self.EnergyConsumption,expression =  lambda x,y,z: x == -(z-y))\n            punishmentRates = [v*self.PunishmentRate for v in self.UnsatisfiedEnergyConsumption.values()]\n        elif self.\u8bbe\u5907\u4fe1\u606f.LoadType == \u8d1f\u8377\u7c7b\u578b.Flexible:"
        },
        {
            "comment": "Code adds constraint for load type, sets range and interruptible conditions, calculates annual cost based on load type, and assigns punishment rate for punished loads.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2618-2631",
            "content": "            self.RangeConstraintMulti(self.{{port_name}}, expression = lambda x: -x>=self.Pmin)\n            self.RangeConstraintMulti(self.{{port_name}}, expression = lambda x: -x<=self.Pmax)\n        elif self.\u8bbe\u5907\u4fe1\u606f.LoadType == \u8d1f\u8377\u7c7b\u578b.Interruptable:\n            self.RangeConstraintMulti(self.{{port_name}}, self.Interrupted, expression = lambda x,y : -x==self.Pmax*(1-y))\n        elif self.\u8bbe\u5907\u4fe1\u606f.LoadType == \u8d1f\u8377\u7c7b\u578b.InterruptableAndFlexible:\n            self.RangeConstraintMulti(self.{{port_name}}, self.Interrupted, expression = lambda x,y : -x>=self.Pmin*(1-y))\n            self.RangeConstraintMulti(self.{{port_name}}, self.Interrupted, expression = lambda x,y : -x<=self.Pmax*(1-y))\n        else:\n            raise Exception(\"\u4e0d\u5408\u7406\u7684\u8d1f\u8377\u7c7b\u578b:\", self.\u8bbe\u5907\u4fe1\u606f.LoadType)\n        {# \u5e74\u5316\u8d39\u7528 = ((0 if self.\u8bbe\u5907\u4fe1\u606f.LoadType == LoadType.Punished else (quicksum_indexed_var(self.IncomeRates)))/len(self.IncomeRates)) * \u6bcf\u5e74\u5c0f\u65f6\u6570 #}\n        if self.\u8bbe\u5907\u4fe1\u606f.LoadType == \u8d1f\u8377\u7c7b\u578b.Punished:\n            \u5e74\u5316\u8d39\u7528 = 0\n            self.punishRate = quicksum_indexed_var(punishmentRates)/self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570"
        },
        {
            "comment": "This code calculates the annualized cost for different types of devices in a microgrid. It handles various device types and uses average consumption rates, prices, and operating hours to calculate annual costs. The code also checks for unknown asset classes and throws errors if they are encountered. The result is stored as \"total annualized cost\" and \"variable O&M annualized cost\".",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2632-2667",
            "content": "        else:\n            \u5e74\u5316\u8d39\u7528 = (quicksum_indexed_var(self.IncomeRates)/self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570) * \u6bcf\u5e74\u5c0f\u65f6\u6570\n        {# \u5e74\u5316\u8d39\u7528 = ((0 if self.\u8bbe\u5907\u4fe1\u606f.LoadType == LoadType.Punished else (quicksum_indexed_var(self.IncomeRates)) + quicksum_indexed_var(punishmentRates))/len(self.IncomeRates)) * \u6bcf\u5e74\u5c0f\u65f6\u6570 #}\n        # \u5df2\u7ecf\u662f\u8d1f\u6570\u4e86\n        {# \u8ba1\u4ef7\u6a21\u578b #}\n    {% elif k == \"input_class\" %}\n        {% if class_name in ['\u67f4\u6cb9'] %}\n        \u5e73\u5747\u6d88\u8017\u7387 = self.SumRange(self.\u71c3\u6599\u63a5\u53e3) / self.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570\n        {% else %}\n            {% error('\u672a\u77e5\u80fd\u6e90\u7c7b\u578b:', class_name) %}\n        {% endif %}\n        \u5e74\u5316\u8d39\u7528 = \u5e73\u5747\u6d88\u8017\u7387 * self.Price * \u6bcf\u5e74\u5c0f\u65f6\u6570\n    {% else %}\n        {% error(\"\u672a\u77e5\u7279\u6b8a\u7c7b\u578b:\", k) %}\n    {% endif %}\n        self.\u603b\u6210\u672c\u5e74\u5316 = self.\u603b\u53ef\u53d8\u7ef4\u62a4\u6210\u672c\u5e74\u5316 = \u5e74\u5316\u8d39\u7528\n        return \u5e74\u5316\u8d39\u7528\n{% endfor %}\n{% endfor %}\nclass ModelWrapperContext:\n    def __init__(self, inputParams:InputParams):\n        mw = ModelWrapper()\n        self.mw = mw\n        self.mw.inputParams = deepcopy(inputParams)\n    def __enter__(self):\n        logger_print(\"ENTER MODEL WRAPPER CONTEXT\")\n        return self.mw\n    def __exit__(self, exc_type, exc_value, exc_traceback):"
        },
        {
            "comment": "Code snippet initializes a logger and performs cleanup tasks when there's an error in the model wrapper context. It also defines `devInstClassMap` as a dictionary mapping device class names to their corresponding classes with different suffixes, and a function `iterate_input_output_limit()` that iterates over input/output limits for each device node.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2668-2697",
            "content": "        # we don't have to take care of this.\n        if exc_type == None:\n            logger_print(\"NO ERROR IN MODEL WRAPPER CONTEXT\")\n        else:\n            logger_print(\"ERROR IN MODEL WRAPPER CONTEXT\")\n        {# del self.mw.model #}\n        del self.mw\n        {# self.mw.exit() #}\n        logger_print(\"EXITING MODEL WRAPPER CONTEXT\")\n{% for e in [\"Inst\", \"ID\", 'Info'] %}\n{% set class_types = {}%}\n{% set type_suffix = (\"\u6a21\u578b\" if e == \"Inst\" else (\"\u4fe1\u606f\" if e == 'Info' else e)) %}\n{% for class_name in \u8bbe\u5907\u63a5\u53e3\u96c6\u5408.keys() %}\n{% do class_types.update({class_name:class_name+type_suffix}) %}\n{% endfor %}\ndev{{e}}ClassMap : Dict[str, {{\"\u8bbe\u5907\"+type_suffix if type_suffix != \"\u4fe1\u606f\" else \"BaseModel\"}}]= {\n    {% for class_name in \u8bbe\u5907\u63a5\u53e3\u96c6\u5408.keys() %}\n    \"{{class_name}}\": {{class_types[class_name]}},\n    {% endfor %}\n} # type: ignore\n{% endfor %}\ndef iterate_input_output_limit(attr, indexs, G, devInstDict):\n    m_limit_list = []\n    for m_id in indexs:\n        m_anchor = G.nodes[m_id]\n        m_node_id = m_anchor[\"device_id\"]\n        m_devInst = devInstDict[m_node_id]"
        },
        {
            "comment": "This code is a function that calculates the sum of input/output limits for microgrid devices. It iterates through the device instances, retrieves the limit attribute from each device, appends them to a list, and then returns the sum of all the limits. The function takes an io_type, attr (attribute name), and type_annotation as parameters. The code also includes three other functions: getSchemaFromDataModel, getRequiredKeysSetFromDataModel, and getDuplicatedSchemaKeysSetFromDataModels. These functions are related to exporting data model schema, obtaining required keys from a data model, and finding duplicated keys among two data models respectively.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2698-2724",
            "content": "        m_limit_list.append(getattr(m_devInst, attr))\n    io_limit = sum(m_limit_list)\n    return io_limit\n{# {% macro iterate_input_output_limit(io_type, attr, type_annotation) %}\n    {% set devInstVarName = \"m_devInst{}\".format(io_type.title())%}\n                m_limit_list = []\n                for m_id in {{io_type}}_indexs:\n                    m_anchor = G.nodes[m_id]\n                    m_node_id = m_anchor['device_id']\n                    {{devInstVarName}} : {{type_annotation}} = devInstDict[m_node_id]\n                    m_limit_list.append({{devInstVarName}}.{{attr}})\n                {{io_type}}_limit = {{- sum_reduce('m_limit_list') }}\n{% endmacro %} #}\n# export all these data with no dependency on calculation type.\ndef getSchemaFromDataModel(dataModel: BaseModel):\n    schema = dataModel.schema()\n    return schema\ndef getRequiredKeysSetFromDataModel(dataModel:BaseModel):\n    schema = getSchemaFromDataModel(dataModel)\n    requiredKeys = schema['required']\n    return set(requiredKeys)\ndef getDuplicatedSchemaKeysSetFromDataModels(dataModel_0:BaseModel, dataModel_1:BaseModel):"
        },
        {
            "comment": "This code defines a class for simulated results that inherits from `BaseModel`. It has fields representing various parameters, with their types and titles determined by the `chineseName` and `englishName` variables. The code also includes a validator method for converting some integer fields to float type.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2725-2749",
            "content": "    requiredKeysSet_0 = getRequiredKeysSetFromDataModel(dataModel_0)\n    requiredKeysSet_1 = getRequiredKeysSetFromDataModel(dataModel_1)\n    duplicatedSchemaKeysSet = requiredKeysSet_0.intersection(requiredKeysSet_1)\n    return duplicatedSchemaKeysSet\n{# TODO: \u6dfb\u52a0\u81ea\u6765\u6c34\u6d88\u8017\u8d39\u7528 \u81ea\u6765\u6c34\u6d88\u8017\u91cf #}\nclass \u4eff\u771f\u7ed3\u679c(BaseModel):\n    {% for chineseName, englishName in frontend_translation_table.items()%}\n    {% if chineseName in ['\u5143\u4ef6\u540d\u79f0', '\u8bbe\u5907\u578b\u53f7', '\u5143\u4ef6\u7c7b\u578b']%}\n        {% set mtype = 'str'%}\n    {% elif chineseName in [\"\u8bbe\u5907\u53f0\u6570\"]%}\n        {% set mtype = 'int'%}\n    {% else %}\n        {% set mtype  = 'float'%}\n        {# need to clarify units! #}\n        {# refer to \"export_format_validate.py\" for unit conversion details. #}\n    {% endif%}\n    {{englishName}} : {{mtype if mtype !='int' else 'float'}} = Field(title = \"{{chineseName}}\")\n    {# {% if mtype in ['int', 'float']%} #}\n    {# unit conversion has been skipped. #}\n    {# {%if mtype == 'int'%}\n    @validator('{{englishName}}')\n    def convert_number_{{englishName}}(cls, v):\n        try: "
        },
        {
            "comment": "The code defines a class \"\u8bbe\u5907\u6a21\u578b\u534f\u8bae\" and uses macros to create fields based on a list. It also sets planningResultExportClassName and planningParamLUT variables, as well as initializing planningUnits. The code aims at generating fields and handling translations for planning results and parameters.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2750-2782",
            "content": "            val = int(v)\n        except:\n            val = v\n        return val\n    {% endif%} #}\n    {% endfor %}\n{% set planningResultKeyTranslationMap = {'\u65b9\u6848\u8be6\u60c5': '\u89c4\u5212\u7ed3\u679c\u8be6\u60c5', \"\u65b9\u6848\u5217\u8868\": \"\u89c4\u5212\u65b9\u6848\u6982\u89c8\"} %}\nclass \u8bbe\u5907\u6a21\u578b\u534f\u8bae(Protocol):\n    \u8bbe\u5907\u4fe1\u606f: \u8bbe\u5907\u4fe1\u606f\n{% macro createFieldsByList(lst)%}\n    {% for elem in lst%}\n    {{elem['vn']}}: {{elem['vt']}} = Field(title=\"{{elem['vn']}}\", description={{repr(elem['desc'])}})\n    \"\"\"\n{{elem['desc'] | indent(4, true)}}\n    \"\"\"\n    {%endfor%}\n{% endmacro%}\n{% for key, elemDict in planningExportFormatList %}\n    {% set planningResultExportClassName = planningResultKeyTranslationMap[key] %}\n    {% set planningParamLUT = {\"cn\": [], 'en': []}%}\n    {% set planningUnits = {} %}\n    {% for elemKey, elem in elemDict.items() %}\n        {% set valName = elemKey %}\n        {% set valEnglishName = elem['englishName'] %}\n        {% set valType = elem['type'] %}\n        {% set valUnit = elem['unit'] %}\n        {% set description %}{{'\u5355\u4f4d: '+valUnit+'\\n' if valUnit != None else ''}}\u5bf9\u5e94\u5b57\u6bb5: {{valEnglishName}}{% endset %}"
        },
        {
            "comment": "The code snippet is defining two classes, one for English parameters and another for Chinese parameters, which extend the BaseModel class. It also creates a Units section with translations for each parameter unit. The translate method converts the object's dictionary representation to its translation table format.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2783-2806",
            "content": "        {% set description_en %}{{'\u5355\u4f4d: '+valUnit+'\\n' if valUnit != None else ''}}\u5bf9\u5e94\u5b57\u6bb5: {{valName}}{% endset %}\n        {% if valUnit != None%}\n            {% do planningUnits.update({valName: valUnit})%}\n        {% endif%}\n        {% do planningParamLUT['cn'].append({\"vn\": valName, \"vt\": valType, \"desc\": description}) %}\n        {% do planningParamLUT['en'].append({\"vn\": valEnglishName, \"vt\": valType, \"desc\": description_en}) %}\n    {% endfor %}\n    {% set planningResultExportClassNameTranslated= planningResultExportClassName+\"_\u7ffb\u8bd1\"%}\nclass {{planningResultExportClassNameTranslated}}(BaseModel):\n{{createFieldsByList(planningParamLUT['en'])}}\nclass {{planningResultExportClassName}}(BaseModel):\n{{createFieldsByList(planningParamLUT['cn'])}}\n    class Units:\n    {% for key, unit in planningUnits.items() %}\n        {{key}} = {{repr(unit)}}\n        {# test type checker #}\n    {% endfor %}\n    def translate(self):\n        paramDict = self.dict()\n        {# paramDict = self.to_dict() #}\n        TT = self.get_translation_table()"
        },
        {
            "comment": "Function defines a method to export planning results, takes in a list of planning and simulation results, a dictionary of FSPT values, total annual fee, and plan type. Parameters for the result export are defined and returned. The function also includes an if condition to check if the key is \"\u65b9\u6848\u5217\u8868\".",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2807-2831",
            "content": "        params = {TT[k]: v for k,v in paramDict.items()}\n        return {{planningResultExportClassNameTranslated}}(**params)\n    @classmethod\n    def get_translation_table(cls) -> Dict[str, str]:\n        schema = cls.schema()\n        required_keys = schema['required']\n        properties = schema['properties']\n        translation_table = {}\n        for rk in required_keys:\n            prop = properties[rk]\n            desc = prop['description']\n            parse_result = parse.parse('\u5bf9\u5e94\u5b57\u6bb5: {englishTranslation}', desc.split(\"\\n\")[-1])\n            et = parse_result['englishTranslation']\n            translation_table[rk] = et\n        return translation_table\n    @classmethod\n    {% if key == \"\u65b9\u6848\u5217\u8868\" %}\n    def export(cls, planningResultList: List[\u89c4\u5212\u7ed3\u679c\u8be6\u60c5], simulationResultList: List[\u4eff\u771f\u7ed3\u679c], FSPT:Dict[str,str], totalAnnualFee:float, planType: str): # totalAnnualFee is equivalent to our \"financial\" objective\n        params = dict(\u5e74\u5316\u8d39\u7528 = totalAnnualFee, \u65b9\u6848\u7c7b\u578b = planType)\n        def updateParam(k, v):\n            {# if type(v) in [float, int]: #}"
        },
        {
            "comment": "This code is updating parameters in a microgrid optimization process. It checks for non-nan values and adds them to the params dictionary. It handles duplicate keys by retrieving values from planning results and updating the params dictionary. Finally, it finds remaining required keys and updates them with values from simulation results.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2832-2851",
            "content": "                {# if not np.isnan(v): #}\n            params[k] = params.get(k, 0)+(v if not np.isnan(v) else 0)\n                    {# params[k] = params.get(k,0)+v #}\n                {# else: #}\n                    {# params[k] = params.get(k,0) #}\n        duplicate_params_planning_keys = getDuplicatedSchemaKeysSetFromDataModels(\u89c4\u5212\u65b9\u6848\u6982\u89c8,\u89c4\u5212\u7ed3\u679c\u8be6\u60c5)\n        for planningResult in planningResultList:\n            for duplicatedKey in duplicate_params_planning_keys:\n                val = getattr(planningResult, duplicatedKey)\n                updateParam(duplicatedKey, val)\n        remainedKeys = getRequiredKeysSetFromDataModel(cls).difference(set(params.keys()))\n        for simulationResult in simulationResultList:\n            for remainedKey in remainedKeys: # '\u5e74\u70ed\u8d1f\u8377', '\u5e74\u7535\u8d1f\u8377', '\u5e74\u51b7\u8d1f\u8377', '\u5e74\u84b8\u6c7d\u8d1f\u8377', '\u5e74\u6c22\u6c14\u8d1f\u8377'\n                {# keyBase = remainedKey.strip(\"\u5e74\") #}\n                keyBase = remainedKey.strip(\"\u5e74\").strip('\u8d1f\u8377').strip('\u6d88\u8017\u91cf')\n                for keySuffix in ['\u8d1f\u8377', '\u6d88\u8017\u91cf']:\n                    attemptKey = f\"{keyBase}{keySuffix}\""
        },
        {
            "comment": "This code is part of a function that handles parameters in simulation results. It updates uninitialized parameters with 'nan' values, and the function exports simulation results for different devices. The commented-out section may have been removed during development.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2852-2871",
            "content": "                {# if (val:=getattr(simulationResult, FSPT.get(keyBase,\"NO_TRANSLATION\"),...)) is not ...: #}\n                    if (val:=getattr(simulationResult, FSPT.get(attemptKey,\"NO_TRANSLATION\"), ...)) is not ...:\n                    {# if (val:=getattr(simulationResult, FSPT.get(attemptKey,...),...)) is not ...: #}\n                        updateParam(remainedKey, val)\n                    {# FIX: early break #}\n                    break\n        remainedKeys = getRequiredKeysSetFromDataModel(cls).difference(set(params.keys()))\n        for rk in remainedKeys:\n            params[rk] = cmath.nan\n    {% else %}\n    {# \u65b9\u6848\u8be6\u60c5 #}\n    # \u6b64\u5904\u7684\u4eff\u771f\u7ed3\u679c\u662f\u6bcf\u4e2a\u5178\u578b\u65e5\u7684\u4eff\u771f\u7ed3\u679c\uff0c\u4e0d\u662f\u5408\u5e76\u4e4b\u540e\u7684\u4eff\u771f\u7ed3\u679c\u8868\u683c\n    # \u51fa\u6765\u7684\u4e5f\u662f\u6bcf\u4e2a\u5178\u578b\u65e5\u5bf9\u5e94\u7684\u89c4\u5212\u8be6\u60c5\uff0c\u9700\u8981\u6839\u636e\u8bbe\u5907ID\u8fdb\u884c\u5408\u5e76\n        {# {% set simExportClassList = [] %}\n        {% for devName in \u8bbe\u5907\u63a5\u53e3\u96c6\u5408.keys() %}\n            {% do simExportClassList.append(\"{}\u4eff\u771f\u7ed3\u679c\".format(devName)) %}\n        {% endfor %} #}\n    {# @staticmethod #}\n    def export(cls, deviceModel: \u8bbe\u5907\u6a21\u578b\u534f\u8bae, deviceSimulationResult, timeParam:float):\n    {# def exp"
        },
        {
            "comment": "This code defines a function called export that takes deviceModel, deviceSimulationResult and timeParam as input. It creates a dictionary of parameters which includes device information such as name, model, quantity, average efficiency, and purchase cost. The function uses getattr and value functions to fetch specific attributes from the input objects. It also calculates parameters like annual start-ups and running hours based on deviceModel attributes.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2871-2884",
            "content": "ort(deviceModel: \u8bbe\u5907\u6a21\u578b\u534f\u8bae, deviceSimulationResult: Union[{{\", \".join(simExportClassList)}}], timeParam:float): #}\n    {# def export(deviceModel: \u8bbe\u5907\u6a21\u578b\u534f\u8bae, deviceSimulationResult: \u4eff\u771f\u7ed3\u679c, timeParam:float): #}\n        params = {}\n        params['\u5143\u4ef6\u540d\u79f0'] = deviceModel.\u8bbe\u5907\u4fe1\u606f.\u8bbe\u5907\u540d\u79f0\n        params['\u578b\u53f7'] = getattr(deviceModel.\u8bbe\u5907\u4fe1\u606f, '\u8bbe\u5907\u578b\u53f7', '')\n        {# params['\u8bbe\u5907\u578b\u53f7'] = getattr(deviceModel.\u8bbe\u5907\u4fe1\u606f, '\u8bbe\u5907\u578b\u53f7', '') #}\n        params['\u6570\u91cf'] = value(getattr_with_ellipsis_fallback(deviceModel,'DeviceCount', 0))\n        {# params['\u6570\u91cf'] = getattr_with_ellipsis_fallback(deviceSimulationResult,'equiCounts', 0) #}\n        {# params['\u6570\u91cf'] = getattr_with_ellipsis_fallback(deviceModel.\u8bbe\u5907\u4fe1\u606f,'equiCounts', 0) # \u4e0d\u8981\u7d2f\u52a0\u6570\u91cf\uff01 #}\n        params['\u5e73\u5747\u6548\u7387_\u5e73\u5747COP'] = getattr_with_ellipsis_fallback(deviceSimulationResult, 'averageEfficiency', cmath.nan)\n        params['\u8bbe\u5907\u91c7\u8d2d\u6210\u672c'] = value(deviceModel.\u603b\u91c7\u8d2d\u6210\u672c) * (timeParam/\u6bcf\u5e74\u5c0f\u65f6\u6570)\n        {% for k in [\"\u673a\u7ec4\u5e74\u542f\u52a8\u6b21\u6570\",\"\u673a\u7ec4\u5e74\u8fd0\u884c\u65f6\u95f4\"] %}\n        params[{{repr(k)}}] = value(getattr_with_ellipsis_fallback(deviceModel,{{repr(k)}}, cmath.nan))"
        },
        {
            "comment": "Iterates through device models, extracts maintenance costs and gas emissions. Checks if model is diesel, multiplies with conversion unit, calculates gas emissions for each attribute ('\u5e74\u78b3\u6392\u653e', '\u5e74NOX\u6392\u653e','\u5e74SO2\u6392\u653e').",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2885-2898",
            "content": "        {% endfor %}\n        params['\u8bbe\u5907\u5e74\u7ef4\u62a4\u8d39'] = getattr_with_ellipsis_fallback(deviceSimulationResult, \"\u8bbe\u5907\u7ef4\u62a4\u8d39\u7528\", cmath.nan) # \u4e58\u8fc7\u65f6\u95f4\u53c2\u6570\u5c31\u4e0d\u7528\u4e58\u4e86\n        {# params['\u8bbe\u5907\u5e74\u7ef4\u62a4\u8d39'] = deviceSimulationResult.equipmentMaintenanceCosts # \u4e58\u8fc7\u65f6\u95f4\u53c2\u6570\u5c31\u4e0d\u7528\u4e58\u4e86 #}\n        for attrName in ['\u5e74\u78b3\u6392\u653e', '\u5e74NOX\u6392\u653e','\u5e74SO2\u6392\u653e']:\n            gasType = attrName.strip('\u5e74').strip('\u6392\u653e') if '\u78b3' not in attrName else 'CO2'\n            # fuel instances. we cannot allow diesel engines for this, since this will introduce errors in summation.\n            if isinstance(deviceModel, \u67f4\u6cb9\u6a21\u578b): # fuel unit: L\n            {# if type(deviceModel) in [\u67f4\u6cb9\u6a21\u578b]: # fuel unit: L #}\n                # L * (kg/L)\n                modelBaseName = deviceModel.__class__.__name__.strip(\"\u6a21\u578b\")\n                dieselConsumptionUnit = getattr(globals().get(f'{modelBaseName}\u4eff\u771f\u7ed3\u679c\u5bfc\u51fa\u5355\u4f4d'), f'{modelBaseName}\u6d88\u8017\u91cf')\n                val_raw, val_unit = multiplyWithUnit((deviceSimulationResult.\u67f4\u6cb9\u6d88\u8017\u91cf, dieselConsumptionUnit), getattr(deviceModel.\u8bbe\u5907\u4fe1\u606f, gasType)) # [\u6570\u503c\uff0c\u5355\u4f4d]\n                {# va"
        },
        {
            "comment": "This code seems to be defining a class with attributes such as \"type\" and \"subtype\". It calculates values based on different units and converts them accordingly. The code also uses unit conversion factors and checks for specific conditions before assigning values. There is a loop that creates an instance of the class, potentially multiple times, using the calculated values. However, there seems to be a fix needed for returning inside the loop. Overall, it appears to be a part of a larger data model or simulation process.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2898-2923",
            "content": "l_raw, val_unit = multiplyWithUnit((deviceSimulationResult.dieselConsumption, dieselConsumptionUnit), getattr(deviceModel.\u8bbe\u5907\u4fe1\u606f, gasType)) # [\u6570\u503c\uff0c\u5355\u4f4d] #}\n                # gas emission unit: kg\n                # now you may want to convert this by acquiring units elsewhere...\n                target_unit = getattr({{planningResultExportClassName}}.Units, attrName)\n                {# magnitude, _ = unitFactorCalculator(ureg, standard_units, val_unit) #}\n                val_quantity = val_raw * ureg.Unit(val_unit)\n                val_quantity_target = val_quantity.to(target_unit)\n                val = val_quantity_target.magnitude\n                {# val = magnitude * val_raw #}\n                # kg -> t (standard)\n            else:\n                val = cmath.nan\n            params[attrName] = val\n    {% endif %}\n        {# FIX: return inside for loop #}\n        return cls(\n            **params\n        )\n{% endfor %}\nclass \u8282\u70b9\u57fa\u7c7b(BaseModel):\n    {# type:{{normal_str}} = Field(title = \"\u8282\u70b9\u7c7b\u578b\") #}\n    subtype:{{normal_str}} = Field(title = \"\u8282\u70b9\u6b21\u7c7b\u578b\")"
        },
        {
            "comment": "This code defines several classes representing different types of nodes in a microgrid model, including connection lines, junction points, anchors, busbars, and devices. The classes have unique attributes and IDs for identification and mapping purposes. There is also a dictionary defining device subtypes and their corresponding aliases. The code uses Python's Field class for data validation and title descriptions, and contains various comments for better understanding the structure and functionality of the microgrid model.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2924-2953",
            "content": "    id:int = Field(title = \"\u8282\u70b9ID\")\nclass \u8fde\u7ebf\u8282\u70b9(\u8282\u70b9\u57fa\u7c7b):\n    type: Literal['\u8fde\u63a5\u7ebf','\u5408\u5e76\u7ebf']\nclass \u951a\u70b9\u8282\u70b9(\u8282\u70b9\u57fa\u7c7b):\n    type: Literal['\u951a\u70b9']\n    port_name:{{normal_str}} = Field(title = '\u951a\u70b9\u540d\u79f0')\n    device_id:{{non_neg_int}} = Field(title = '\u951a\u70b9\u6240\u5bf9\u5e94\u8bbe\u5907ID')\nclass \u6bcd\u7ebf\u8282\u70b9(\u8282\u70b9\u57fa\u7c7b):\n    type: Literal['\u6bcd\u7ebf']\n    conn: conlist({{normal_str}}, min_items=2)  = Field(title = '\u6bcd\u7ebf\u8fde\u63a5\u7ebf\u7c7b\u578b\u5217\u8868', description = '\u5305\u62ec\u8fde\u63a5\u5230\u6bcd\u7ebf\u4e0a\u7684\u8fde\u63a5\u7ebf\u548c\u5408\u5e76\u7ebf\u7c7b\u578b')# connection/merge types to literal.\nclass \u8bbe\u5907\u63a5\u53e3\u6620\u5c04(BaseModel):\n    subtype: {{normal_str}} = Field(title = \"\u63a5\u53e3\u7c7b\u578b\")\n    id: {{non_neg_int}} = Field(title = \"\u63a5\u53e3ID\", description = \"\u62d3\u6251\u56fe\u4e0a\u4e0e\u8bbe\u5907\u3001\u6bcd\u7ebf\u3001\u8fde\u63a5\u7ebf\u7684ID\u76f8\u6bd4\u8f83\u5177\u6709\u552f\u4e00\u6027\u7684ID\")\n{% set infoClassList = []%}\n{% for class_name in \u8bbe\u5907\u63a5\u53e3\u96c6\u5408.keys() %}\n    {% do infoClassList.append(class_name+\"\u4fe1\u606f\")%}\n{% endfor %}\nclass \u8bbe\u5907\u8282\u70b9\u57fa\u7c7b(\u8282\u70b9\u57fa\u7c7b):\n    type: Literal['\u8bbe\u5907']\n    ports:Dict[{{normal_str}},\u8bbe\u5907\u63a5\u53e3\u6620\u5c04] = Field(title = \"\u8bbe\u5907\u63a5\u53e3\u6620\u5c04\", description = \"\u63cf\u8ff0\u8bbe\u5907\u6240\u5bf9\u5e94\u63a5\u53e3\u7684\u7c7b\u578b\u548c\u63a5\u53e3ID\")\ndeviceSubtypeAlias = dict(\u53d8\u6d41\u5668=[\"\u5355\u5411\u53d8\u6d41\u5668\"], \u53d8\u538b\u5668='\u53cc\u5411\u53d8\u538b\u5668')\n{# deviceSubtypeAlias = dict(\u53d8\u6d41\u5668=[\"\u5355\u5411\u53d8\u6d41\u5668\"], \u9502\u7535\u6c60=['\u84c4\u70ed\u8bbe\u5907','\u84c4\u51b7\u8bbe\u5907','\u84c4\u51b0\u8bbe\u5907']) #}\nDSAToDS = {e:k for k, v in deviceSubtypeAlias.items() for e in v}"
        },
        {
            "comment": "This code is defining classes for different device nodes in a microgrid, with each class inheriting from the \"DeviceNodeBase\" class. Each class has a specific device name, node name, and optional subtype. The code also includes a validator function to validate the subtype input. Additionally, there is a separate class called mDict with some reserved fields.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2954-2976",
            "content": "{# {% set deviceSubtypeAlias = dict(\u53d8\u6d41\u5668=[\"\u5355\u5411\u53d8\u6d41\u5668\"]) %} #}\n{% set deviceNodeClasses = [] %}\n{% for infoClass in infoClassList %}\n    {% set deviceName = infoClass.strip(\"\u4fe1\u606f\") %}\n    {% set deviceNodeClassName = deviceName+\"\u8282\u70b9\" %}\n    {% do deviceNodeClasses.append(deviceNodeClassName) %}\nclass {{deviceNodeClassName}}(\u8bbe\u5907\u8282\u70b9\u57fa\u7c7b):\n    {# subtype_hidden:Union[None, str] = Field(default = None, title = \"\u8282\u70b9\u539f\u6b21\u7c7b\u578b\", description = \"\u5185\u90e8\u53d8\u91cf\uff0c\u4e0d\u8981\u586b\u5199\") #}\n    subtype: Literal[{{repr(deviceName)}}, *deviceSubtypeAlias.get({{repr(deviceName)}}, [])] = Field(title = \"\u8282\u70b9\u6b21\u7c7b\u578b\")\n    {# subtype: Literal[{{repr(deviceName)}}, {{\",\".join(aliasLiterals)}}] = Field(title = \"\u8282\u70b9\u6b21\u7c7b\u578b\") #}\n    param:{{infoClass}} = Field(title = '\u8bbe\u5907\u4fe1\u606f', description = {{repr(infoClass)}})\n{# \n    @validator('subtype')\n    def validate_subtype(cls, v, values):\n        v = DSAToDS.get(v, v)\n        return v #}\n{% endfor %}\nclass mDict(BaseModel):\n    directed:bool=Field(default = False, title='\u4fdd\u7559\u5b57\u6bb5')\n    multigraph:bool=Field(default = False, title='\u4fdd\u7559\u5b57\u6bb5')\n    graph:\u8ba1\u7b97\u53c2\u6570 = Field("
        },
        {
            "comment": "This code defines a class `EnergyFlowGraph` that represents an energy flow graph with nodes and links. It includes fields for additional attributes, model parameters, simulation type, and weather data. Nodes include anchor points, device nodes, bus nodes, and line nodes. Links represent connections between nodes in the energy flow graph.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":2977-3008",
            "content": "        title=\"\u80fd\u6d41\u62d3\u6251\u56fe\u7684\u9644\u52a0\u5c5e\u6027\",\n        description=\"\u4eff\u771f\u548c\u4f18\u5316\u6240\u9700\u7684\u6a21\u578b\u53c2\u6570\u5b57\u5178\", example = {\n            \"\u8ba1\u7b97\u6b65\u957f\": \"\u5c0f\u65f6\",\n            \"\u5178\u578b\u65e5\": False,\n            \"\u5178\u578b\u65e5\u4ee3\u8868\u7684\u65e5\u671f\": [],\n            \"\u8ba1\u7b97\u7c7b\u578b\": \"\u8bbe\u8ba1\u89c4\u5212\",\n            \"\u98ce\u901f\": [], \"\u5149\u7167\":[],\"\u6c14\u6e29\":[] ,\"\u5e74\u5229\u7387\":0.1})\n    nodes:conlist(Union[\u951a\u70b9\u8282\u70b9,{{\",\".join(deviceNodeClasses)}},\u6bcd\u7ebf\u8282\u70b9,\u8fde\u7ebf\u8282\u70b9], min_items=5) = Field(\n    {# nodes:conlist(Union[\u951a\u70b9\u8282\u70b9,\u8bbe\u5907\u8282\u70b9,\u6bcd\u7ebf\u8282\u70b9,\u8fde\u7ebf\u8282\u70b9], min_items=5) = Field( #}\n        title=\"\u8282\u70b9\",\n        description=\"\u7531\u6240\u6709\u8282\u70b9ID\u548c\u5c5e\u6027\u5b57\u5178\u7ec4\u6210\u7684\u5217\u8868\", example =[ {\n                \"type\": \"\u951a\u70b9\",\n                \"port_name\": \"\u7535\u63a5\u53e3\",\n                \"subtype\": \"\u4f9b\u7535\u7aef\u8f93\u51fa\",\n                \"device_id\": 2,\n                \"id\": 3\n            }])\n    links:conlist(Dict[Literal['source','target'], int], min_items=4) = Field(\n        title=\"\u8fb9\",\n        description=\"\u7531\u80fd\u6d41\u56fe\u4e2d\u8282\u70b9\u4e92\u76f8\u8fde\u63a5\u7684\u8fb9\u7ec4\u6210\u7684\u5217\u8868\", example = [\n            {\n                \"source\": 0,\n                \"target\": 1\n            },\n            {\n                \"source\": 1,\n                \"target\": 31\n            }])\n# TODO: \u589e\u52a0\u5355\u5178\u578b\u65e5\u5224\u65ad\u7c7b\u578b\u6216\u8005\u5b57\u6bb5\nclass EnergyFlowGraph(BaseModel):"
        },
        {
            "comment": "This code defines a function `compute()` that takes in device parameters, adds additional data, graph information, and a graph object. It computes power demand (PD) based on device subtypes and parameters.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":3009-3040",
            "content": "    mDictList: List[mDict]\n    residualEquipmentLife: confloat(ge=0) = Field(\n        default=0, title=\"\u8f85\u52a9\u8bbe\u5907\u5bff\u547d\", description=\"\u9ed8\u8ba4\u4e3a0\uff0c\u5e74\u5316\u7387\u8fd4\u56de\u4e3a1\\n\u5355\u4f4d\uff1a\u5e74\\n\u7528\u4e8e\u8ba1\u7b97\u8f85\u52a9\u8bbe\u5907\u5e74\u5316\u7cfb\u6570\"\n    )\nfrom networkx import Graph\nfrom failsafe_utils import failsafe_suppress_exception\n# partial if typical day mode is on.\ndef compute(devs:List[dict], adders:Dict[int,dict], graph_data:dict, G: Graph, mw: ModelWrapper):\n    PD = {}\n    algoParam = \u8ba1\u7b97\u53c2\u6570.parse_obj(graph_data)\n    typicalDayIndex = algoParam.\u5178\u578b\u65e5ID\n    devInstDict = {}\n    for dev in devs:\n        with failsafe_suppress_exception():\n            __devSubtype = dev['subtype']\n            devSubtype = DSAToDS.get(__devSubtype, __devSubtype)\n            {# devSubtype = dev['subtype'] #}\n            {# devParam = {k:v for k,v in dev.items() if k not in {\"subtype\",\"type\",\"ports\"} } #}\n            devParam = dev['param']\n            devPorts = dev['ports']\n            devID_int = dev['id']\n            devIDClass = devIDClassMap[devSubtype]\n            devIDInstInit = {\"ID\": devID_int}\n            for port_name, port_info in devPorts.items():"
        },
        {
            "comment": "Creates a device instance using provided parameters and adds it to a dictionary, also initializes empty dictionaries for extra data items and sets up variables for error types in adder devices.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":3041-3069",
            "content": "                with failsafe_suppress_exception():\n                    port_id = port_info['id']\n                    devIDInstInit.update({port_name:port_id})\n            devIDInst = devIDClass.parse_obj(devIDInstInit)\n            devInfoInstInit = devParam\n            devInfoClass = devInfoClassMap[devSubtype]\n            devInfoInst = devInfoClass.parse_obj(devInfoInstInit)\n            devInstClass = devInstClassMap[devSubtype]\n            devInst = devInstClass(PD = PD, mw=mw, \u8ba1\u7b97\u53c2\u6570\u5b9e\u4f8b=algoParam, \u8bbe\u5907ID= devIDInst, \u8bbe\u5907\u4fe1\u606f=devInfoInst) # type: ignore\n            devInstDict.update({devID_int: devInst})\n{% set extra_data_items = [\"adder_index_error_mapping\", \"adder_error_total\", \"adder_index_error_sum_mapping\"] %}\n{% for it in extra_data_items%}\n    {{it}} = {}\n{% endfor%}\n    # positive for too much input\n    # negative for insufficient input\n    # you may activate both\n{% set error_types = ['positive', 'negative', 'combined']%}\n{% for t in error_types%}\n    adder_{{t}}_error_total = 0\n{% endfor%}\n    for adder_index, adder in adders.items():"
        },
        {
            "comment": "Initializing adder_error_mapping and adder_current_{t}_error variables for each error type.\nGetting input, output, and IO indexes from adder dictionary.\nChecking if there is at least one input index, then obtaining information of the first port node.\nIf the port name is \"\u71c3\u6599\u63a5\u53e3\" and the node has subtype \"\u67f4\u6cb9\u8f93\u51fa\", it asserts that only one input index exists and stores the diesel device ID for later use.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":3070-3090",
            "content": "        adder_error_mapping = {}\n{% for t in error_types%}\n        adder_current_{{t}}_error = 0\n{% endfor%}\n        with failsafe_suppress_exception():\n            input_indexs, output_indexs, io_indexs = adder['input'], adder['output'], adder['IO']\n            logger_print(f'adder #{adder_index}:', adder)\n            # fill in missing params\n            with failsafe_suppress_exception():\n                if len(input_indexs) >= 1:\n                    first_port_info = G.nodes[input_indexs[0]]\n                    if first_port_info['port_name'] == \"\u71c3\u6599\u63a5\u53e3\":\n                    {# if G.nodes[input_indexs[0]]['subtype'] == \"\u67f4\u6cb9\u8f93\u51fa\": #}\n                        assert len(input_indexs) == 1, \"\u71c3\u6599\u5143\u4ef6\u53ea\u80fd\u4e00\u5bf9\u591a\u8fde\u63a5\"\n                        {# assert len(input_indexs) == 1, \"\u67f4\u6cb9\u5143\u4ef6\u53ea\u80fd\u4e00\u5bf9\u591a\u8fde\u63a5\" #}\n                        diesel_node_id = G.nodes[input_indexs[0]]['device_id']\n                        {# \u70ed\u503c = devInstDict[diesel_node_id].\u8bbe\u5907\u4fe1\u606f.\u70ed\u503c #}\n                        \u70ed\u503c = devInstDict[diesel_node_id].\u70ed\u503c\n                        for output_index in output_indexs:"
        },
        {
            "comment": "This code is updating device IDs, displaying input, output, and IO variable names, and calculating a sequential sum for an iterative algorithm. It also mentions adding a constraint for load factors later. The code includes variables with different abbreviations (PE and NE) for each iteration step in the algorithm.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":3091-3110",
            "content": "                            output_node_index = G.nodes[output_index]['device_id']\n                            devInstDict[output_node_index].\u71c3\u6599\u70ed\u503c = \u70ed\u503c\n            # add them all.\n            logger_print(\"_\"*20)\n            display_var_names = lambda indexs: '\\n    '.join([str(PD[i]) for i in indexs])\n            logger_print(f\"INPUTS:{display_var_names(input_indexs)}\")\n            logger_print()\n            logger_print(f\"OUTPUTS:{display_var_names(output_indexs)}\")\n            logger_print()\n            logger_print(f\"IO:{display_var_names(io_indexs)}\")\n            logger_print(\"_\"*20)\n            adder_index_repr = str(adder_index).replace(\"_\",\"-\").replace('-', 'N')\n            for j in range(algoParam.\u8fed\u4ee3\u6b65\u6570):\n                seqsum = {{- sum_reduce('[PD[i][j] for i in input_indexs + output_indexs + io_indexs]') }}\n                # TODO: \u6d88\u7eb3\u7387\u7ea6\u675f\n{% for symbol, abbv in dict(positive='PE', negative='NE').items()%}\n                {{symbol}}_error = mw.Var(name = f\"TD_{typicalDayIndex}_AD_{adder_index_repr}_{{abbv}}_{j}\", within = NonNegativeReals)"
        },
        {
            "comment": "The code calculates the combined adder error by adding positive and negative errors. It then creates a dictionary of adder_error_mapping with each error type's value, updates the adder_index_error_sum_mapping with current adder error values, and adds them to the total adder error. Finally, it uses failsafe_suppress_exception() for handling any exceptions that might occur during execution.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":3111-3138",
            "content": "                if not({{repr(symbol)}} in ies_env.ADDER_ERROR_COMPENSATION or ies_env.ADDER_ERROR_COMPENSATION == 'combined'):\n                    {{symbol}}_error.fix(0)\n{% endfor %}\n                combined_error = positive_error+negative_error\n                adder_error_mapping[j] = dict(\n{% for t in error_types%}\n                    {{t}}_error={{t}}_error, \n{% endfor%}\n                    )\n{% for t in error_types%}\n                adder_current_{{t}}_error += {{t}}_error\n{% endfor%}\n                mw.Constraint(seqsum == positive_error - negative_error)\n                {# mw.Constraint(seqsum == 0) #}\n                {# mw.Constraint(seqsum >=0) #}\n            adder_index_error_mapping[adder_index] = adder_error_mapping\n            adder_index_error_sum_mapping[adder_index] = dict(\n{% for t in error_types%}\n                {{t}}_error = adder_current_{{t}}_error,\n{% endfor%}\n            )\n{% for t in error_types%}\n            adder_{{t}}_error_total += adder_current_{{t}}_error\n{% endfor%}\n            with failsafe_suppress_exception():"
        },
        {
            "comment": "The code checks if the algorithm parameter type is '\u8bbe\u8ba1\u89c4\u5212' and counts the constraint number. If there are input indexes, it retrieves the first input anchor node with a '\u53d8\u538b\u5668\u8f93\u51fa' subtype and performs input-output limit calculations for maximum allowed load power and MaxEnergyConsumption using iterate_input_output_limit function. These limits are added to a constraint, and an adder_error_total dictionary is initialized for error types.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":3139-3162",
            "content": "                if algoParam.\u8ba1\u7b97\u7c7b\u578b == '\u8bbe\u8ba1\u89c4\u5212':\n                    cnt = 0\n                    if len(input_indexs)==0:\n                        continue\n                    input_anchor_0 = G.nodes[input_indexs[0]]\n                    if input_anchor_0['subtype'] == '\u53d8\u538b\u5668\u8f93\u51fa':\n                        logger_print(f\"Building Converter Constraint #{cnt}\")\n                        cnt+=1\n                        assert io_indexs == []\n                        input_limit = iterate_input_output_limit(\"\u6700\u5927\u5141\u8bb8\u7684\u8d1f\u8f7d\u603b\u529f\u7387\", input_indexs, G, devInstDict)\n    {# {{ iterate_input_output_limit(\"input\",\"\u6700\u5927\u5141\u8bb8\u7684\u8d1f\u8f7d\u603b\u529f\u7387\", \"\u53d8\u538b\u5668\u6a21\u578b\") }} #}\n                        output_limit = iterate_input_output_limit(\"MaxEnergyConsumption\", output_indexs, G, devInstDict)\n    {# {{ iterate_input_output_limit(\"output\",\"MaxEnergyConsumption\", \"\u7535\u8d1f\u8377\u6a21\u578b\") }} #}\n                        mw.Constraint(input_limit + output_limit >= 0)\n    adder_error_total = dict(\n{% for t in error_types%}\n        {{t}}_error=adder_{{t}}_error_total,\n{% endfor%}\n    )\n    {# financial_obj_expr = {{- sum_reduce('[e.constraints_register() for e in devInstDict.values()]') }} #}"
        },
        {
            "comment": "This code calculates financial and environmental objectives for a microgrid. It iterates over devices in the `devInstDict` dictionary, excluding load instances, and sums their financial values (registered constraints and dynamic maintenance costs) separately. For generators (\u67f4\u6cb9\u6a21\u578b), it also computes the annual CO2 emissions and adds them to a list of environment objectives.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":3163-3190",
            "content": "    financial_obj_expr = 0\n    checkIfIsLoadClassInstance = lambda inst: \"\u8d1f\u8377\" in inst.__class__.__name__ \n    for e in devInstDict.values():\n        with failsafe_suppress_exception():\n            val = e.constraints_register()\n            financial_obj_expr += (val if not checkIfIsLoadClassInstance(e) else 0)\n            financial_obj_expr = addPunishRateToFinancialTarget(financial_obj_expr, devInst)\n    financial_dyn_obj_expr = 0\n    for e in devInstDict.values():\n        with failsafe_suppress_exception():\n            val = e.\u603b\u53ef\u53d8\u7ef4\u62a4\u6210\u672c\u5e74\u5316\n            financial_dyn_obj_expr += (val if not checkIfIsLoadClassInstance(e) else 0)\n            financial_dyn_obj_expr = addPunishRateToFinancialTarget(financial_obj_expr, devInst)\n    {# financial_dyn_obj_expr = sum([(e.\u603b\u53ef\u53d8\u7ef4\u62a4\u6210\u672c\u5e74\u5316) for e in devInstDict.values()]) #}\n    environment_obj_exprs = [] # annual CO2 emission\n    for e in devInstDict.values():\n        {# if type(e) == \u67f4\u6cb9\u6a21\u578b: #}\n        if isinstance(e, \u67f4\u6cb9\u6a21\u578b):\n            environment_obj_exprs.append((sum(e.\u71c3\u6599\u63a5\u53e3.values())/e.\u8ba1\u7b97\u53c2\u6570.\u8fed\u4ee3\u6b65\u6570)*\u6bcf\u5e74\u5c0f\u65f6\u6570 * e.CO2)"
        },
        {
            "comment": "The code calculates the objective expression for a microgrid optimization problem, including financial and environmental factors. It adds values to the target from device instances based on their attributes, minimizing the objective. The functions addValueToTarget, addNewRateToAnnualTarget, and addPunishRateToFinancialTarget are used to modify the target value accordingly. Extra data is also included in the return statement.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/ies_optim_legacy.py.j2\":3192-3219",
            "content": "    environment_obj_expr = sum(environment_obj_exprs)\n    obj_exprs = (financial_obj_expr,\n                financial_dyn_obj_expr,\n                environment_obj_expr,\n    )\n    # TODO: return 'adder_index_error_mapping'\n    extra_data = dict(\n{% for it in extra_data_items%}\n        {{it}} = {{it}},\n{% endfor%}\n    )\n    {# return obj_exprs, devInstDict, PD #}\n    return obj_exprs, devInstDict, PD, extra_data\n    # always minimize the objective.\ndef addValueToTarget(target, devInst, attrName:str, iterCount:int):\n    if hasattr(devInst, attrName):\n        target += getattr(devInst, attrName) * iterCount\n    return target\ndef addNewRateToAnnualTarget(target, devInst, attrName:str):\n    target = addValueToTarget(target, devInst, attrName, \u6bcf\u5e74\u5c0f\u65f6\u6570)\n    return target\ndef addPunishRateToFinancialTarget(target, devInst):\n    target = addNewRateToAnnualTarget(target, devInst, 'punishRate')\n    return target"
        }
    ]
}