{
    "summary": "This code utilizes OR-Tools library to solve a linear optimization problem involving workers and tasks, finding optimal assignments with constraints.",
    "details": [
        {
            "comment": "This code uses the OR-Tools library to create a linear solver, specifically using the SAT backend. It defines an optimization problem with workers and tasks, assigns binary variables x[i, j] for each assignment, and ensures that each worker is assigned at most 1 task and each task is assigned to exactly one worker.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/or_tools_solver.py\":0-38",
            "content": "from ortools.linear_solver import pywraplp\n# GLPK not working.\n# solver = pywraplp.Solver.CreateSolver(solver_name:='GLPK')\n# builtin backends:\nsolver = pywraplp.Solver.CreateSolver(solver_name:='SAT')\n# solver = pywraplp.Solver.CreateSolver(solver_name:=\"CBC\")\n# solver = pywraplp.Solver.CreateSolver(solver_name:=\"SCIP\")\nif not solver:\n    raise Exception(\"SOLVER %s NOT WORKING\" % solver_name)\n# breakpoint()\ncosts = [\n    [90, 80, 75, 70],\n    [35, 85, 55, 65],\n    [125, 95, 90, 95],\n    [45, 110, 95, 115],\n    [50, 100, 90, 100],\n]\nnum_workers = len(costs)\nnum_tasks = len(costs[0])\n# x[i, j] is an array of 0-1 variables, which will be 1\n# if worker i is assigned to task j.\nx = {}\nfor i in range(num_workers):\n    for j in range(num_tasks):\n        x[i, j] = solver.IntVar(0, 1, \"\")\n# Each worker is assigned to at most 1 task.\nfor i in range(num_workers):\n    solver.Add(solver.Sum([x[i, j] for j in range(num_tasks)]) <= 1)\n# Each task is assigned to exactly one worker.\nfor j in range(num_tasks):\n    solver.Add(solver.Sum([x[i, j] for i in range(num_workers)]) == 1)"
        },
        {
            "comment": "This code uses the OR-Tools library to solve a linear optimization problem. It calculates the objective terms for each worker and task, sets them as the problem's objective function, solves the problem, and prints the optimal solution and total cost if it is feasible or optimal. If no solution is found, it indicates that status and the number of iterations taken by the solver are printed.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/or_tools_solver.py\":40-59",
            "content": "objective_terms = []\nfor i in range(num_workers):\n    for j in range(num_tasks):\n        objective_terms.append(costs[i][j] * x[i, j])\nsolver.Minimize(solver.Sum(objective_terms))\nstatus = solver.Solve()\nif status == pywraplp.Solver.OPTIMAL or status == pywraplp.Solver.FEASIBLE:\n    print(f\"Total cost = {solver.Objective().Value()}\\n\")\n    for i in range(num_workers):\n        for j in range(num_tasks):\n            # Test if x[i,j] is 1 (with tolerance for floating point arithmetic).\n            if x[i, j].solution_value() > 0.5:\n                print(f\"Worker {i} assigned to task {j}.\" + f\" Cost: {costs[i][j]}\")\nelse:\n    print(\"STATUS?\", status)\n    print(\"No solution found.\")\nprint(\"ITERATIONS?\", solver.iterations())"
        }
    ]
}