{
    "summary": "The code provides a `FileLogger` class and `solver_exec_script` function for executing solver scripts, handling file redirection, parsing output, navigating directories, and loading solution files in a microgrid system. It also generates optimization scripts, performs feasibility checks, defines a failsafe method for SCIP, and presents a utility function using IPOPT solver.",
    "details": [
        {
            "comment": "The code defines a context manager to suppress exceptions, a MethodRegistry class for registering methods with given signatures, and imports necessary modules. The context manager is used to prevent exceptions from propagating in failsafe mode, while the MethodRegistry class helps register methods based on their signature.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/failsafe_utils.py\":0-44",
            "content": "from log_utils import logger_print\nfrom config import ies_env\nfrom contextlib import contextmanager\nfrom log_utils import logger_traceback\n# from ies_optim import *\nfrom enum import auto, IntEnum\nfrom debug_utils import ExportedModel, modelSolvedTestContext\nimport random\nimport sys\nfrom pyomo_environ import *\nimport tempfile\nfrom constants import *\nimport os\nfrom typing import List\n# we need a configurable context manager which suppress exception.\n@contextmanager\ndef failsafe_suppress_exception(hint=\"failsafe suppressed exception:\"):\n    try:\n        yield\n    except Exception as e:\n        if not ies_env.FAILSAFE:\n            raise e\n        else:\n            logger_traceback(hint, stacklevel=5)\nimport inspect\nclass MethodRegistry(list):\n    \"\"\"\n    A registry of methods, used to register methods with given signature.\n    \"\"\"\n    def __init__(self, signature: List[str]):\n        self.signature = signature\n        self.names = set()\n        super().__init__()\n    def check_signature(self, obj):\n        obj_sig = inspect.signature(obj)"
        },
        {
            "comment": "The code defines a class `FileLogger` that writes log messages to a file, along with the current timestamp. It also includes a `MethodRegistry` for registering and checking the signatures of functions. The `quote` function adds quotation marks around its argument, while `TeeStream` and `LogStream` are imported from `pyomo.common`.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/failsafe_utils.py\":45-85",
            "content": "        obj_keys = list(obj_sig.parameters.keys())\n        assert (\n            obj_keys == self.signature\n        ), \"Signature mismatch: (registered signature: {}, given signature: {})\".format(\n            self.signature, obj_keys\n        )\n        return True\n    def add(self, obj):\n        name = obj.__name__\n        if name not in self.names:\n            if self.check_signature(obj):\n                self.names.add(name)\n                self.append(obj)\n    def register(self, obj):\n        self.add(obj)\n        return obj\nfailsafe_methods = MethodRegistry(signature=[\"mw\", \"logdir\"])\ndef quote(s: str, q='\"'):\n    return q + s + q\nfrom pyomo.common.tee import TeeStream\nfrom pyomo.common.log import LogStream\nimport datetime\nclass FileLogger:\n    def __init__(self, fname: str):\n        self.fname = fname\n        self.handle = open(fname, \"a+\")\n        self.handle.write(datetime.datetime.now().isoformat().center(70, \"=\") + \"\\n\")\n        # self.handle = open(fname, \"w+\")\n    def log(self, level, message):\n        logger_print(message)"
        },
        {
            "comment": "The code defines a class `FileLogger` for logging output to a file and a function `solver_exec_script` that executes a script using a solver, with the option to log the execution to a specified logfile. The `FileLogger` writes messages to a handle and closes it in its destructor. The `solver_exec_script` function checks that the script is not empty, constructs the command from the solver and script elements, initializes a `FileLogger` for logging output, tries running the command using `subprocess.run`, suppressing exceptions with `failsafe_suppress_exception`, and returns the exit code of the subprocess. The function also handles stdout and stderr redirection through `TeeStream` to log both normal and error output to the specified logfile or stdout/stderr if no logfile is provided.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/failsafe_utils.py\":86-119",
            "content": "        self.handle.write(message + \"\\n\")\n    def __del__(self):\n        self.handle.close()\n        del self.fname\n        del self.handle\nimport subprocess\ndef solver_exec_script(solver: Solver, script: List[str], logfile: str, timeout: float):\n    check_script_is_not_empty(script)\n    cmd = [solver, *script]\n    flogger = FileLogger(logfile)\n    logger_print(\"running solver:\", cmd)\n    return_code = -1\n    try:\n        with failsafe_suppress_exception():\n            ostreams = [LogStream(level=None, logger=flogger), sys.stdout]\n            # cmd = \" \".join([e if \" \" not in e else quote(e) for e in cmd ])\n            # return_code = os.system(cmd)\n            with TeeStream(*ostreams) as t:\n                cp = subprocess.run(\n                    cmd,\n                    timeout=timeout,\n                    stdout=t.STDOUT,\n                    stderr=t.STDERR,\n                    universal_newlines=True,\n                )\n                return_code = cp.returncode\n            # cmd = f\"{Solver.cplex} -c {' '.join([quote(e) for e in script])}\""
        },
        {
            "comment": "The code is a part of a microgrid system that involves executing scripts with different solvers, such as CPLEX and SCIP. It includes functions for running the scripts, checking if the script is empty or not, and verifying if a SCIP solution file contains a solved or unsolved condition.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/failsafe_utils.py\":120-156",
            "content": "            # return_code = os.system(cmd)\n        return return_code\n    finally:\n        del flogger\ndef cplex_exec_script(script: List[str], logfile: str, timeout: float):\n    check_script_is_not_empty(script)\n    return solver_exec_script(Solver.cplex, [\"-c\", *script], logfile, timeout)\ndef check_script_is_not_empty(script):\n    assert len(script) > 0, \"no script to execute\"\ndef scip_exec_script(script: List[str], logfile: str, timeout: float):\n    check_script_is_not_empty(script)\n    args = []\n    for s in script:\n        args.append(\"-c\")\n        args.append(s)\n    return solver_exec_script(Solver.scip, args, logfile, timeout)\nSCIP_NOT_SOLVED_KW = \"no solution available\"\nSCIP_SOLVED_KW = \"objective value\"\ndef check_scip_if_solved(first_two_lines: list[str]):\n    _c = \"\\n\".join(first_two_lines)\n    if SCIP_SOLVED_KW in _c:\n        return True\n    elif SCIP_NOT_SOLVED_KW in _c:\n        return False\n    else:\n        raise Exception(\n            f\"Unknown scip solution conditon. Is it a scip solution file?\\nFirst two lines:\\n{_c}\""
        },
        {
            "comment": "This function parses SCIP solver output and extracts variable values. It first checks if the solution is solved by examining the first two lines of the content, then iterates over solution lines, extracting non-blank segments using a regex pattern. If there are at least two such segments, it tries to parse them as variable name and value, storing the result in a dictionary and returning it. The code also includes a context manager for changing the current working directory.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/failsafe_utils.py\":157-192",
            "content": "        )\nimport re\nREGEX_FIND_NON_BLANK_SEGMENTS = re.compile(r\"[^ \\t]+\")\nTWO = 2\ndef parse_scip_solution_content(content: str):\n    lines = content.strip().split(\"\\n\")\n    first_two_lines = lines[:TWO]\n    solution_lines = lines[TWO:]\n    solved = check_scip_if_solved(first_two_lines)\n    solution = {}\n    if solved:\n        for line in solution_lines:\n            line = line.strip()\n            if len(line) > 0:\n                candidates = REGEX_FIND_NON_BLANK_SEGMENTS.findall(line)\n                if len(candidates) >= TWO:\n                    try:\n                        varname, value_str = candidates[:TWO]\n                        varname = varname.strip()\n                        if len(varname) > 0:\n                            value = float(value_str)\n                            solution[varname] = value\n                    except TypeError:\n                        pass\n                    except Exception as e:\n                        raise e\n    return solution\n@contextmanager\ndef chdir_context(dirpath: str):"
        },
        {
            "comment": "Code navigates through different directories, switches the current working directory using `os.chdir`, and yields after performing some operation. It also defines constants related to the CPLEX solver settings, and includes a function that loads SCIP solution files using `solution_loader` with a specific parsing function.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/failsafe_utils.py\":193-229",
            "content": "    cwd = os.getcwd()\n    os.chdir(dirpath)\n    try:\n        yield\n    finally:\n        os.chdir(cwd)\nclass FeasoptMode(IntEnum):\n    \"\"\"\n    CPLEX> set feasopt mode <mode>\n        0 = find minimum-sum relaxation\n        1 = find optimal minimum-sum relaxation\n        2 = find minimum number of relaxations\n        3 = find optimal relaxation with minimum number of relaxations\n        4 = find minimum quadratic-sum relaxation\n        5 = find optimal minimum quadratic-sum relaxation\n    \"\"\"\n    minimum_sum_relaxation = (\n        0  # do not use 'auto' here because that will make it into 1\n    )\n    optimal_minimum_sum_relaxation = auto()\n    minimum_number_of_relaxations = auto()\n    optimal_relaxation_with_minimum_number_of_relaxations = auto()\n    minimum_quadratic_sum_relaxation = auto()\n    optimal_minimum_quadratic_sum_relaxation = auto()\nFEASOPT_TIMELIMIT = 240\n# FEASOPT_TIMELIMIT = 30\nCPLEX_SEC_TO_TICK = 290\nfrom bs4 import BeautifulSoup\ndef load_scip_sol_file(sol_file: str):\n    return solution_loader(sol_file, parse_scip_solution_content)"
        },
        {
            "comment": "This code defines functions for parsing CPLEX solution content, loading CPLEX solution files, and invoking a solver with custom configuration and solution parser. The CPLEX solution is parsed using BeautifulSoup with the \"xml\" parser, and the solution is loaded by reading file content and passing it to the parser function. The solver is invoked within a temporary directory using a model-solving context manager.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/failsafe_utils.py\":232-262",
            "content": "def parse_cplex_solution_content(content):\n    # 'xml' is the parser used. For html files, which BeautifulSoup is typically used for, it would be 'html.parser'.\n    soup = BeautifulSoup(content, \"xml\")\n    data = {}\n    for var in soup.find_all(\"variable\"):\n        name = var[\"name\"]\n        value = float(var[\"value\"])\n        data[name] = value\n    return data\ndef solution_loader(sol_file: str, parser):\n    with open(sol_file, \"r\") as f:\n        content = f.read()\n        data = parser(content)\n        return data\ndef load_cplex_sol_file(sol_file: str):\n    return solution_loader(sol_file, parse_cplex_solution_content)\ndef invoke_solver_with_custom_config_and_solution_parser(\n    mw, logfile: str, timelimit: int, script_generator, script_executor, solution_parser\n):\n    solved = False\n    # TODO: logging\n    with tempfile.TemporaryDirectory() as tmpdir:\n        with chdir_context(tmpdir):\n            with modelSolvedTestContext(mw.model) as check_solved:\n                # lp_path_abs = os.path.join(tmpdir, lp_path := \"model.mps\")"
        },
        {
            "comment": "This code generates a script for a linear programming problem, executes it, and assigns the solution to the corresponding model variables if the solution exists. The solution count is also tracked.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/failsafe_utils.py\":263-289",
            "content": "                lp_path_abs = os.path.join(tmpdir, lp_path := \"model.lp\")\n                sol_path = \"solution.sol\"\n                exp_model = ExportedModel(mw.model, lp_path_abs)\n                script = script_generator(lp_path, sol_path)\n                script_executor(script, logfile, timelimit)\n                if os.path.exists(sol_path):\n                    # TODO: parse and assign value from solution\n                    solution = solution_parser(sol_path)\n                    for v in mw.model.component_data_objects(ctype=Var):\n                        varname = v.name\n                        trans_varname = exp_model.reverse_translation_table.get(\n                            varname, None\n                        )\n                        val = solution.get(trans_varname, None)\n                        if val is not None:\n                            v.set_value(val)\n                    solved = check_solved()\n                # breakpoint()\n    return solved\nSOLUTION_COUNT = 0\ndef feasopt_script_generator("
        },
        {
            "comment": "This code generates a script for the CPLEX optimization solver to solve an LP problem and returns it. The script takes parameters such as the LP file path, solver mode, solution count, and deterministic fail-safe setting. The function uses partial to pass the mode and solutionCount parameters to the feasopt_script_generator function.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/failsafe_utils.py\":290-320",
            "content": "    lp_path: str, sol_path: str, mode: FeasoptMode, solutionCount: int\n):\n    cplex_config = [\n        f\"timelimit {FEASOPT_TIMELIMIT}\"\n        if not ies_env.DETERMINISTIC_FAILSAFE\n        else f\"dettimelimit {FEASOPT_TIMELIMIT*CPLEX_SEC_TO_TICK}\",\n        f\"feasopt mode {mode}\",\n    ]\n    if solutionCount > 0:\n        cplex_config.append(f\"mip limits solutions {solutionCount}\")\n    if ies_env.DETERMINISTIC_FAILSAFE:\n        cplex_config.append(f\"randomseed {ies_env.ANSWER_TO_THE_UNIVERSE}\")\n    script = [\n        f\"read {lp_path}\",\n        *[f\"set {c}\" for c in cplex_config],\n        \"feasopt all\",  # dettime: 8816 ticks for 30s timelimit\n        f\"write {sol_path}\",\n        \"quit\",\n    ]\n    return script\nfrom functools import partial\ndef feasopt(mw, mode: FeasoptMode, logfile: str, solutionCount: int = SOLUTION_COUNT):\n    solved = invoke_solver_with_custom_config_and_solution_parser(\n        mw,\n        logfile,\n        FEASOPT_TIMELIMIT + 10,\n        partial(feasopt_script_generator, mode=mode, solutionCount=solutionCount),"
        },
        {
            "comment": "The code defines a function `feasopt_with_optimization` and `feasopt_only`, which utilize the `feasopt` method to perform feasibility checks on an input `mw` (presumably a model) with different modes. The first mode aims for optimal minimum sum relaxation, while the second aims only for minimum sum relaxation. Additionally, the code includes a `scip_minuc_script_generator` function that generates a set of instructions for the SCIP optimization software. This function can handle multiple solutions and implements some deterministic failsafe measures if necessary.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/failsafe_utils.py\":321-354",
            "content": "        cplex_exec_script,\n        load_cplex_sol_file,\n    )\n    return solved\n@failsafe_methods.register\ndef feasopt_with_optimization(mw, logdir: str):\n    logfile = os.path.join(logdir, \"cplex_feasopt_with_optimization_failsafe.log\")\n    return feasopt(mw, FeasoptMode.optimal_minimum_sum_relaxation, logfile), logfile\n@failsafe_methods.register\ndef feasopt_only(mw, logdir: str):\n    logfile = os.path.join(logdir, \"cplex_feasopt_only_failsafe.log\")\n    return feasopt(mw, FeasoptMode.minimum_sum_relaxation, logfile), logfile\ndef scip_minuc_script_generator(\n    lp_path: str, sol_path: str, solutionCount: int = SOLUTION_COUNT\n):\n    scip_config = [\n        f\"limits time {FEASOPT_TIMELIMIT}\",\n    ]\n    if solutionCount > 0:\n        scip_config.extend(\n            [\n                f\"limits solutions {solutionCount}\",\n                f\"limits maxsol {solutionCount}\",\n            ]\n        )\n    if ies_env.DETERMINISTIC_FAILSAFE:\n        scip_config.append(f\"random lpseed {ies_env.ANSWER_TO_THE_UNIVERSE}\")\n        scip_config.append(f\"random permutationseed {ies_env.ANSWER_TO_THE_UNIVERSE}\")"
        },
        {
            "comment": "This code snippet defines a failsafe method for SCIP solver and registers it. The `scip_minuc` function invokes the SCIP solver with a custom configuration and solution parser, then returns the solved status and log file path. It also defines constants for IPOPT settings, but mentions that the `ipopt_no_presolve` method is deprecated.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/failsafe_utils.py\":355-394",
            "content": "        scip_config.append(f\"random randomseedshift {ies_env.ANSWER_TO_THE_UNIVERSE}\")\n    script = [\n        f\"read {lp_path}\",\n        *[f\"set {c}\" for c in scip_config],\n        \"change minuc\",\n        \"optimize\",\n        f\"write solution {sol_path}\",\n        \"quit\",\n    ]\n    return script\n@failsafe_methods.register\ndef scip_minuc(mw, logdir: str):\n    logfile = os.path.join(logdir, \"scip_minuc.log\")\n    solved = invoke_solver_with_custom_config_and_solution_parser(\n        mw,\n        logfile,\n        FEASOPT_TIMELIMIT * 3,\n        scip_minuc_script_generator,\n        scip_exec_script,\n        load_scip_sol_file,\n    )\n    return solved, logfile\nIPOPT_MAX_ITERATION = 1000\nIPOPT_TIMELIMIT = 30\nIPOPT_ITERATION_KW = \"Number of Iterations\"\nIPOPT_MAX_ITER_CONFIG_KW = \"max_iter\"\nIPOPT_MAX_CPUTIME_CONFIG_KW = \"max_cpu_time\"\nIPOPT_MAX_CPUTIME = 10\n# you cannot use ipopt with constant objective.\n# @failsafe_methods.register\n# don't register it. deprecated.\ndef ipopt_no_presolve(mw, logdir: str):\n    solved = False\n    logfile = os.path.join(logdir, \"ipopt_failsafe.log\")"
        },
        {
            "comment": "This code sets up a solver to solve an optimization model. If the failsafe is deterministic, it uses random seeds for initial variable values. If the solver does not find a solution, it parses the logfile and reruns the task with adjustments.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/failsafe_utils.py\":395-413",
            "content": "    with SolverFactory(Solver.ipopt) as solver:\n        with modelSolvedTestContext(mw.model) as check_solved:\n            solver.options[IPOPT_MAX_ITER_CONFIG_KW] = IPOPT_MAX_ITERATION\n            solver.options[IPOPT_MAX_CPUTIME_CONFIG_KW] = IPOPT_MAX_CPUTIME\n            if ies_env.DETERMINISTIC_FAILSAFE:\n                # we pass initial values of variables as random seeds. don't have cli configuration.\n                ...\n            solved = ipopt_solve(mw, logfile, solver, check_solved)\n            if not solved:\n                # parse the logfile and rerun the task.\n                adjusted_max_iter = 0\n                if os.path.exists(logfile):\n                    with open(logfile, \"r\") as f:\n                        content = f.read()\n                        content_lines = content.split(\"\\n\")\n                        for line in content_lines:\n                            if IPOPT_ITERATION_KW in line:\n                                iteration = re.search(r\"\\d+\", line).group()\n                                logger_print(\"IPOPT FAILED AT ITERATION: \", iteration)"
        },
        {
            "comment": "The code snippet is for a failsafe utility function that attempts to solve a problem using the IPOPT solver. If the iteration count cannot be obtained from a failed IPOPT session, it logs a failure message. The `ipopt_solve` function takes a model, logfile, and check_solved function as inputs and uses failsafe suppression to attempt solving the model with IPOPT, returning whether or not the problem was solved. The `random_value_assignment` method sets random values for variables in the model using a lambda function and skips validation to suppress W1001 warnings.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/failsafe_utils.py\":414-440",
            "content": "                                adjusted_max_iter = int(iteration) - 1\n                                break\n                if adjusted_max_iter > 0:\n                    solver.options[IPOPT_MAX_ITER_CONFIG_KW] = adjusted_max_iter\n                    os.remove(logfile)\n                    solved = ipopt_solve(mw, logfile, solver, check_solved)\n                else:\n                    logger_print(\n                        \"FAILED TO GET ITERATION COUNT FROM FAILED IPOPT SESSION\"\n                    )\n            # breakpoint()\n    return solved, logfile\ndef ipopt_solve(mw, logfile, solver, check_solved):\n    solved = False\n    with failsafe_suppress_exception():\n        solver.solve(mw.model, tee=True, logfile=logfile, timelimit=IPOPT_TIMELIMIT)\n        solved = check_solved()\n    return solved\n@failsafe_methods.register\ndef random_value_assignment(mw, logdir: str):\n    rng = lambda: random.uniform(-100, 100)\n    for v in mw.model.component_data_objects(ctype=Var):\n        v.set_value(rng(), skip_validation=True)  # suppress W1001"
        },
        {
            "comment": "The code defines a function 'solve_failsafe' that applies four different methods in a specific order to solve a problem. The methods are 'feasopt_with_optimization', 'feasopt_only', 'ipopt_no_presolve', and 'random_value_assignment'. If any of the methods successfully solve the problem, it stops and returns True along with the logfile path. The code also includes a try-except block to handle possible failures during execution.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/failsafe_utils.py\":441-478",
            "content": "        # ref: https://pyomo.readthedocs.io/en/stable/errors.html#W1001\n    return (\n        True,\n        \"\",\n    )  # instead of None, to prevent unwanted behavior when checking existance\n# for m in [\n#     feasopt_with_optimization,\n#     feasopt_only,\n#     ipopt_no_presolve,\n#     random_value_assignment,\n# ]:\n#     failsafe_methods.add(m)\ndef solve_failsafe(mw, logdir: str):\n    \"\"\"\n    Steps (fail and continue):\n        1. feasopt & objective optimization\n        2. feasopt only\n        3. scip minuc\n        4. random value assignment\n    \"\"\"\n    solved = False\n    report = []\n    for method in failsafe_methods:\n        name = method.__name__\n        try:\n            logger_print(f\"trying failsafe method: {name}\")\n            solved, logfile = method(mw, logdir)\n            if solved:\n                logger_print(f\"solved with {name}\")\n                if os.path.exists(logfile):\n                    logger_print(f\"logfile write to: {logfile}\")\n                else:\n                    logger_print(f\"logfile not found at: {logfile}\")"
        },
        {
            "comment": "This code defines a failsafe utility function that suppresses exceptions, checks if solutions are found for certain operations, and logs information about the operations. It is used within an 'if __name__ == \"__main__\"' block to demonstrate how it handles different types of exceptions.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/failsafe_utils.py\":479-499",
            "content": "                break  # you may not break just because of the 'solved' flag but also the existance of the logfile.\n            else:\n                logger_print(f\"failed to solve with {name}\")\n            report.append((name, solved, os.path.exists(logfile)))\n        except:\n            report.append((name, False, False))\n            logger_traceback()\n    for n, r, l_exists in report:\n        logger_print(f\"{n}:\\t{r}\\t(logfile exists? {l_exists})\")\n    return solved\nif __name__ == \"__main__\":\n    ies_env.FAILSAFE = True\n    with failsafe_suppress_exception():\n        raise Exception(\"Exc\")\n    # it will reach and raise Exc2\n    ies_env.FAILSAFE = False\n    with failsafe_suppress_exception():\n        raise Exception(\"Exc2\")"
        }
    ]
}