{
    "summary": "The function iteratively shifts subsections of data to optimize the region with lowest error, using adaptive sampling and calculating overall error for comparison.",
    "details": [
        {
            "comment": "This function performs a shift in the data and calculates errors for different regions, aiming to optimize the region with lowest error.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/adaptive_sampling/test_shift.py\":0-30",
            "content": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\ndef fit_and_get_error(x, y, region):\n    start, end = region\n    model = LinearRegression()\n    model.fit(x[start : end + 1].reshape(-1, 1), y[start : end + 1])\n    # Calculate the predicted values\n    y_pred = model.predict(x[start : end + 1].reshape(-1, 1))\n    # Calculate the error (element-wise)\n    error = np.abs(y[start : end + 1] - y_pred)\n    return np.sum(error)\ndef perform_shift(x, y, left_region, right_region):\n    # either return one or two regions after shifting\n    left_start, _ = left_region\n    _, right_end = right_region\n    merged_region = (left_start, right_end)\n    regions_to_error = [(merged_region, fit_and_get_error(x, y, merged_region))]\n    for i in range(right_end - left_start - 2):\n        new_left_start = left_start + i + 1\n        new_right_start = new_left_start + 1\n        new_left_region = (left_start, new_left_start)\n        new_right_region = (new_right_start, right_end)\n        left_error = fit_and_get_error(x, y, new_left_region)"
        },
        {
            "comment": "Function for iteratively shifting breakpoints based on subsections of x and y data. Continues until maximum subsection count is reached or no change in subsections.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/adaptive_sampling/test_shift.py\":31-62",
            "content": "        right_error = fit_and_get_error(x, y, new_right_region)\n        total_error = left_error + right_error\n        regions_to_error.append(((new_left_region, new_right_region), total_error))\n    regions_to_error.sort(key=lambda x: x[1])\n    # print(regions_to_error)\n    regions = regions_to_error[0][0]\n    regions = list(regions)\n    return regions\nimport copy\n# Iterative shifting of breakpoints\ndef shifting_approximation(x, y, subsections: list[tuple[float, float]]):\n    assert (\n        len(subsections) >= 2\n    ), f\"cannot merge subsections because you only have one or less section.\\npassed: {subsections}\"\n    subsections = [(x, y) for x, y in subsections]\n    subsections.sort(key=lambda x: x[0])\n    last_sections = []\n    current_sections = copy.deepcopy(subsections)\n    # Iterate until the maximum subsection count is reached\n    # i = 0\n    while set(last_sections) != set(current_sections):\n        # print(f'iteration: #{i}')\n        # i+=1\n        last_sections = copy.deepcopy(current_sections)\n        left_region = current_sections[0]"
        },
        {
            "comment": "This function performs adaptive sampling by shifting subsections within three given sections. It takes x and y as input, along with current_sections, and returns updated current_sections after performing shifts. The fit_and_get_error function is used to calculate the error for each region. The function also includes examples of getting random regions, which can be useful for implementing adaptive sampling strategies.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/adaptive_sampling/test_shift.py\":63-101",
            "content": "        right_region = current_sections[1]\n        new_subsections = perform_shift(x, y, left_region, right_region)\n        for candidate in current_sections[2:]:\n            last_new_candidate = new_subsections.pop(-1)\n            outputs = perform_shift(x, y, last_new_candidate, candidate)\n            new_subsections.extend(outputs)\n        # Update the subsections\n        current_sections = new_subsections\n    return current_sections\n# Example usage\nx = np.linspace(0, 10, 100)\ny = x**2\n# y = np.sin(x)\ndef get_overall_error(x, y, regions):\n    error = 0\n    for region in regions:\n        error += fit_and_get_error(x, y, region)\n    return error\n# randomize and shift?\nimport random\ndef get_random_regions(population, size):\n    start = 0\n    end = population -1\n    candidates = list(range(1, population-1))\n    assert len(candidates) > 0, f\"wrong population and size: ({population}, {size})\"\n    chosen = random.sample(candidates, k=size)\n    chosen.sort()\n    ret = []\n    for _s, _e in zip([start, *chosen[:-1]], [*chosen[1:], end]):"
        },
        {
            "comment": "This code calculates and prints the overall error for a set of subsections, then applies shifting approximation to improve the sections and recalculates the error. The code compares different methods of creating subsections and evaluates their effectiveness by measuring the overall error before and after the shifting approximation is applied.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/adaptive_sampling/test_shift.py\":102-129",
            "content": "        ret.append((_s, _e))\n    return ret\nregion_to_size = lambda regions: [y - x for x, y in regions]\n# no better than uniform regions\nsubsections = get_random_regions(100, 10)\n# 6.52 -> 6.52\n# subsections = [(i * 10, (i + 1) * 10 - 1) for i in range(10)]\n# 5.76 -> 4.54\n# subsections = [(0, 6), (7, 12), (13, 24), (25, 31), (32, 37), (38, 49), (50, 56), (57, 62), (63, 74), (75, 81), (82, 87), (88, 99)]\n# 7.94 -> 7.10\n# subsections = [(0, 6), (7, 12), (13, 24), (25, 31), (32, 37), (38, 49), (50, 62), (63, 74), (75, 87), (88, 99)]\nprint(\n    \"Before:\",\n    subsections,\n    region_to_size(subsections),\n    get_overall_error(x, y, subsections),\n    sep=\"\\n\",\n)\nsubsections = shifting_approximation(x, y, subsections)\nprint(\n    \"After:\",\n    subsections,\n    region_to_size(subsections),\n    get_overall_error(x, y, subsections),\n    sep=\"\\n\",\n)"
        }
    ]
}