{
    "summary": "The code performs microgrid network validation, initializes topology graphs and nodes, establishes connections, and handles exceptions. It utilizes libraries, defines functions, and creates instances of devices and interfaces from JSON data.",
    "details": [
        {
            "comment": "Code imports necessary libraries, defines a function to get main and subtype from data, and sets up various types of objects (devices, busbars, lines) in a template-based manner. It also defines a neighbor iterator macro.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/topo_check_v1.py.j2\":0-40",
            "content": "from log_utils import logger_print\n{# from pydantic import BaseModel #}\n{# import when needed. #}\nimport networkx\nfrom networkx.readwrite import json_graph\nfrom config import ies_env\n# when to check topology:\n# \t1.  Building topology <- which the frontend does the job\n# \t2.  Importing topology <- where algorithm kicks in\n# so here we only check topo when importing. we don't check validity during topo construction.\n{# type_sys = {{str(type_sys)}} # will work? #}\n# \u6bcd\u7ebf\u6700\u591a99\u4e2a\u5bf9\u63a5\u7684\u63a5\u53e3\ndef getMainAndSubType(data):\n    logger_print(\"DATA:\", data)\n    return data['type'], data['subtype']\n# better use some template.\n# \u8bbe\u5907\u3001\u6bcd\u7ebf\u3001\u8fde\u63a5\u7ebf\u3001\u5408\u5e76\u7ebf\n{% for mtype, mdata in \u7c7b\u578b\u96c6\u5408\u5206\u7c7b %}\n{{mtype}}\u7c7b\u578b = {{mdata}}\n{% endfor %}\n\u8bbe\u5907\u63a5\u53e3\u96c6\u5408 = {{ \u8bbe\u5907\u63a5\u53e3\u96c6\u5408 }}\n\u8fde\u63a5\u7c7b\u578b\u6620\u5c04\u8868 = {{\u8fde\u63a5\u7c7b\u578b\u6620\u5c04\u8868}}\n{# \ndef getMainAndSubType(data):\n    mainType = data['type']\n    subType = data['subtype']\n    return mainType, subType #}\n{% macro neighborIterator() %}\n                for n in neighbors:\n                    ne_data = self.G.nodes[n]\n                    ne_type, ne_subtype = getMainAndSubType(ne_data)"
        },
        {
            "comment": "This code defines a class for a topology graph and includes helper macros to add nodes and handle errors. The main functionality is initializing the topology graph object, iterating through node data in the graph, setting IDs, and handling different types of nodes (input, output, input/output). It also checks if the node type is known or throws an exception if not.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/topo_check_v1.py.j2\":42-68",
            "content": "{% endmacro %}\n{% macro adderMacro(source_subtype, source_id, target)%}\n                    if {{source_subtype}}.endswith(\"\u8f93\u5165\u8f93\u51fa\"):\n                        {{target}}['IO'].append({{source_id}})\n                    elif {{source_subtype}}.endswith(\"\u8f93\u5165\"):\n                        {{target}}['output'].append({{source_id}})\n                    elif {{source_subtype}}.endswith(\"\u8f93\u51fa\"):\n                        {{target}}['input'].append({{source_id}})\n                    else:\n                        raise Exception(\"Unknown type:\", {{source_subtype}})\n{% endmacro %}\n{% macro error_node_info(node_id=\"node_id\")%}\u8282\u70b9 {{\"#{\"}}{{node_id}}{{\"}\"}}{% endmacro %}\nclass \u62d3\u6251\u56fe:\n    def __init__(self, **kwargs):\n        self.node_count = 0\n        self.G = networkx.Graph(**kwargs)\n        self.\u5408\u5e76\u6bcd\u7ebfID\u96c6\u5408\u5217\u8868 = []\n        self.is_valid = ies_env.FAILSAFE\n    def get_all_devices(self) -> list:\n        devs = []\n        for node_index, node_data in self.G.nodes.items():\n            node_type = node_data['type']\n            node_data['id'] = node_index"
        },
        {
            "comment": "This code defines two functions, `get_all_devs()` and `get_all_adders()`, which appear to be part of a larger class. The `get_all_devs()` function returns a list of device nodes based on their types, while the `get_all_adders()` function populates an adder dictionary using adder IDs and node information from the graph (G). It seems that this code is related to some sort of network or grid topology.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/topo_check_v1.py.j2\":70-94",
            "content": "            if node_type == \"\u8bbe\u5907\":\n                devs.append(node_data)\n        return devs\n    def get_all_adders(self) -> dict: # don't care about types here.\n        # use adder ids. adder starts with -1\n        adders = {min(s):{\"input\":[], \"output\":[], \"IO\":[]} for s in self.\u5408\u5e76\u6bcd\u7ebfID\u96c6\u5408\u5217\u8868} # \u7528\u5230\uff1a\u5408\u5e76\u6bcd\u7ebfID\u96c6\u5408\u5217\u8868\n        adder_id = -1\n        \u6bcd\u7ebfID\u6620\u5c04\u8868 = {e:min(s) for s in self.\u5408\u5e76\u6bcd\u7ebfID\u96c6\u5408\u5217\u8868 for e in s}\n        # format: {\"input\":input_ids, \"output\": output_ids, \"IO\": IO_ids}\n        for node_index, node_data in self.G.nodes.items():\n            node_type = node_data[\"type\"]\n            if node_type == \"\u8fde\u63a5\u7ebf\":\n                adder = {\"input\":[], \"output\":[], \"IO\":[]}\n                #  \u68c0\u67e5\u8fde\u63a5\u7ebf\u4e24\u7aef\n                left_id, right_id = self.G.neighbors(node_index)\n                left_type = self.G.nodes[left_id]['type']\n                right_type = self.G.nodes[right_id]['type']\n                left_subtype = self.G.nodes[left_id]['subtype']\n                right_subtype = self.G.nodes[right_id]['subtype']\n                if left_type == \"\u6bcd\u7ebf\" and right_type == \"\u951a\u70b9\":"
        },
        {
            "comment": "The code appears to be part of a network topology checker, with functions for adding nodes, getting graph data, and checking connections between different types of elements. It seems to involve some translation or mapping between \"\u951a\u70b9\" (anchor points) and \"\u6bcd\u7ebf\" (mother lines). The adderMacro function is used to process subtypes and adders. An exception is thrown for unreasonable connection line endpoints.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/topo_check_v1.py.j2\":95-118",
            "content": "                    (left_id, left_type, left_subtype), (right_id, right_type,right_subtype) = (right_id, right_type,right_subtype), (left_id, left_type, left_subtype)\n                if left_type == \"\u951a\u70b9\" and right_type == \"\u951a\u70b9\":\n{{ adderMacro(\"left_subtype\", \"left_id\", \"adder\") }}\n{{ adderMacro(\"right_subtype\", \"right_id\", \"adder\") }}\n                    adders[adder_id] = adder\n                    adder_id -= 1\n                elif left_type == \"\u951a\u70b9\" and right_type == \"\u6bcd\u7ebf\":\n                    madder_id = \u6bcd\u7ebfID\u6620\u5c04\u8868[right_id]\n{{ adderMacro(\"left_subtype\", \"left_id\", \"adders[madder_id]\") }}\n                else:\n                    raise Exception(f\"\u4e0d\u5408\u7406\u7684\u8fde\u63a5\u7ebf\u4e24\u7aef\uff1a{left_type}[{left_subtype}]-{right_type}[{right_subtype}]\")\n                {# adders.append(adder) #}\n        return adders\n    def get_graph_data(self) -> dict: # primary data. shall be found somewhere.\n        graph_data = self.G.graph\n        return graph_data\n    def add_node(self, **kwargs):\n        self.G.add_node(self.node_count,**kwargs)\n        node_id = self.node_count"
        },
        {
            "comment": "This code is performing a consistency check on a microgrid network. It iterates through each node, checks its type and subtype, and ensures that the connections and attributes are correct. If any errors occur, it raises an assertion error with relevant information about the problematic node. The function also includes a call to `neighborIterator()`, likely for further processing of neighboring nodes.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/topo_check_v1.py.j2\":119-142",
            "content": "        self.node_count += 1\n        return node_id\n    # monotonically adding a node.\n    def check_consistency(self): # return nothing.\n        #  use subgraph\n        # \u63d0\u53d6\u6240\u6709\u6bcd\u7ebfID\n        \u6bcd\u7ebfID\u5217\u8868 = []\n        \u5408\u5e76\u7ebfID\u5217\u8868 = []\n        for node_id, node_data in self.G.nodes.items():\n            node_type, node_subtype = getMainAndSubType(node_data)\n            logger_print(\"NODE TYPE:\", node_type)\n            logger_print(\"NODE SUBTYPE:\", node_subtype)\n            neighbors = list(self.G.neighbors(node_id))\n            logger_print(\"NEIGHBORS:\", neighbors)\n            for n in neighbors:\n                logger_print(self.G.nodes[n])\n            logger_print(\"=\"*40)\n            if node_type == \"\u6bcd\u7ebf\":\n                \u6bcd\u7ebfID\u5217\u8868.append(node_id)\n                assert node_subtype in \u6bcd\u7ebf\u7c7b\u578b, f\"{{error_node_info()}} \u4e0d\u5b58\u5728\u7684\u6bcd\u7ebf\u7c7b\u578b: {node_subtype}\"\n                assert len(neighbors) <= 99, f\"{{error_node_info()}} \u6bcd\u7ebf\u8fde\u63a5\u6570\u8d85\u8fc799: {len(neighbors)}\"\n{{ neighborIterator()}}\n                    if ne_type == \"\u5408\u5e76\u7ebf\":\n                        # just check type."
        },
        {
            "comment": "The code is validating the node subtype and ensuring that it belongs to a defined set of types for each type of node. It also checks if the connection between nodes is logical by comparing their subtypes. If any of these assertions fail, an exception is raised with a descriptive error message. The \"\u8bbe\u5907\u7c7b\u578b\" and \"\u8fde\u63a5\u7ebf\u7c7b\u578b\" sets are not defined in this code snippet but should be available elsewhere in the codebase to allow for proper validation of the node subtype.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/topo_check_v1.py.j2\":143-157",
            "content": "                        assert ne_subtype in \u5408\u5e76\u7ebf\u7c7b\u578b, f\"{{error_node_info('n')}} \u4e0d\u5b58\u5728\u7684\u5408\u5e76\u7ebf\u7c7b\u578b: {ne_subtype}\"\n                        assert ne_subtype.replace(\"\u5408\u5e76\", \"\u8fde\u63a5\") == node_subtype, f\"{{error_node_info('n')}}\"\n                    elif ne_type == \"\u8fde\u63a5\u7ebf\":\n                        assert ne_subtype in \u8fde\u63a5\u7ebf\u7c7b\u578b, f\"{{error_node_info('n')}} \u4e0d\u5b58\u5728\u7684\u8fde\u63a5\u7ebf\u7c7b\u578b: {ne_subtype}\"\n                        assert ne_subtype.replace('\u4e0d\u53ef','\u53ef').replace(\"\u8f93\u5165\",\"\").replace(\"\u8f93\u51fa\",\"\") == node_subtype, f\"{{error_node_info('n')}} \u4e0d\u5408\u7406\u7684\u8fde\u63a5\u5bf9\uff1a ({ne_subtype}, {node_subtype})\"\n                    else:\n                        raise Exception(f\"{{error_node_info('n')}} {node_subtype}\u8fde\u63a5\u975e\u6cd5\u7c7b\u578b\u8282\u70b9\uff1a\",ne_type)\n            elif node_type == \"\u8bbe\u5907\":\n                assert node_subtype in \u8bbe\u5907\u7c7b\u578b, f\"{{error_node_info()}} \u4e0d\u5b58\u5728\u7684\u8bbe\u5907\u7c7b\u578b: {node_subtype}\"\n                port_set = set()\n{{neighborIterator()}}\n                    port_name = ne_data['port_name']\n                    assert ne_type == \"\u951a\u70b9\", f\"{{error_node_info('n')}} \u9519\u8bef\u7684\u8282\u70b9\u7c7b\u578b: {ne_type}\"\n                  "
        },
        {
            "comment": "This code checks the number of neighbors for each node and verifies if they are of valid subtypes. It also ensures that the port set is correct and prevents self-connections. The code handles nodes of types \"\u7535\u6e90\u7ad9\" and \"\u8fde\u63a5\u7ebf\".",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/topo_check_v1.py.j2\":157-173",
            "content": "  assert len(list(self.G.neighbors(n))) == 2, f\"{{error_node_info('n')}} \u76f8\u90bb\u8282\u70b9\u6570\u9519\u8bef: {len(list(self.G.neighbors(n)))} \u76f8\u90bb\u8282\u70b9: {(list(self.G.neighbors(n)))}\"\n                    port_set.add((port_name, ne_subtype))\n                assert port_set == \u8bbe\u5907\u63a5\u53e3\u96c6\u5408[node_subtype], f\"{{error_node_info()}}  PORT SET: {port_set} TARGET: {\u8bbe\u5907\u63a5\u53e3\u96c6\u5408[node_subtype]}\"\n            elif node_type == \"\u8fde\u63a5\u7ebf\":\n                assert node_subtype in \u8fde\u63a5\u7ebf\u7c7b\u578b, f'{{error_node_info()}} \u4e0d\u5408\u7406\u8fde\u63a5\u7ebf\u7c7b\u578b\uff1a {node_subtype}'\n                assert len(neighbors) == 2, f'{{error_node_info()}} \u4e0d\u5408\u7406\u8fde\u63a5\u7ebf\u76f8\u90bb\u8282\u70b9\u6570: {len(neighbors)} \u76f8\u90bb\u8282\u70b9: {neighbors}'\n                dev_ids = set()\n                subtypes = []\n                {{neighborIterator()}}\n                    assert ne_type in [\"\u951a\u70b9\",\"\u6bcd\u7ebf\"]\n                    subtypes.append(ne_subtype)\n                    if ne_type == \"\u951a\u70b9\":\n                        dev_ids.add(ne_data['device_id'])\n                    else:\n                        dev_ids.add(n)\n                assert len(dev_ids) == 2, f'{{error_node_info()}} invalid dev_ids: {dev_ids}' # no self-connection."
        },
        {
            "comment": "This code is checking the types of nodes in a topology and ensuring they adhere to certain conditions. It handles three types: connection lines, merging lines, and anchors. The code raises exceptions for unknown node subtypes or if merging lines have an incorrect number of neighbors. If the node type is not recognized, it throws an exception with the unknown type. Finally, it creates a subgraph containing all mother and merge lines.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/topo_check_v1.py.j2\":174-191",
            "content": "                try:\n                    assert \u8fde\u63a5\u7c7b\u578b\u6620\u5c04\u8868[frozenset(subtypes)] == node_subtype\n                except:\n                    raise Exception(f\"{{error_node_info()}} \u672a\u77e5\u8fde\u63a5\u7ec4\u5408: (\u4e24\u7aef: {subtypes} \u8fde\u63a5\u7ebf: {node_subtype})\")\n            elif node_type == \"\u5408\u5e76\u7ebf\":\n                \u5408\u5e76\u7ebfID\u5217\u8868.append(node_id)\n                assert node_subtype in \u5408\u5e76\u7ebf\u7c7b\u578b, f\"{{error_node_info()}} \u672a\u77e5\u5408\u5e76\u7ebf\u7c7b\u578b: {node_subtype}\"\n                assert len(neighbors) == 2, f\"{{error_node_info()}} \u4e0d\u5408\u7406\u76f8\u90bb\u8282\u70b9\u6570: {len(neighbors)} \u76f8\u90bb\u8282\u70b9: {len(neighbors)}\"\n                node_ids = set()\n                {{neighborIterator()}}\n                    assert ne_type == \"\u6bcd\u7ebf\", f\"{{error_node_info('n')}} \u4e0d\u5408\u7406\u7c7b\u578b: {ne_type}\"\n                    node_ids.add(n)\n                assert len(node_ids) == 2, f\"{{error_node_info()}} \u4e0d\u5408\u7406\u5408\u5e76\u7ebf\u603b\u8282\u70b9\u6570\uff1a{len(node_ids)} \u8282\u70b9\u5217\u8868: {node_ids}\"\n            elif node_type == '\u951a\u70b9':\n                continue\n            else:\n                raise Exception(\"unknown node type:\", node_type)\n        subgraph = self.G.subgraph(\u6bcd\u7ebfID\u5217\u8868+\u5408\u5e76\u7ebfID\u5217\u8868) # check again."
        },
        {
            "comment": "This code initializes a logger print of the bus ID list, then merges bus IDs into a set and stores them in a list. It checks if there are any input or output connections for each bus and stores them separately.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/topo_check_v1.py.j2\":192-211",
            "content": "        logger_print(\"\u6bcd\u7ebfID\u5217\u8868:\", \u6bcd\u7ebfID\u5217\u8868)\n        {# breakpoint() #}\n        self.\u5408\u5e76\u6bcd\u7ebfID\u96c6\u5408\u5217\u8868 = list(networkx.connected_components(subgraph))\n        self.\u5408\u5e76\u6bcd\u7ebfID\u96c6\u5408\u5217\u8868 = [set([i for i in e if i not in \u5408\u5e76\u7ebfID\u5217\u8868]) for e in self.\u5408\u5e76\u6bcd\u7ebfID\u96c6\u5408\u5217\u8868]\n        logger_print(\"\u5408\u5e76\u6bcd\u7ebfID\u96c6\u5408\u5217\u8868:\", self.\u5408\u5e76\u6bcd\u7ebfID\u96c6\u5408\u5217\u8868)\n        for id_set in self.\u5408\u5e76\u6bcd\u7ebfID\u96c6\u5408\u5217\u8868:\n            has_input = False\n            has_output = False\n            input_conns = []\n            output_conns = []\n            for node_id in id_set:\n                node_data = self.G.nodes[node_id]\n                {# if node_data['type'] == '\u5408\u5e76\u7ebf': continue #}\n                conn = [e for e in node_data['conn'] if not e.startswith(\"\u53ef\u5408\u5e76\")] # list.\n                merge = [e for e in node_data['conn'] if e.startswith(\"\u53ef\u5408\u5e76\")]\n                assert len(merge)<=2, f'{{error_node_info()}} \u9519\u8bef\u7684\u53ef\u5408\u5e76\u8fde\u63a5\u6570: {len(merge)} \u53ef\u5408\u5e76\u7ebf\u5217\u8868: {merge}'\n                for c in conn:\n                    if not c.endswith(\"\u8f93\u5165\u8f93\u51fa\"):\n                        if c.endswith(\"\u8f93\u5165\"):\n                            input_conns.append(c)"
        },
        {
            "comment": "The code checks the connections of motherlines and their nodes, ensuring they have at least one input and one output connection. If a motherline does not meet this requirement, it raises an exception with error information. If all motherlines satisfy the condition, the code continues execution.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/topo_check_v1.py.j2\":212-235",
            "content": "                            has_input=True\n                        elif c.endswith(\"\u8f93\u51fa\"):\n                            output_conns.append(c)\n                            has_output=True\n                        else:\n                            raise Exception(f\"{self.G.nodes[node_id]['type']}\u4e0d\u53ef\u63a5\u53d7\u7684\u8fde\u63a5\u7c7b\u578b: {c}\")\n            if has_input and has_output:\n                # \u68c0\u67e5\u67f4\u6cb9\u7c7b\u578b\u7684\n                if output_conns[0] == \"\u4e0d\u53ef\u8fde\u63a5\u67f4\u6cb9\u6bcd\u7ebf\u8f93\u51fa\":\n                    assert len(output_conns) == 1, f\"{{error_node_info()}} \u67f4\u6cb9\u6bcd\u7ebf\u6709\u4e14\u53ea\u6709\u4e00\u4e2a\u4e0e\u67f4\u6cb9\u5143\u4ef6\u7684\u8fde\u63a5\"\n            else:\n                logger_print()\n                logger_print(\"============ERROR LOG============\")\n                logger_print()\n                for n in id_set:\n                    logger_print(\"\u6bcd\u7ebf:\", self.G.nodes[n])\n                logger_print()\n                logger_print(\"INPUT:\", has_input)\n                logger_print(\"OUTPUT:\", has_output)\n                logger_print()\n                raise Exception(f\"\u6bcd\u7ebf\u7ec4{id_set}\u672a\u5b9e\u73b0\u81f3\u5c11\u4e00\u8fdb\u4e00\u51fa\")\n        self.is_valid = True\n    def to_json(self) -> dict:"
        },
        {
            "comment": "This code defines a class for topology graphs, a Node class representing nodes in the graph, and a Busbar class and Device class extending Node. The classes can be initialized with specific types, subtypes, and other parameters. The code also includes methods to create a topology from JSON data and check the consistency of the topology.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/topo_check_v1.py.j2\":236-272",
            "content": "        data = json_graph.node_link_data(self.G)\n        return data\n    @staticmethod\n    def from_json(data):\n        # load data to graph\n        G = json_graph.node_link_graph(data)\n        kwargs = G.graph\n        topo = \u62d3\u6251\u56fe(**kwargs)\n        topo.G = G\n        if not ies_env.FAILSAFE:\n            topo.check_consistency()\n        return topo\n    # with checking.\n    # iterate through all nodes.\n# \u4e0b\u9762\u7684\u90fd\u9700\u8981\u4f20\u62d3\u6251\u56fe\u8fdb\u6765\nclass \u8282\u70b9:\n    def __init__(self, topo:\u62d3\u6251\u56fe, **kwargs):\n        self.topo = topo\n        self.kwargs = kwargs\n        self.id = self.topo.add_node(**kwargs)\nclass \u6bcd\u7ebf(\u8282\u70b9):\n    def __init__(self, topo:\u62d3\u6251\u56fe, subtype:str, **kwargs):\n        super().__init__(topo, type=\"\u6bcd\u7ebf\", subtype=subtype ,conn = [],**kwargs)\n        # infinite ports.\nclass \u8bbe\u5907(\u8282\u70b9):\n    def __init__(self, topo:\u62d3\u6251\u56fe, device_type:str, port_definition, # iterable. \n    **kwargs):\n        # check if device type is one of the common types.\n        super().__init__(topo, type=\"\u8bbe\u5907\", subtype=device_type, ports={}, **kwargs)\n        self.ports = {}\n        for port_name, port_type in port_definition:"
        },
        {
            "comment": "This code adds a new node to the topology, representing a port connection. It assigns an ID to the node based on its type and port name. The newly added node's information is updated in the ports dictionary, and edges are created between the main node and this port node. Additionally, if either of the connected nodes are mother lines, the subtype of this new port node is appended to their list of connected types. Finally, a macro function is defined for creating instances of custom connection node classes.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/topo_check_v1.py.j2\":273-292",
            "content": "            port_node_id = self.topo.add_node(type=\"\u951a\u70b9\", port_name=port_name, subtype=port_type, device_id = self.id)\n            self.ports.update({port_name: {\"subtype\": port_type,\"id\":port_node_id}})\n            self.topo.G.add_edge(self.id, port_node_id)\n            {# logger_print(\"EDGE IDS:\", self.id, port_node_id)\n            breakpoint() #}\n        self.topo.G.nodes[self.id]['ports'] = self.ports\nclass \u8fde\u63a5\u8282\u70b9(\u8282\u70b9):\n    def __init__(self, topo:\u62d3\u6251\u56fe, _type:str, subtype:str, conn_start_id:int, conn_end_id:int, **kwargs):\n        super().__init__(topo, type=_type, subtype = subtype, **kwargs)\n        self.topo.G.add_edge(conn_start_id, self.id)\n        self.topo.G.add_edge(self.id, conn_end_id)\n        if self.topo.G.nodes[conn_start_id][\"type\"] == \"\u6bcd\u7ebf\":\n            self.topo.G.nodes[conn_start_id][\"conn\"].append(subtype)\n        if self.topo.G.nodes[conn_end_id][\"type\"] == \"\u6bcd\u7ebf\":\n            self.topo.G.nodes[conn_end_id][\"conn\"].append(subtype)\n{% macro makeConnNodeInstance(className) %}\nclass {{className}}(\u8fde\u63a5\u8282\u70b9):"
        },
        {
            "comment": "Code defines a class with the name \"microgrid_base/topo_check_v1.py\" and contains functions to create instances of connections, devices, and device interfaces using pre-defined templates or definitions. These instances are used to represent various components in a network topology. The code also includes a macro definition for creating device classes with specific port configurations.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/topo_check_v1.py.j2\":293-316",
            "content": "    def __init__(self, topo:\u62d3\u6251\u56fe, subtype:str, conn_start_id:int, conn_end_id:int, **kwargs):\n        super().__init__(topo, _type=\"{{className}}\", subtype = subtype, conn_start_id= conn_start_id, conn_end_id=conn_end_id, **kwargs)\n{% endmacro %}\n{{ makeConnNodeInstance(\"\u8fde\u63a5\u7ebf\") }}\n{{ makeConnNodeInstance(\"\u5408\u5e76\u7ebf\") }}\n{% macro makeDevice(device_name, port_definition) %}\nclass {{device_name}}(\u8bbe\u5907):\n    def __init__(self, topo:\u62d3\u6251\u56fe, **kwargs):\n        super().__init__(topo=topo, device_type=\"{{device_name}}\",  port_definition={{port_definition}}, **kwargs)\n        {% for port_name, port_type in port_definition %}\n        self.{{ port_name }} = self.ports[\"{{port_name}}\"]['id']\n        {% endfor %}\n{% endmacro %}\n{% for device_name, port_definition in \u8bbe\u5907\u63a5\u53e3\u96c6\u5408.items() %}\n{{makeDevice(device_name, port_definition)}}\n{% endfor %}"
        }
    ]
}