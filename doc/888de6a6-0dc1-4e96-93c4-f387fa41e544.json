{
    "summary": "This code sets up a soil heat pump model, defines variables for heat pump systems, and calculates coefficients. It develops a class with optimization methods and stores results in Tfav.",
    "details": [
        {
            "comment": "The code is initializing a class \"SoilSource\" that extends the IGES class and takes input parameters such as number of hours, model object, cooling/heating maximum/minimum values, set price, temperature range, length, and a set name. It also increments an index variable for each instance created. The code defines some attributes and variables for the class but does not fully define its methods or functionality.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/heatpump_code_reference/SoilSource_new.py\":0-49",
            "content": "# !/usr/bin/python3\nimport docplex\nfrom docplex.mp.model import Model\nimport pandas as pd\nimport numpy as np\nimport time\nimport os.path\nimport math\nimport random\n# import sys\nfrom docplex.mp.conflict_refiner import ConflictRefiner\nimport matplotlib.pyplot as plt\nfrom matplotlib import style\nfrom result_processlib import Value\nfrom plot_arr import IGESPlot\nfrom cpExample import IGES\nfrom IGES_Math import RRproduct\nfrom IGES_Math import RRSqure\nclass SoilSource(IGES):\n    index = 0\n    def __init__(\n        self,\n        num_h,\n        mdl: Model,\n        cool_max,\n        cool_min,\n        heat_max,\n        heat_min,\n        set_price,\n        Tmin,\n        Tmax,\n        Length,\n        set_name=\"SoilSource\",\n    ):\n        self.num_h = num_h\n        IGES(set_name)\n        SoilSource.index += 1\n        num_period = round(self.num_h / 120)\n        self.mdl = mdl\n        self.set_price = set_price\n        self.heat_max = heat_max\n        self.heat_min = heat_min\n        self.cool_max = cool_max\n        self.cool_min = cool_min\n        # self.dd = mdl.continuous_var(name='dd{0}'.format(SoilSource.index), lb=-1e3)"
        },
        {
            "comment": "This code initializes variables for a heat pump model, including temperature arrays (T), heat flow arrays (q), summed heat flow arrays (qln_sumf and qln_sumb), average temperature arrays (Tfav), average heat flow array (qav), continuous variable lists for heat output (pcool_out) and heat input (pheat_out), and two more continuous variables (nianhua and length).",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/heatpump_code_reference/SoilSource_new.py\":51-78",
            "content": "        self.T = np.zeros(self.num_h)\n        self.q = np.zeros(self.num_h)\n        self.qln_sumf = np.zeros(self.num_h)\n        self.qln_sumb = np.zeros(self.num_h)\n        self.Tfav = np.zeros(self.num_h)\n        self.Tfav_1 = np.zeros(self.num_h)\n        self.Tfav_2 = np.zeros(self.num_h)\n        self.qav = np.zeros(self.num_h)\n        self.pcool_out = self.mdl.continuous_var_list(\n            [i for i in range(0, self.num_h)],\n            name=\"SoilSource.pcool_out{0}\".format(SoilSource.index),\n            lb=-1e3,\n        )\n        self.pheat_out = self.mdl.continuous_var_list(\n            [i for i in range(0, self.num_h)],\n            name=\"SoilSource.tpheat{0}\".format(SoilSource.index),\n            lb=-1e3,\n        )\n        self.nianhua = self.mdl.continuous_var(\n            name=\"SoilSource_nianhua{0}\".format(SoilSource.index)\n        )\n        self.length = self.mdl.continuous_var(\n            name=\"SoilSourcelength{0}\".format(SoilSource.index)\n        )\n        self.nset = self.mdl.continuous_var(\n            name=\"SoilSource.nset{0}\".format(SoilSource.index)"
        },
        {
            "comment": "This code initializes variables for a soil heat pump model. It defines integer variables for each hour, calculates thermal properties, and sets values for various factors such as drill bit diameter, hole outer diameter, thermal conductivity of backfill material, and hole depth.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/heatpump_code_reference/SoilSource_new.py\":79-114",
            "content": "        )\n        self.zcool = self.mdl.integer_var_list(\n            [i for i in range(self.num_h)],\n            name=\"SoilSource.zcool{0}\".format(SoilSource.index),\n        )\n        self.zheat = self.mdl.integer_var_list(\n            [i for i in range(self.num_h)],\n            name=\"SoilSource.zheat{0}\".format(SoilSource.index),\n        )\n        self.Tff = 16\n        self.lamdas = 1.72\n        self.k = 1 / (4 * 3.1415926 * self.lamdas)\n        # \u5355U\n        self.pi = 3.1415926\n        self.db = 0.2\n        self.do = 0.032\n        # \u94bb\u5b54\u56de\u586b\u6750\u6599\u7684\u5bfc\u70ed\u7cfb\u6570\n        self.lamdab = 2\n        #\n        self.lamdap = 0.42\n        self.di = 0.026\n        self.D = 0.0064\n        self.lh = 3000\n        # shall be the translation of the formula\n        self.Rb = 0.5 * (\n            1\n            / (2 * self.pi * self.lamdab)\n            * (\n                np.log(self.db / self.do)\n                + np.log(self.db / self.D)\n                + (self.lamdab - self.lamdas)\n                / (self.lamdab + self.lamdas)\n                * np.log("
        },
        {
            "comment": "This code defines a class for a soil source component in a heat pump system. It calculates the heat exchange coefficients based on various parameters and adds constraints to a model object. The class also has methods to register the component in a model, read parameters from basic or topology files, and update the heat exchange rates based on flow temperature.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/heatpump_code_reference/SoilSource_new.py\":115-140",
            "content": "                    math.pow(self.db, 4) / (math.pow(self.db, 4) - math.pow(self.D, 4))\n                )\n            )\n            + 1 / (2 * self.pi * self.lamdap) * np.log(self.do / self.di)\n            + 1 / (self.pi * self.di * self.lh)\n        )\n        # \u589e\u52a0\u4ee5\u4e0b\u4ee3\u7801\n        self.Tmin = Tmin  # \u6d41\u4f53\u6700\u4f4e\u63a7\u5236\u6e29\u5ea6\uff0c\u4ece\u62d3\u6251\u53c2\u6570\u8bfb\u5165\n        self.Tmax = Tmax  # \u6d41\u4f53\u6700\u9ad8\u63a7\u5236\u6e29\u5ea6\uff0c\uff0c\u4ece\u62d3\u6251\u53c2\u6570\u8bfb\u5165\n        # self.Length = 120  # \u4ece\u57fa\u7840\u53c2\u6570\u8bfb\u5165\n        self.Length = Length\n        self.q_ex_heat = (self.Tff - self.Tmin) / self.Rb\n        self.q_ex_cool = (self.Tmax - self.Tff) / self.Rb\n    def cons_register(self, mdl:Model, loop_flag):\n        ####simple\n        bigM = 1e8\n        # mdl.add_constraint(self.nset >= 0)\n        # mdl.add_constraint(self.nset <= 1000)\n        mdl.add_constraint(self.nset * self.q_ex_heat <= self.heat_max)\n        mdl.add_constraint(self.nset * self.q_ex_heat >= self.heat_min)\n        mdl.add_constraint(self.nset * self.q_ex_cool <= self.cool_max)\n        mdl.add_constraint(self.nset * self.q_ex_cool >= self.cool_min)\n        # mdl.add_constraint(self.nset * 4 <= self.heat_max)"
        },
        {
            "comment": "Enforces balance between heating and cooling mode, adds constraints for maximum/minimum cooling and heating output, limits cooling output to 4 times the number of sets, ensures non-negative heat pump output, and limits heat output by the available heat source.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/heatpump_code_reference/SoilSource_new.py\":141-161",
            "content": "        # mdl.add_constraint(self.nset * 4 >= self.heat_min)\n        # mdl.add_constraint(self.nset * 6 <= self.cool_max)\n        # mdl.add_constraint(self.nset * 6 >= self.cool_min)\n        # force the balance inbetween heating and cooling mode, ensure this is doeable every year\n        if loop_flag == 1:\n            pcool_sum = mdl.sum(self.pcool_out)\n            pheat_sum = mdl.sum(self.pheat_out)\n            mdl.add_constraint(pcool_sum <= pheat_sum * 1.25)\n            mdl.add_constraint(pcool_sum >= pheat_sum * 0.8)\n        mdl.add_constraints(\n            self.pcool_out[h] <= 4 * self.nset for h in range(self.num_h)\n        )\n        mdl.add_constraints(self.pcool_out[h] >= 0 for h in range(self.num_h))\n        mdl.add_constraints(\n            self.pheat_out[h] <= 4 * self.nset for h in range(self.num_h)\n        )\n        mdl.add_constraints(self.pheat_out[h] >= 0 for h in range(self.num_h))\n        mdl.add_constraints(\n            self.pheat_out[h] <= self.zheat[h] * bigM for h in range(self.num_h)"
        },
        {
            "comment": "This code defines a class with methods for defining and solving optimization constraints related to a soil heat pump system. The Do_simulation method calculates temperature change based on the optimized values.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/heatpump_code_reference/SoilSource_new.py\":162-186",
            "content": "        )\n        mdl.add_constraints(\n            self.pcool_out[h] <= self.zcool[h] * bigM for h in range(self.num_h)\n        )\n        mdl.add_constraints(\n            self.zcool[h] + self.zheat[h] <= 1 for h in range(self.num_h)\n        )\n        # 30 for device lifetime (year), 120 for depth (meter) per subdevice\n        mdl.add_constraint(self.nianhua == self.length * self.set_price / 30)\n        mdl.add_constraint(self.length == self.nset * 120)\n    def Do_simulation(self, sol_run, periodh, consideer_history):\n        # calculate the temperature change\n        # this is not building model. this is calculating temperature change after optimization.\n        # q \u6b63\u503c\u4e3a\u5bf9\u5916\u5236\u51b7\u3002\u8d1f\u503c\u4e3a\u5bf9\u5916\u503c\u70ed\u3002\n        rrp = []\n        length = sol_run.get_value(self.length)\n        pcool_out = sol_run.get_values(self.pcool_out)\n        pheat_out = sol_run.get_values(self.pheat_out)\n        self.q = [\n            1000 * (pcool_out[index] - pheat_out[index]) / length\n            for index in range(self.num_h)\n        ]\n        print(\"do simulation\")"
        },
        {
            "comment": "The code calculates the average heating demand and temperature over a given period and stores it in the respective arrays. It also calculates the logarithmic sum of heating demand for forward and backward periods and assigns them to specific arrays based on a consideration flag.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/heatpump_code_reference/SoilSource_new.py\":188-214",
            "content": "        num_period = round(8760 / periodh)\n        for period in range(num_period):\n            self.qav[period] = (\n                sum(self.q[period * periodh : (period + 1) * periodh]) / periodh\n            )\n            # self.Tfav[period] = mdl.sum(self.T[(period) * 120:(period+1) * 120]) / 120\n        self.Tfav.resize((num_period, 1))\n        self.Tfav_1.resize((num_period, 1))\n        self.Tfav_2.resize((num_period, 1))\n        for period in range(num_period):\n            print(period)\n            self.qln_sumf[period] = sum(\n                self.qav[period + 1 - nindex] * np.log((nindex + 1) / (nindex))\n                for nindex in range(1, period + 1)\n            )\n            self.qln_sumb[period] = sum(\n                self.qav[period + 1 - nindex + num_period - 1]\n                * np.log((nindex + 1) / (nindex))\n                for nindex in range(period + 1, num_period)\n            )\n            if consideer_history == 1:\n                self.Tfav[period] = (\n                    self.k * (self.qln_sumf[period] + self.qln_sumb[period])"
        },
        {
            "comment": "Calculates average temperatures for heat pump system based on inputs, storing results in Tfav file.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/heatpump_code_reference/SoilSource_new.py\":215-234",
            "content": "                    + self.qav[period] * self.Rb\n                    + self.Tff\n                )\n                self.Tfav_1[period] = self.k * (\n                    self.qln_sumf[period] + +self.qln_sumb[period]\n                )\n            else:\n                self.Tfav[period] = (\n                    self.k * (self.qln_sumf[period])\n                    + self.qav[period] * self.Rb\n                    + self.Tff\n                )\n                self.Tfav_1[period] = self.k * (self.qln_sumf[period])\n            self.Tfav_2[period] = self.qav[period] * self.Rb\n        for h in range(self.num_h):\n            self.T[h] = self.Tfav[math.floor(h / periodh)]\n        # \u4fdd\u5b58\n        # Tfav\u6587\u4ef6"
        }
    ]
}