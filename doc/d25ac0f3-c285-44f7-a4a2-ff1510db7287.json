{
    "summary": "The code uses StrEnum to define energy sources, water types, and refrigerants. It includes mappings between these types and a function to flatten the lists of type members. The code also resolves basic types by iterating over an input list, checking for matches in the `\u7c7b\u578b\u7ec6\u5206\u8868`, adding corresponding types to a set, and recursively calling itself until all types are resolved.",
    "details": [
        {
            "comment": "This code defines various types of energy sources, water types, and refrigerants, using StrEnum class from the strenum module. It also includes mappings between these types and a function to flatten the lists of type members. The ErrorManager is used to check for duplicated keys while processing the mappings.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_def.py\":0-61",
            "content": "from log_utils import logger_print\n\"\"\"static & dynamic topology type checking\"\"\"\nfrom enum import auto\nfrom strenum import StrEnum\nclass \u57fa\u672c\u7c7b\u578b(StrEnum):\n    \u67f4\u6cb9 = auto()\n    \u5929\u7136\u6c14 = auto()\n    \u6c22\u6c14 = auto()\n    \u7535 = auto()\n    \u6c34 = auto()\n    \u84b8\u6c7d = auto()\n    \u70df\u6c14 = auto()\n    \u5bfc\u70ed\u6cb9 = auto()\n    \u4e59\u4e8c\u9187 = auto()\nclass \u6c34\u7c7b\u578b(StrEnum):\n    \u7ba1\u9053\u6c34 = auto()\n    \u81ea\u6765\u6c34 = auto()\nclass \u4e59\u4e8c\u9187\u7c7b\u578b(StrEnum):\n    \u51b7\u4e59\u4e8c\u9187 = auto()\n    \u70ed\u4e59\u4e8c\u9187 = auto()\n    \u51b0\u4e59\u4e8c\u9187 = auto()\nclass \u7ba1\u9053\u6c34\u7c7b\u578b(StrEnum):\n    \u70ed\u6c34 = auto()\n    \u51b7\u6c34 = auto()\n_mappings = {\n    \u57fa\u672c\u7c7b\u578b.\u6c34: \u6c34\u7c7b\u578b,\n    \u6c34\u7c7b\u578b.\u7ba1\u9053\u6c34: \u7ba1\u9053\u6c34\u7c7b\u578b,\n    \u57fa\u672c\u7c7b\u578b.\u4e59\u4e8c\u9187: \u4e59\u4e8c\u9187\u7c7b\u578b,\n}\n\u7c7b\u578b\u6cdb\u5316\u8868 = {}\ndef flatten_mappings(c, cs: list):\n    if isinstance(c, str):\n        cs.append(c)\n    elif issubclass(c, StrEnum):\n        cs.extend(list(c.__members__.values()))\n    else:\n        raise Exception(\"Unsupported type:\", type(c))\nfrom error_utils import ErrorManager\nwith ErrorManager(default_error=f\"Found duplicated keys while processing.\") as em:\n    for v, k in _mappings.items():\n        ks = []\n        vs = []\n        flatten_mappings(k, ks)\n        flatten_mappings(v, vs)"
        },
        {
            "comment": "The code defines a function `\u89e3\u6790\u57fa\u672c\u7c7b\u578b(t0)` to resolve basic types by iterating over the input list `t0`. It checks if the type is in the `\u7c7b\u578b\u7ec6\u5206\u8868`, and if so, adds its corresponding types to the `t_resolved` set. If not found in the table, it simply adds the type to the set. The function returns a resolved list of basic types when there are no more updates, otherwise recursively calls itself with the updated list until all types are resolved. The code also defines two dictionaries: `\u7c7b\u578b\u6cdb\u5316\u8868` and `\u7c7b\u578b\u7ec6\u5206\u8868`, which map generalized types to specific types and vice versa respectively.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_def.py\":62-99",
            "content": "        for k in ks:\n            for v in vs:\n                if k in \u7c7b\u578b\u6cdb\u5316\u8868.keys():\n                    em.append(f\"Duplicated: {k} -> {v} (Already have: {\u7c7b\u578b\u6cdb\u5316\u8868[k]})\")\n                else:\n                    \u7c7b\u578b\u6cdb\u5316\u8868[str(k)] = str(v)\n\u7c7b\u578b\u7ec6\u5206\u8868 = {}\nfor k, v in \u7c7b\u578b\u6cdb\u5316\u8868.items():\n    if v not in \u7c7b\u578b\u7ec6\u5206\u8868.keys():\n        \u7c7b\u578b\u7ec6\u5206\u8868[v] = set()\n    \u7c7b\u578b\u7ec6\u5206\u8868[v].add(k)\ndef \u89e3\u6790\u57fa\u672c\u7c7b\u578b(t0):\n    if isinstance(t0, str):\n        t = [t0]\n    else:\n        t = t0\n    t_resolved = set()\n    for _t in t:\n        # if _t in ['\u4e59', '\u9187', '\u4e8c']:\n        #     breakpoint()\n        if _t in \u7c7b\u578b\u7ec6\u5206\u8868.keys():\n            # logger_print('update:', _t)\n            t_resolved.update(\u7c7b\u578b\u7ec6\u5206\u8868[_t])\n        else:\n            # logger_print('add:', _t)\n            t_resolved.add(_t)\n    ret = list(t_resolved)\n    # logger_print('ret:', ret)\n    if t_resolved == set(t):\n        return ret\n    else:\n        # logger_print(\"t_resolved:\", t_resolved)\n        # if t_resolved == {'\u4e59', '\u9187', '\u4e8c'}: breakpoint()\n        # logger_print('rec ret:', ret)\n        return \u89e3\u6790\u57fa\u672c\u7c7b\u578b(ret)"
        }
    ]
}