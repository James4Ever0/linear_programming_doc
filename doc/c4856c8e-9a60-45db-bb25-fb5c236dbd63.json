{
    "summary": "This FastAPI application manages Celery tasks, handling task status updates and storing task information such as name, status, and execution time. It provides routes for creating and retrieving task status and continuously executes background tasks.",
    "details": [
        {
            "comment": "Code imports necessary modules and defines variables for storing task information. It creates a FastAPI instance, sets up a celery_on_message function to handle the task status updates from Celery, and prepares data structures to store task information like task name, status, and execution time. The code also includes import statements but does not include the definition of the \"add\" function or how it is used.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/celery_fastapi_test.py\":0-43",
            "content": "from datetime import datetime\nfrom fastapi import FastAPI, BackgroundTasks\n# do not import the function. import the celery app.\nfrom celery_test import app as celery_app\n# from celery_test import add, app as celery_app\nfrom celery.result import AsyncResult\nimport celery.states as S\nfrom typing import Dict\ntaskDict: Dict[str, AsyncResult] = {}\n# task_name = add.signature().name # working?\n# print(\"TASK NAME?\", task_name) # failed. man what is going on?\napp = FastAPI()\n# import logging\n# log = logging.getLogger(__name__)\n# do not use logging?\nimport datetime\nfrom typing import Any\ntaskInfo: Dict[str, Dict[str, datetime.datetime]] = {}\ntaskResult: Dict[str, Any] = {}\ndef celery_on_message(body: dict):\n    print(\"BODY TYPE?\", type(body))\n    print(\"ON MESSAGE?\", body)\n    task_id = body[\"task_id\"]\n    status = body[\"status\"]\n    if task_id not in taskInfo.keys():\n        taskInfo[task_id] = {}\n    if status not in taskInfo[task_id].keys():\n        taskInfo[task_id][status] = datetime.datetime.now()\n    ###\n    # BODY TYPE? <class 'dict'>"
        },
        {
            "comment": "The code defines a function `background_on_message` that retrieves a value from a Celery task asynchronously and prints the type and value. The task status is not checked within this function, but it can be obtained separately. The function also stores the result in the `taskResult` dictionary using the task ID as the key. The backend used by Celery must utilize both Redis and RabbitMQ, and tasks can be revoked if desired.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/celery_fastapi_test.py\":44-71",
            "content": "    # ON MESSAGE? {'status': 'STARTED', 'result': {'pid': 74297, 'hostname': 'celery@MacBook-Air-M1.local'}, 'traceback': None, 'children': [], 'date_done': None, 'task_id': 'c7a5a013-36aa-4242-842a-46fb3bb8e9fa'}\n    ###\n    # BODY TYPE? <class 'dict'>\n    # ON MESSAGE? {'status': 'SUCCESS', 'result': '14', 'traceback': None, 'children': [], 'date_done': '2023-03-28T09:26:50.382791', 'task_id': 'c7a5a013-36aa-4242-842a-46fb3bb8e9fa'}\ndef background_on_message(task: AsyncResult):\n    value = task.get(on_message=celery_on_message, propagate=False)\n    # shall you not check here.\n    # and not the message callback.\n    # status = task.status\n    # print(\"TASK STATUS?\", status)\n    taskResult[task.id] = value\n    print(\"VALUE TYPE?\", type(value))  # str, '14'\n    print(\"TASK VALUE?\", value)\n# can you check the task status, finished or not, unblockingly?\n# backend does not support on_message callback?\n# the celery backend must use both redis and rabbitmq.\n# also, revoke tasks, if wanted.\n# check the task creation time?"
        },
        {
            "comment": "Function add_get is creating a pending Celery task by sending the task to MAIN_NAME. The task is assigned an ID, and if it's not in exception states, its status is set as \"RECEIVED\".",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/celery_fastapi_test.py\":74-99",
            "content": "@app.get(\"/add/{a}/{b}\")\ndef add_get(a, b, background_task: BackgroundTasks):\n    # apparently it is not calling celery.\n    # val = add(a,b)\n    args = [a, b]\n    # print(\"\")\n    # never registered. use name instead?\n    from celery_test import MAIN_NAME\n    task_name = f\"{MAIN_NAME}.add\"\n    task: AsyncResult = celery_app.send_task(task_name, args=args)\n    # task:AsyncResult = add.apply_async(args=args)\n    print(\"PENDING CELERY TASK:\", task)  # this has the task id, but this is an object.\n    # print(\"TASK TYPE?\", type(task)) # <class 'celery.result.AsyncResult'>\n    print(\"TASK ID?\", type(task.id), task.id)  # autocompleted.\n    # task.id is of type \"str\"\n    if task.id:\n        background_task.add_task(background_on_message, task)\n        # return \"RECEIVED\"\n        taskDict.update({task.id: task})\n        task_status = task.status\n        if task_status not in S.EXCEPTION_STATES:\n            status = \"RECEIVED\"  # this is not the task status.\n        else:\n            print(\"TASK STATUS\", task_status)\n            status = \"EXCEPTION\""
        },
        {
            "comment": "This code appears to be a FastAPI application with several routes for interacting with tasks. The \"/task_status\" route retrieves the status of a given task ID, the \"/revoke\" route revokes a task by its ID, and the \"/task_result\" route returns the result and status of a task. The code also sets up an instance of a FastAPI app to run on 127.0.0.1:8010 using Uvicorn. Background tasks will continue executing even if interrupted.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/celery_fastapi_test.py\":100-138",
            "content": "    else:\n        print(\"TASK ID IS NONE.\")\n        status = \"ERROR\"\n    return {\"task_id\": task.id, \"status\": status, \"task_status\": task.status}\n@app.get(\"/task_status\")\ndef get_task_status(task_id: str):\n    task_status = \"MISSING\"\n    if task_id in taskDict.keys():\n        task_status = taskDict[task_id].status\n    print(\"CHECKING TASK:\", task_id)\n    print(\"TASK STATUS:\", task_status)\n    return task_status\n@app.get(\"/revoke\")\ndef revoke_task(task_id: str):\n    if task_id in taskDict.keys():\n        taskDict[task_id].revoke(terminate=True)\n    else:\n        return \"MISSING\"\n    print(\"TERMINATING TASK:\", task_id)\n    return \"REVOKED\"\n@app.get(\"/task_result\")\ndef get_task_result(task_id: str):\n    task_result = taskResult.get(task_id, None)\n    task_status = \"MISSING\"\n    if task_result:\n        task_status = taskDict[task_id].status\n    return dict(task_result=task_result, task_status=task_status)\nimport uvicorn\nuvicorn.run(app, host=\"127.0.0.1\", port=8010)\n# background tasks will be executed even if interrupted."
        }
    ]
}