{
    "summary": "The code uses PyGCKOpt to load data for a Capacitated Multiple-Depot Routing Problem instance, build an optimization model, apply presolve and decomposition, select and optimize the model.",
    "details": [
        {
            "comment": "This code is loading data for a Capacitated Multiple-Depot Routing Problem (CMDRP) instance. It defines a function to read the data from a JSON file or provide it directly, and then uses the PyGCKOpt library to build an optimization model. The CMDRP involves routing clusters of vehicles from multiple depots to deliver goods to locations while satisfying capacity constraints.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/visualize_decomposition_pygcgopt.py\":0-28",
            "content": "# ref: https://scipopt.github.io/PyGCGOpt/examples/cpmp/cpmp.html?highlight=visual\n# conda install --channel conda-forge -n cplex pygcgopt\nimport json\ndef get_simple_instance():\n    n = 5\n    p = 2\n    d = {0: {0: 0, 1: 25, 2: 46, 3: 43, 4: 30}, 1: {1: 0, 2: 22, 3: 20, 4: 22}, 2: {2: 0, 3: 22, 4: 40}, 3: {3: 0, 4: 22}, 4: {4: 0}}\n    q = {0: 14, 1: 13, 2: 9, 3: 15, 4: 6}\n    Q = {i: 33 for i in range(5)}\n    return n, p, d, q, Q\n# def read_instance_json(path):\n#     with open(path) as f:\n#         instance = json.load(f)\n#     d = {int(k): {int(kk): vv for kk, vv in v.items()} for k, v in instance[\"d\"].items()}\n#     q = {int(k): v for k, v in instance[\"q\"].items()}\n#     Q = {int(k): v for k, v in instance[\"Q\"].items()}\n#     return instance[\"n\"], instance[\"p\"], d, q, Q\n# n_locations, n_clusters, distances, demands, capacities = read_instance_json(\"instances/p550-01.json\")\nn_locations, n_clusters, distances, demands, capacities = get_simple_instance()\nfrom pygcgopt import Model, quicksum\ndef build_model(n_locations, n_clusters, distances, demands, capacities):"
        },
        {
            "comment": "Builds a CPLEX model with variables for assignment (x) and location selection (y). Adds assignment, capacity, and p-median constraints. Returns the model (m), assignment constraints (*conss_assignment), capacity constraints (*conss_capacity), and p-median constraint (cons_pmedian).",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/visualize_decomposition_pygcgopt.py\":29-66",
            "content": "    m = Model()\n    m.printVersion()\n    m.redirectOutput()\n    m.setMinimize()\n    x = {}\n    y = {}\n    for j in range(n_locations):\n        y[j] = m.addVar(f\"y_{j}\", vtype=\"B\")\n        for i in range(n_locations):\n            x[i, j] = m.addVar(f\"x_{i}_{j}\", vtype=\"B\", obj=distances[min(i,j)][max(i,j)])\n    # Hold different constraint types\n    conss_assignment = []\n    conss_capacity = []\n    cons_pmedian = None\n    # Create the assignment constraints\n    for i in range(n_locations):\n        conss_assignment.append(\n            m.addCons(quicksum(x[i, j] for j in range(n_locations)) == 1)\n        )\n    # Create the capacity constraints\n    for j in range(n_locations):\n        conss_capacity.append(\n            m.addCons(quicksum(demands[i] * x[i, j] for i in range(n_locations)) <= capacities[j] * y[j])\n        )\n    # Create the p-median constraint\n    cons_pmedian = m.addCons(quicksum(y[j] for j in range(n_locations)) == n_clusters)\n    return m, conss_assignment, conss_capacity, cons_pmedian\nm, *conss = build_model(n_locations, n_clusters, distances, demands, capacities)"
        },
        {
            "comment": "The code applies presolve and detection to the model 'm', lists decompositions, prints the number of finished decompositions, selects a specific decomposition, displays its scores, sets it as selected, and then optimizes the model.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/visualize_decomposition_pygcgopt.py\":67-87",
            "content": "m.presolve()\nm.detect()\ndecomps = m.listDecompositions()\nprint(\"GCG found {} finished decompositions.\".format(len(decomps)))\nprint(decomps)\nd = decomps[2]\nprint(\n    f\"Decomp scores: {d.classicScore:.04f}, {d.borderAreaScore:.04f}, {d.maxWhiteScore:.04f}, {d.maxForWhiteScore:.04f}\"\n    # f\"Decomp scores: {d.classicScore=:.04f}, {d.borderAreaScore=:.04f}, {d.maxWhiteScore=:.04f}, {d.maxForWhiteScore=:.04f}\"\n)\nd\nd.isSelected = True\nm.optimize()"
        }
    ]
}