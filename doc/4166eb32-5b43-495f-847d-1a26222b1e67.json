{
    "summary": "The code contains a class for exception handling, utility functions, and Prolog interaction. It retrieves query results from Prolog scripts, verifies topology status, and maps to adder status for energy types. If valid, it writes the status to a file using pickle dump.",
    "details": [
        {
            "comment": "The code defines an ErrorManager class to manage exceptions and errors, which can be used in `with` statements for automatic error management. The class takes arguments such as suppress_error and suppress_exception to control exception handling behavior. It has methods to add and check if there are any errors present.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/prolog_typesys_dynamic_verification.py\":0-37",
            "content": "######## ERROR UTILS START ########\nfrom typing import Union\nimport traceback\nimport sys\n# @beartype\nclass ErrorManager:\n    \"\"\"\n    Manage exceptions and errors.\n    Can be used in `with` statements to automate such management, which behavior can be configured by setting `suppress_error` and `suppress_exception` arguments.\n    Args:\n    suppress_error:bool: If suppressed, don't raise exception if having error messages\n    suppress_exception:bool: If suppressed, don't suppress exception raised by program\n    default_error:str: The default error message to display if any error occurs during execution\n    \"\"\"\n    def __init__(\n        self,\n        suppress_error: bool = False,\n        suppress_exception: bool = False,\n        default_error: Union[str, None] = None,\n    ):\n        self.errors = []\n        self.suppress_error = suppress_error\n        self.suppress_exception = suppress_exception\n        self.default_error = default_error\n    def __bool__(self):\n        return len(self.errors) > 0\n    @property\n    def has_error(self):"
        },
        {
            "comment": "This code defines a class that handles exception errors and provides methods for appending, clearing, and formatting them. It also includes methods for raising or printing exceptions if any exist. The `__enter__` and `__exit__` methods handle exception handling within the context of using this class as a context manager.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/prolog_typesys_dynamic_verification.py\":38-78",
            "content": "        return bool(self)\n    @property\n    def has_exception(self):\n        last_exc = sys.exc_info()\n        return last_exc[0] is not None\n    def append(self, error: str):\n        self.errors.append(error)\n    def clear(self):\n        self.errors = []\n        self.default_error = None\n    def format_error(self, clear=True, join: str = \"\\n\"):\n        error_msg = join.join(\n            self.errors\n            + ([self.default_error] if (self and self.default_error) else [])\n        )\n        if clear:\n            self.clear()\n        return error_msg\n    def raise_if_any(self):\n        if self.errors:\n            self.print_if_any()\n            raise Exception(self.format_error())\n    def print_if_any(self):\n        if self.errors:\n            print(self.format_error())\n            return True\n        return False\n    def __enter__(self):\n        self.raise_if_any()\n        return self\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if exc_type is None and not self.suppress_error:\n            self.raise_if_any()"
        },
        {
            "comment": "This code snippet contains various utility functions for error handling, directory changes, and working with Prolog. It includes a context manager for changing directories, Prolog server connection functions, and Pydantic models for representing errors in a structured way. The code also uses rich library for printing and frozendict for immutable dictionaries. The snippet ends with a banner function that centers a given title between dashes.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/prolog_typesys_dynamic_verification.py\":79-130",
            "content": "        else:\n            self.print_if_any()\n        if self.has_exception:\n            traceback_exc = traceback.format_exc()\n            print(traceback_exc)\n        return True if self.suppress_exception else None\n    def __str__(self):\n        return self.format_error(clear=False)\n    def __repr__(self):\n        return self.format_error(clear=False)\n    def __len__(self):\n        return len(self.errors)\n    def __iter__(self):\n        return iter(self.errors)\n######## ERROR UTILS END ########\n######## FAILSAFE UTILS START #####\nfrom contextlib import contextmanager\n@contextmanager\ndef chdir_context(dirpath: str):\n    cwd = os.getcwd()\n    os.chdir(dirpath)\n    try:\n        yield\n    finally:\n        os.chdir(cwd)\n######## FAILSAFE UTILS END #####\nfrom swiplserver import PrologMQI, PrologThread\nfrom pydantic import BaseModel\nfrom typing import List, Dict\n# from HashableDict.HashableDict import HashDict\nfrom frozendict import frozendict\nimport rich\nimport os\nimport tempfile\nbanner = lambda title: print(title.center(60, \"-\"))"
        },
        {
            "comment": "This code defines a function \"query_result_from_prolog\" that queries a Prolog script and returns the result as a topology status dictionary. The code creates a temporary directory, writes the Prolog script content to a file, and uses the \"PrologMQI\" class to interact with the Prolog interpreter in a separate thread. The \"construct_query_result_iterator\" function constructs an iterator for querying the result from the Prolog interpreter's thread.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/prolog_typesys_dynamic_verification.py\":133-156",
            "content": "def query_result_from_prolog(prolog_script_content: str, adder_index_to_port_name):\n    banner(\"querying\")\n    topology_status_dict = {}\n    with tempfile.TemporaryDirectory() as temp_dir:\n        with chdir_context(temp_dir):\n            prolog_file_path = \"prolog_script.pro\"\n            prolog_file_path_abs = os.path.join(prolog_file_path)\n            with open(prolog_file_path_abs, \"w+\") as f:\n                f.write(prolog_script_content)\n            with PrologMQI() as mqi:\n                with mqi.create_thread() as prolog_thread:\n                    topology_status_dict = query_prolog_in_context(\n                        topology_status_dict,\n                        prolog_file_path,\n                        prolog_thread,\n                        adder_index_to_port_name,\n                    )\n    return topology_status_dict\ndef construct_query_result_iterator(thread, query):\n    thread.query_async(query, find_all=False)\n    while True:\n        it = thread.query_async_result()\n        if it is not None:"
        },
        {
            "comment": "This function, \"query_prolog_in_context\", queries a Prolog program to get the status of multiple adder ports in a network topology. It constructs a query based on the list of adder names and iterates through the results to extract the status of each port. The statuses are then stored in the \"STATUS_LIST\" variable.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/prolog_typesys_dynamic_verification.py\":157-190",
            "content": "            yield it\n        else:\n            break\ndef query_prolog_in_context(\n    topology_status_dict, prolog_file_path, prolog_thread, adder_index_to_port_name\n):\n    adder_name_list = []\n    adder_index_mapping = {}\n    for i, k in enumerate(adder_index_to_port_name.keys()):\n        adder_name_list.append(\"adder{}\".format(str(k).replace('-','_')))\n        adder_index_mapping[i] = k\n    adder_names = \", \".join(adder_name_list)\n    print('adder_names: ',adder_names)\n    # breakpoint()\n    prolog_thread.query(f'[\"{prolog_file_path}\"].')\n    # result = prolog_thread.query(\n    #     f\"findall(STATUS, adder_port_status_list([{adder_names}], STATUS), STATUS_LIST)\"\n    # )\n    query = f\"adder_port_status_list([{adder_names}], STATUS)\"\n    _iterator = construct_query_result_iterator(prolog_thread, query)\n    STATUS_LIST = []\n    for result in _iterator:\n        STATUS = result[0][\"STATUS\"]\n        STATUS_LIST.append(STATUS)\n    # print('STATUS_LIST: ')\n    # rich.print(STATUS_LIST)\n    # breakpoint()\n    for simutaneous_status in STATUS_LIST:"
        },
        {
            "comment": "This code iterates over simutaneous_status and creates dictionaries for adder_energy_type and port_status. It then prints the adder information and port statuses. Finally, it adds a key-value pair to topology_status_dict if the key does not already exist, and adds the value to its corresponding set in the dictionary.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/prolog_typesys_dynamic_verification.py\":191-209",
            "content": "        adder_status_dict = {}\n        port_status_dict = {}\n        for _index, adder_simutaneous_status in enumerate(simutaneous_status):\n            adder_index = adder_index_mapping[_index]\n            adder_energy_type, adder_port_status = adder_simutaneous_status\n            adder_status_dict[adder_index] = adder_energy_type\n            print(f\"adder #{adder_index}\")\n            print(f\"\\tenergy type: {adder_energy_type}\")\n            print(f\"\\tport_status:\")\n            port_index_to_port_name = adder_index_to_port_name[adder_index]\n            for adder_port_index, port_status in enumerate(adder_port_status):\n                port_name = port_index_to_port_name[adder_port_index]\n                port_status_dict[port_name] = port_status\n                print(f\"\\t\\t{port_name}: {port_status}\")\n        key = frozendict(adder_status_dict)\n        value = frozendict(port_status_dict)\n        if key not in topology_status_dict.keys():\n            topology_status_dict[key] = set()\n        topology_status_dict[key].add(value)"
        },
        {
            "comment": "This function takes a topology status dictionary, port verifiers, conjugate port verifiers, and an index to port name mapping. It prints a banner for unverified topology status, then rich-prints the topology status dictionary. The function then proceeds to iterate through each topo status frame in the topology status dictionary and creates a topo status frame flatten dictionary, while checking if the port name is already in the topo status frame flatten keys.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/prolog_typesys_dynamic_verification.py\":210-247",
            "content": "        print(\"-\" * 60)\n    # print(topology_status_dict)\n    # breakpoint()\n    return topology_status_dict\ndef verify_topology_status_dict(\n    topology_status_dict,\n    port_verifiers,\n    conjugate_port_verifiers,\n    adder_index_to_port_name,\n):\n    banner(\"unverified topo status\")\n    rich.print(topology_status_dict)\n    banner(\"verifying\")\n    verified_topology_status_dict = {}\n    for topo_status_index, (adder_status, topo_status) in enumerate(\n        topology_status_dict.items()\n    ):\n        topo_status_frame_flatten = {}\n        port_verified = {}\n        conjugate_port_verified = {}\n        port_name_to_energy_type = {\n            v_v: adder_status[k]\n            for k, v in adder_index_to_port_name.items()\n            for v_k, v_v in v.items()\n        }\n        for topo_status_frames in topo_status:\n            for topo_status_frame_index, (port_name, port_status) in enumerate(\n                topo_status_frames.items()\n            ):\n                # breakpoint()\n                if port_name not in topo_status_frame_flatten.keys():"
        },
        {
            "comment": "This code is iterating over a list of conjugate ports and verifying their topo status frames. If the conjugate verification fails, it appends an error message using `ErrorManager`. It uses sets to store flattened topo_status_frames for each port. The `conjugate_verified` variable checks if the conjugate verification passed or failed.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/prolog_typesys_dynamic_verification.py\":248-264",
            "content": "                    topo_status_frame_flatten[port_name] = set()\n                _conjugate_verified = True\n                with ErrorManager(suppress_error=True) as em:\n                    for (\n                        conjugate_ports,\n                        conjugate_verifier,\n                    ) in conjugate_port_verifiers.items():\n                        conds = [\n                            topo_status_frames[port_name] for port_name in conjugate_ports\n                        ]\n                        energytypes = [port_name_to_energy_type[port_name] for port_name in conjugate_ports]\n                        conjugate_verified = conjugate_verifier(*conds, *energytypes)\n                        # conjugate_verified = conjugate_verifier(*conds)\n                        if not conjugate_verified:\n                            em.append(\n                                f\"conjugate verification failed for conjugate ports '{conjugate_ports}' at topo status frame #{topo_status_frame_index}\"\n                            )"
        },
        {
            "comment": "Code checks if topo status frame is skipped due to failed conjugate ports verification. It then iterates through each port, verifies its conditions using a verifier function, and marks the port as verified or not. If all ports are verified, it checks if all conjugate ports are also verified. Finally, it determines if the entire topology is valid based on all ports' and conjugate ports' verification statuses.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/prolog_typesys_dynamic_verification.py\":265-285",
            "content": "                            if _conjugate_verified:\n                                _conjugate_verified = False\n                if _conjugate_verified:\n                    topo_status_frame_flatten[port_name].add(port_status)\n                else:\n                    print(\n                        f\"skipping topo status frame #{topo_status_frame_index} due to failed conjugate ports verification\"\n                    )\n        for port_name, verifier in port_verifiers.items():\n            conds = topo_status_frame_flatten[port_name]\n            verified = verifier(conds)\n            port_verified[port_name] = verified\n            if not verified:\n                print(f\"verifier failed for port '{port_name}'\")\n        all_ports_verified = all(port_verified.values())\n        all_conjugate_ports_verified = all(conjugate_port_verified.values())\n        topo_verified = all_ports_verified and all_conjugate_ports_verified\n        if not all_ports_verified:\n            print(\"not all port vaildations have passed\")"
        },
        {
            "comment": "The code checks if all conjugate port validations have passed and if the topology verification failed for a specific topo status index. It processes topo status, skipping empty ones, and returns a dictionary with verified topology status. The function `isomorphicTopologyStatusCombinator` creates a dictionary of topology statuses and adder statuses.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/prolog_typesys_dynamic_verification.py\":287-309",
            "content": "        if not all_conjugate_ports_verified:\n            print(\"not all conjugate port vaildations have passed\")\n        if not topo_verified:\n            print(f\"topo verification failed for topo status #{topo_status_index}\")\n        else:\n            if len(topo_status) > 0:\n                verified_topology_status_dict[adder_status] = topo_status\n            else:\n                print(\"skipping due to empty topo status\")\n        banner(f\"processed topo status #{topo_status_index}\")\n    banner(\"verified topo status\")\n    rich.print(verified_topology_status_dict)\n    return verified_topology_status_dict\ndef isomorphicTopologyStatusCombinator(topology_status_dict: dict):\n    topo_status_to_adder_status_dict: Dict[frozenset, set] = {}\n    for adder_index_to_energy_type, topo_status in topology_status_dict.items():\n        topo_status_frozen = frozenset(topo_status)\n        if topo_status_frozen not in topo_status_to_adder_status_dict.keys():\n            topo_status_to_adder_status_dict[topo_status_frozen] = set()"
        },
        {
            "comment": "Creates a dictionary mapping topology status to adder status, then checks if the verified topology status can proceed by determining if there's only one adder energy type set in the topology.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/prolog_typesys_dynamic_verification.py\":310-339",
            "content": "        topo_status_to_adder_status_dict[topo_status_frozen].add(\n            adder_index_to_energy_type\n        )\n    return topo_status_to_adder_status_dict\ndef check_if_can_proceed(verified_topology_status_dict):\n    isomorphic_topo_status = None\n    possible_adder_energy_type_set_counts = len(verified_topology_status_dict)\n    print(\n        \"possible adder energy type set counts:\", possible_adder_energy_type_set_counts\n    )\n    isomorphic_topo_status = isomorphicTopologyStatusCombinator(\n        verified_topology_status_dict\n    )\n    banner(\"isomorphic topo status\")\n    rich.print(isomorphic_topo_status)\n    isomorphic_topo_status_counts = len(isomorphic_topo_status.keys())\n    print(\"isomorphic topo status counts:\", isomorphic_topo_status_counts)\n    can_proceed = False\n    if isomorphic_topo_status_counts == 0:\n        print(\"no adder energy type set\")\n    elif isomorphic_topo_status_counts > 1:\n        print(\"multiple adder energy type sets found\")\n    else:\n        can_proceed = True\n    if not can_proceed:"
        },
        {
            "comment": "The code reads a Prolog script, checks the topology status by querying and verifying, then determines if it can proceed. If not, \"cannot proceed\" is printed; otherwise, \"clear to proceed\" is printed before returning the results of verification and whether to proceed. The function executes in the context of the main block with specific parameters.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/prolog_typesys_dynamic_verification.py\":340-375",
            "content": "        print(\"cannot proceed\")\n    else:\n        print(\"clear to proceed\")\n    return can_proceed, isomorphic_topo_status\ndef execute_prolog_script_and_check_if_can_proceed(\n    prolog_script_content,\n    adder_index_to_port_name,\n    port_verifiers,\n    conjugate_port_verifiers,\n):\n    topology_status_dict = query_result_from_prolog(\n        prolog_script_content, adder_index_to_port_name\n    )\n    verified_topology_status_dict = verify_topology_status_dict(\n        topology_status_dict,\n        port_verifiers,\n        conjugate_port_verifiers,\n        adder_index_to_port_name,\n    )\n    can_proceed, isomorphic_topo_status = check_if_can_proceed(verified_topology_status_dict)\n    return can_proceed, isomorphic_topo_status\nif __name__ == \"__main__\":\n    with open(\"prolog_gen.pro\", \"r\") as f:\n        prolog_script_content = f.read()\n    adder_index_to_port_name = {\n        1: {0: \"bat_port1\", 1: \"generator_port1\", 2: \"load_port1\"}\n    }\n    port_verifiers = {\n        \"bat_port1\": lambda conds: \"input\" in conds,\n        \"load_port1\": lambda conds: \"input\" in conds,"
        },
        {
            "comment": "The code defines conjugate_port_verifiers dictionary and checks if it can proceed with the Prolog script execution. If it can proceed, it writes isomorphic_topo_status to \"isomorphic_topo_status.pkl\" file using pickle dump.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/prolog_typesys_dynamic_verification.py\":376-393",
            "content": "    }\n    # {tuple_of_port_names: lambda cond1, cond2, etype1, etype2: ...}\n    conjugate_port_verifiers = {}\n    can_proceed, isomorphic_topo_status = execute_prolog_script_and_check_if_can_proceed(\n        prolog_script_content,\n        adder_index_to_port_name,\n        port_verifiers,\n        conjugate_port_verifiers,\n    )\n    output_fpath = \"isomorphic_topo_status.pkl\"\n    if can_proceed:\n        print('write data to:', output_fpath)\n        import pickle\n        with open(output_fpath, 'wb') as f:\n            pickle.dump(isomorphic_topo_status, f)"
        }
    ]
}