{
    "summary": "The code imports modules and defines functions for Jinja templating, type hint removal, string camelization, and error handling. It performs error checks for Pyright, handles exceptions, uses Jinja2 functions and variables, ensures valid template paths, and injects functions into templates.",
    "details": [
        {
            "comment": "This code imports necessary modules and defines two functions for type hint removal and string camelization. It also sets up variables based on environment settings and handles a potential issue with triple quote strings. The code imports humps module to handle case conversions, uses ast library for parsing and modifying function definitions, and utilizes os and subprocess modules for execution.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/jinja_utils.py\":0-43",
            "content": "from log_utils import logger_print\nimport subprocess\nfrom tempfile import TemporaryDirectory\n# from humps import kebabize\nimport jinja2\nimport shutil\nimport os\nif not os.environ.get(\"NO_PYTHON_TYPECHECK\", None) == \"True\":\n    import black\n    import pyright_utils  # for checking if really installed.\nelse:\n    pyright_utils = object()\nimport re\n# live share's triple quote issue isn't fixed.\nimport humps  # default to snake case!\nimport ast\ndef remove_typehint(paramDef: str) -> str:\n    tree_def = ast.parse(\"def func({}): ...\".format(paramDef)).body[0]\n    args = []\n    for elem in ast.walk(tree_def):\n        if isinstance(elem, ast.arg):\n            argName = elem.arg  # str\n            args.append(argName)\n    return \",\".join([f\"{argName}={argName}\" for argName in args])\ndef camelize_with_space(string):\n    return humps.camelize(string.replace(\" \", \"-\"))\n# ref: https://www.geeksforgeeks.org/python-program-to-convert-camel-case-string-to-snake-case/\ndef c2s(_str):\n    \"\"\"\n    Camel case to snake case.\n    \"\"\"\n    # return humps.kebabize(_str).replace(\"-\", \"_\")"
        },
        {
            "comment": "The code contains several functions for converting between different case styles. The 'jinja_utils' module provides methods for converting Snake case to camel case (s2c), snake case to camel case with a lowercase start letter (s2cl), and snake case to camel case with an uppercase start letter (s2cu). It also includes a class 'NeverUndefined' that extends 'jinja2.StrictUndefined' for error handling in Jinja templates.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/jinja_utils.py\":44-86",
            "content": "    # res = [_str[0].lower()]\n    # for c in _str[1:]:\n    #     if c in (\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"):\n    #         res.append(\"_\")\n    #         res.append(c.lower())\n    #     else:\n    #         res.append(c)\n    # return \"\".join(res)\n    return humps.decamelize(_str)\ndef s2c(_str, lower: bool):\n    \"\"\"\n    Snake case to camel case.\n    \"\"\"\n    # assert not _str.startswith(\"_\")\n    # lst = _str.split(\"_\")\n    # first_letter = lst[0][0]\n    # lst[0] = (first_letter.lower() if lower else first_letter.upper()) + lst[0][1:]\n    # for i in range(1, len(lst)):\n    #     lst[i] = lst[i].title()\n    # return \"\".join(lst)\n    return getattr(humps, \"camelize\" if lower else \"pascalize\")(_str)\ndef s2cl(_str):\n    \"\"\"\n    Snake case to camel case (starting with lower letter).\n    \"\"\"\n    return s2c(_str, True)\ndef s2cu(_str):\n    \"\"\"\n    Snake case to camel case (starting with upper letter).\n    \"\"\"\n    return s2c(_str, False)\nclass NeverUndefined(jinja2.StrictUndefined):\n    def __init__(self, *args, **kwargs):\n        # ARGS: (\"parameter 'myvar2' was not provided\",)"
        },
        {
            "comment": "This function defines a template loading and rendering method that also formats the result. If an undefined variable is present in the parameters, it raises an exception. The code then extracts parts of the output path to create a backup file name, checks if the output file exists and reads its contents for backup purposes, and writes the rendered result to a temporary file named by appending 'new' at the end of the output path.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/jinja_utils.py\":87-123",
            "content": "        # KWARGS: {'name': 'myvar2'}\n        if len(args) == 1:\n            info = args[0]\n        elif \"name\" in kwargs.keys():\n            info = f\"Undefined variable '{kwargs['name']}\"\n        else:\n            infoList = [\"Not allowing any undefined variable.\"]\n            infoList.append(f\"ARGS: {args}\")\n            infoList.append(f\"KWARGS: {kwargs}\")\n            info = \"\\n\".join(infoList)\n        raise Exception(info)\ndef load_render_and_format(\n    template_path: str,\n    output_path: str,\n    render_params: dict,\n    banner: str,\n    needFormat: bool = True,\n):\n    tpl = load_template(template_path)\n    result = tpl.render(**render_params)\n    logger_print()\n    logger_print(\"______________________[{}]\".format(banner))\n    logger_print(result)\n    # import black.Mode\n    output_path_elems = output_path.split(\".\")\n    output_path_elems.insert(-1, \"new\")\n    if os.path.exists(output_path):\n        with open(output_path, \"r\") as f:\n            backup_content = f.read()\n    else:\n        backup_content = \"\"\n    with open(tmp_output_path := \".\".join(output_path_elems), \"w+\") as f:"
        },
        {
            "comment": "Writes formatted result to file, checks if formatting is needed, moves the temporary file to output path, returns early if no formatting was done. Attempts to format the result with black and checks for undefined variables before rewriting the source file. Uses a temporary directory and writes the result into it. Uses pyright_utils to run type checking on the written file.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/jinja_utils.py\":124-150",
            "content": "        f.write(result)\n    if not needFormat:\n        shutil.move(tmp_output_path, output_path)\n        return\n    try:\n        # TODO: add more test, like checking for undefined variables, before rewriting the source file.\n        # TODO: add rollback mechanism in makefile\n        result = black.format_str(result, mode=black.Mode())\n        logger_print(\"Formatter Ok.\")\n        # with TemporaryDirectory() as TP:\n        with open(output_path, \"w+\") as f:\n            f.write(result)\n        # do further type checking.\n        # typechecker_input_path = os.path.join(\n        #     TP, base_output_path := os.path.basename(output_path)\n        # )\n        # with open(typechecker_input_path, \"w+\") as f:\n        #     f.write(typechecker_input_path)\n        # output = subprocess.run(\n        #     [\"pyright\", typechecker_input_path],\n        #     capture_output=True,\n        #     encoding=\"utf-8\",\n        # )\n        run_result = pyright_utils.run(\n            output_path, capture_output=True, encoding=\"utf-8\"\n        )"
        },
        {
            "comment": "The code checks for type errors using Pyright and outputs the error messages. If any Pyright errors are found, an exception is raised with the error messages. If stderr contains content, it appends a new line with \"Pyright error: {stderr content}\" to the error list. After processing, if typeErrors is not empty, it inserts a message with the output path and joins all error messages in a formatted string. It also removes a temporary file and writes backup_content to the original output_path if any exceptions occur. The code may be using os.utime() to update the last access and modification times of the output_path without altering its content.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/jinja_utils.py\":151-178",
            "content": "        typeErrors = [\n            e.strip().replace(\n                os.path.basename(output_path), os.path.basename(tmp_output_path)\n            )\n            for e in re.findall(\n                pyright_utils.errorRegex, run_result.stdout, re.MULTILINE\n            )\n        ]\n        # breakpoint()\n        if run_result.stderr:\n            typeErrors.append(\"\")\n            typeErrors.append(f\"Pyright error:\\n{run_result.stderr}\")\n        if typeErrors:\n            typeErrors.insert(0, f\"Type error found in file {repr(output_path)}\")\n            raise Exception(f\"\\n{' '*4}\".join(typeErrors))\n        logger_print(\"Pyright Ok.\")\n        os.remove(tmp_output_path)\n    except:\n        import traceback\n        traceback.print_exc()\n        # os.remove(tmp_output_path)\n        with open(output_path, \"w+\") as f:\n            f.write(backup_content)\n        # ref: https://www.geeksforgeeks.org/python-os-utime-method/\n        # do not set this to 0 or something. will cause error.\n        os.utime(\n            output_path,"
        },
        {
            "comment": "This code appears to contain functions and variables related to Jinja2 templating engine. The \"lstrip\" function strips leading whitespace from each line in a string, while the \"code_and_template_path\" function returns paths for code and template files with .j2 extension. Jinja2TemplateArguments dictionary defines options for Jinja2 templates, including extensions and trim/lstrip settings. There is an error check that raises an Exception if certain conditions are not met, possibly related to timestamps of the template file versus other files.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/jinja_utils.py\":179-216",
            "content": "            times=(\n                os.path.getatime(template_path) - 1000000,\n                os.path.getmtime(template_path) - 1000000,\n            ),\n        )  # to make this older than template, must update!\n        raise Exception(\n            f\"Code check failed.\\nTemporary cache saved to: '{tmp_output_path}'\"\n        )\n    logger_print(\"=\" * 40)\ndef lstrip(string: str):\n    lines = string.split(\"\\n\")\n    result_lines = []\n    for line in lines:\n        result_lines.append(line.lstrip())\n        # if stripped_line := line.lstrip():\n        # result_lines.append(stripped_line)\n    result = \"\\n\".join(result_lines).strip(\"\\n\")\n    return result\ndef code_and_template_path(base_name):\n    code_path = f\"{base_name}.py\"\n    template_path = f\"{code_path}.j2\"\n    return code_path, template_path\njinja2_template_arguments = dict(\n    extensions=[\n        \"jinja2_error.ErrorExtension\",\n        \"jinja2.ext.do\",\n        \"jinja2.ext.loopcontrols\",\n    ],\n    trim_blocks=True,\n    lstrip_blocks=True,\n    # undefined=jinja2.StrictUndefined,"
        },
        {
            "comment": "This code defines a function make_jinja2_func_dict() that creates a dictionary of Jinja2 functions and optional extra functions. The inject_template_globals() function takes a Jinja2 Template object and a func_dict, updates the template's globals with the combined dictionary of Jinja2 and extra functions, and returns the updated template. The load_template_text() function creates a new Jinja2 Template from a text string, injects extra functions into it using inject_template_globals(), and returns the modified template. Finally, the load_template() function loads a template file path, injects extra functions, and returns the modified template.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/jinja_utils.py\":217-265",
            "content": "    undefined=NeverUndefined,\n)\njinja2_func_dict = dict(\n    list=list,\n    str=str,\n    _dict=dict,\n    _set=set,  # avoid name collision\n    tuple=tuple,\n    ord=ord,\n    len=len,\n    repr=repr,\n    c2s=c2s,\n    # s2c=s2c,\n    s2cl=s2cl,\n    s2cu=s2cu,\n    zip=zip,\n    cws=camelize_with_space,\n    lstrip=lstrip,\n    remove_typehint=remove_typehint,\n    kebabize=humps.kebabize,\n    pascalize=humps.pascalize,\n    # enumerate=enumerate,\n    # eval=eval,\n    # join=myJoin\n)\ndef make_jinja2_func_dict(extra_func_dict={}):\n    func_dict = dict(**jinja2_func_dict, **extra_func_dict)\n    return func_dict\nfrom jinja2 import Template\ndef inject_template_globals(template: Template, func_dict: dict) -> Template:\n    func_dict = make_jinja2_func_dict(func_dict)\n    template.globals.update(func_dict)\n    return template\ndef load_template_text(template_text: str, extra_func_dict={}):\n    tpl = Template(template_text, **jinja2_template_arguments)\n    inject_template_globals(tpl, extra_func_dict)\n    return tpl\ndef load_template(template_path: str, extra_func_dict={}):"
        },
        {
            "comment": "Code tries to load Jinja2 template from a given path, throws exception if the template path is malformed, and then returns the loaded template after injecting global variables. The test function runs a subprocess with provided command list and checks its return code.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/jinja_utils.py\":266-282",
            "content": "    try:\n        assert template_path.endswith(\".j2\")\n    except:\n        Exception(f\"jinja template path '{template_path}' is malformed.\")\n    env = jinja2.Environment(\n        loader=jinja2.FileSystemLoader(searchpath=[\"./\", \"../\"]),\n        **jinja2_template_arguments,\n    )\n    tpl = env.get_template(template_path)\n    inject_template_globals(tpl, extra_func_dict)\n    return tpl\ndef test(cmd: list, exec=\"python3\" if os.name != \"nt\" else \"python\"):\n    cmd = [exec] + cmd\n    p = subprocess.run(cmd)\n    p.check_returncode()"
        }
    ]
}