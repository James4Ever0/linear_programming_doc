{
    "summary": "This code uses CPLEX solver to solve linear programming models and identifies problematic variables using `decomposeExpression`, solving models twice with/without objective functions while manipulating optimization parameters.",
    "details": [
        {
            "comment": "This code solves a linear programming model with unbounded objective, which could indicate potential infinite rays. It sets bounds on the objective expression and uses CPLEX solver to solve the model without an objective. The code also writes the LP file (no_bound.lp) for further analysis.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/check_unbounded_model.py\":0-39",
            "content": "# ref: https://yalmip.github.io/debuggingunbounded\n# solve the model without objective?\n# add bounds to objective expression\n# note that won't indicate all infinite rays\n# you spot one, you fix one.\nMAX_BOUND = 1e8\n# pyomo can utilize any solver without version specific libraries.\nfrom pyomo.environ import *\n# that is during presolve, not during solve.\n# from pyomo.contrib.iis import write_iis\nmodel = ConcreteModel()\nx = model.\u53d8\u91cfx = Var()\ny = model.\u53d8\u91cfy = Var()\nmodel.constraint_x_y = Constraint(expr=x + y >= 10)\nz = model.z = Var([0, 1])\nx.setlb(-10)\nx.setub(10)\nobj_expr = 2 * x - 5 + y + z[0] + z[1] + 3 * (z[0] + y) + 10\nobj = model.obj = Objective(expr=obj_expr, sense=minimize)\nmodel.write(filename=\"no_bound.lp\")\n# warning: shall not be NaN\n# from cmath import nan\n# no_obj = model.no_obj = Objective(expr=nan, sense=minimize) # treated as 0\nno_obj = model.no_obj = Objective(expr=0)\n# write_iis(model, \"no_bound.ilp\", \"cplex\")\n# no conflict! how comes? it is unbounded.\nsolver = SolverFactory(\"cplex\")\n# switch lp algorithm"
        },
        {
            "comment": "This code is manipulating the optimization parameters and solving the model twice - once without an objective function and once with a bounded objective function. The solver options include setting the method, time limit, conflict display, feasibility tolerance, and optimality tolerance. It also activates and deactivates the objective functions in the model.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/check_unbounded_model.py\":40-70",
            "content": "# ref: https://www.ibm.com/docs/en/icos/20.1.0?topic=parameters-algorithm-continuous-linear-problems\"\n# working?\n# solver.options['lpmethod'] = 1  # 0(automatic)-6(concurrent)\nsolver.options[\"timelimit\"] = 15\nsolver.options[\"conflict display\"] = 2  # detailed display\n# not working.\n# solver.options['feasopt tolerance'] = 100 # seems not working.\n# solver.options['feasopt mode'] = 5 # 0(default)-5\n# cannot be too big.\n# solver.options['simplex tolerances optimality'] = 1e-1\nsmap_ids = []\nmodel.obj.deactivate()\nresult_no_obj = solver.solve(model, tee=True, logfile=\"no_obj_solver.log\")\nsmap_ids.append(solver._smap_id)\nprint(f\"X={value(x)}, Y={value(y)}\")\nprint()\nprint(\"=\" * 70)\nmodel.no_obj.deactivate()\nmodel.obj.activate()\n# model.bound_obj.deactivate()\nresult_unbound = solver.solve(model, tee=True, logfile=\"unbound_solver.log\")\nsmap_ids.append(solver._smap_id)\nprint()\nprint(\"=\" * 70)\n# no need to create new objective. just limit the objective expression to bounds.\nmodel.debug_obj_lb_constraint = Constraint(expr=obj_expr >= -MAX_BOUND)"
        },
        {
            "comment": "The code snippet checks if the CPLEX solver is terminating abnormally due to unbounded or infeasible models. It creates a constraint and objective for a bounding model, solves it, prints the termination conditions, and then proceeds to analyze the expression tree of the model to identify any problematic variables causing issues.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/check_unbounded_model.py\":71-103",
            "content": "model.debug_obj_ub_constraint = Constraint(expr=obj_expr <= MAX_BOUND)\n# mobjVar = model.mobjVar = Var()\n# mobjVar.setub(MAX_BOUND)\n# mobjVar.setlb(-MAX_BOUND)\n# model.constraint_bound_obj = Constraint(expr=mobjVar == obj_expr)\n# bound_obj = model.bound_obj = Objective(expr=mobjVar, sense=minimize)\n# model.obj.deactivate()\n# model.bound_obj.activate()\nresult_bound = solver.solve(model, tee=True, logfile=\"bound_solver.log\")\nsmap_ids.append(solver._smap_id)\n# you still need to set time limit options over this.\nprint(\"UNBOUND TERMINATION CONDITION:\", result_unbound.solver.termination_condition)\nprint(\"BOUND TERMINATION CONDITION:\", result_bound.solver.termination_condition)\n# now analyze what variable is doing havoc to the model.\nfrom pyomo.core.expr import current as EXPR\n# class ExpressionDecomposer(EXPR.SimpleExpressionVisitor):\n#     def __init__(self):\n#         # self.counter = 0\n#         self.varmap = {}\n#     def visit(self, node):\n#         # self.counter += 1\n#         print(node)\n#         print(type(node))"
        },
        {
            "comment": "This code defines a function `decomposeExpression` that takes an expression as input and returns its decomposition into constant, variables, and their coefficients. It uses the `TypedDict` class to define the expected structure of the returned decomposition result in a dictionary format. The function first initializes variables for storing the constant, variable names, and their coefficients. Then, it decomposes the expression using the `decompose_term` function from the `EXPR` module. If the expression is linear, it iterates over its terms and updates the constant and variable dictionaries accordingly.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/check_unbounded_model.py\":104-143",
            "content": "#         # breakpoint()\n#         print(\"_____\")\n#     def finalize(self):\n#         return self.varmap\n# def decomposeExpression(expr):\n#     #\n#     # Create the visitor object\n#     #\n#     visitor = ExpressionDecomposer()\n#     #\n#     # Compute the varmap using the :func:`xbfs` search method.\n#     #\n#     varmap = visitor.xbfs(expr)\n#     return varmap\nfrom typing import TypedDict, Dict\nclass DecomposedExpression(TypedDict):\n    constant: float\n    varNameToVarObject: Dict[str, str]\n    varNameToVarCoefficient: Dict[str, float]\ndef decomposeExpression(expr):\n    const = 0\n    varNameToVarObject = {}\n    varNameToVarCoefficient = {}\n    is_linear, terms = EXPR.decompose_term(expr)\n    if is_linear:\n        for coef, var in terms:\n            if var is None:\n                const += coef\n            else:\n                varName = str(var)\n                varNameToVarObject[varName] = var\n                varNameToVarCoefficient[varName] = (\n                    varNameToVarCoefficient.get(varName, 0) + coef\n                )"
        },
        {
            "comment": "This code defines a function to decompose an expression, retrieve variable values, sort and display them. It also includes functions for converting value dictionaries to lists and sorting and displaying variable values in a specified order. The code then decomposes the given expression, retrieves variable values, and sorts/displays them if the decomposition is successful.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/check_unbounded_model.py\":144-178",
            "content": "        return DecomposedExpression(\n            constant=const,\n            varNameToVarObject=varNameToVarObject,\n            varNameToVarCoefficient=varNameToVarCoefficient,\n        )\nfrom typing import List, Tuple\ndef getValueListFromValueDict(valueDict: Dict[str, float]):\n    valueList = list(valueDict.items())\n    return valueList\ndef sortAndDisplayVarValues(\n    valueList: List[Tuple[str, float]], banner: str, head_count=10, reverse=False\n):\n    print(banner.center(70, \"=\"))  # to be commented out\n    valueList.sort(key=lambda x: x[1], reverse=reverse)\n    head_count = min(len(valueList), head_count)\n    message = [f\"reversed: {reverse}\", \"\"]\n    for i in range(head_count):\n        message.append(\"%s\\t%s\" % valueList[i])\n    output = \"\\n\".join(message)\n    print(output)\ndecomposedResult = decomposeExpression(obj_expr)\nif decomposedResult:\n    print(decomposedResult)\n    varNameToVarValue = {}\n    varNameToTermValue = {}\n    for varName, varObj in decomposedResult[\"varNameToVarObject\"].items():\n        varValue = value(varObj)"
        },
        {
            "comment": "This code calculates the coefficient of a variable, multiplies it by the current variable value, and stores both in dictionaries. It then sorts and displays the variable-value pairs in descending order for varNameToVarValue and varNameToTermValue dictionaries before printing the objective function's value.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/check_unbounded_model.py\":179-200",
            "content": "        coef = decomposedResult[\"varNameToVarCoefficient\"][\n            varName\n        ]  # seems to be no typeddict type checking in pyright\n        termValue = coef * varValue\n        varNameToVarValue[varName] = varValue\n        varNameToTermValue[varName] = termValue\n    # sort and display\n    valueListOfVarNameToVarValue = getValueListFromValueDict(varNameToVarValue)\n    valueListOfVarNameToTermValue = getValueListFromValueDict(varNameToTermValue)\n    BANNER_VARNAME_TO_VAR_VALUE = \"VAR NAME TO VAR VALUE\"\n    BANNER_VARNAME_TO_TERM_VALUE = \"VAR NAME TO TERM VALUE\"\n    sortAndDisplayVarValues(valueListOfVarNameToVarValue, BANNER_VARNAME_TO_VAR_VALUE)\n    sortAndDisplayVarValues(\n        valueListOfVarNameToVarValue, BANNER_VARNAME_TO_VAR_VALUE, reverse=True\n    )\n    sortAndDisplayVarValues(valueListOfVarNameToTermValue, BANNER_VARNAME_TO_TERM_VALUE)\n    sortAndDisplayVarValues(\n        valueListOfVarNameToTermValue, BANNER_VARNAME_TO_TERM_VALUE, reverse=True\n    )\n    print()\n    obj_val = value(obj_expr)"
        },
        {
            "comment": "The code checks the objective value, constant objective value and prints them. If the objective expression is non-linear, it prints a message. Finally, it selects the most recent solver SMAP ID to translate the log and exported model.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/check_unbounded_model.py\":201-209",
            "content": "    obj_const = decomposedResult[\"constant\"]\n    print(\"(OBJ - OBJ_CONST)?\", obj_val - obj_const)\n    print(\"OBJ?\", obj_val)\n    print(\"OBJ_CONST?\", obj_const)\nelse:\n    print(\"objective expression is non-linear.\")\nprint(\"solver smap ids:\", smap_ids)  # three unique ids.\n# pick up the most recent one to translate the log and exported model (lp format)."
        }
    ]
}