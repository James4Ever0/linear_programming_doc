{
    "summary": "The code initializes a model, sets timezone, prints current time, adds constraints, defines objective function, handles solver options and exceptions, logs results, possibly switches LP algorithm. It provides functions for diagnostics, solution iteration, and expression decomposition, checking model solutions and calculating variable values, while identifying linearity of the objective expression and translating logs and models in lp format.",
    "details": [
        {
            "comment": "This code defines a function getModelSolution that retrieves the solution of an active ConcreteModel and returns it as a dictionary. The variable MAX_BOUND is set to 1e8, and the function model_write writes the model in both lp and nl formats. The function checkIfSolved checks if the solution after solving is null and sets has_solution to False in that case.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/alternative_solver.py\":0-43",
            "content": "# ref: https://yalmip.github.io/debuggingunbounded\n# solve the model without objective?\n# add bounds to objective expression\n# note that won't indicate all infinite rays\n# you spot one, you fix one.\nMAX_BOUND = 1e8\n# pyomo can utilize any solver without version specific libraries.\nfrom pyomo.environ import *\nimport os\nfrom contextlib import contextmanager\nimport weakref\ndef getModelSolution(model: ConcreteModel):\n    solution = {}\n    for v in model.component_data_objects(ctype=Var, active=True, descend_into=True):\n        varName = v.name\n        val = value(v, exception=None)\n        if val is not None:\n            solution[varName] = val\n        else:\n            return None\n    return solution\nNULL_SOLUTIONS = [None, {}]\nis_null_solution = lambda sol: sol in NULL_SOLUTIONS\ndef model_write(model: ConcreteModel, name):\n    # for fmt in 'lp', 'nl':\n    for fmt in [\"lp\", \"nl\"]:\n        model.write(filename=f\"{name}.{fmt}\")\ndef checkIfSolved(sol_before, sol_after):\n    if is_null_solution(sol_after):\n        has_solution = False"
        },
        {
            "comment": "This code defines a context manager for monitoring and checking the changes in the solution of an optimization model. The ModelSolutionChecker class initializes with the model writer function, stores the previous solution, and updates it when requested. It provides methods to check if there is a new solution and whether there's a difference between the old and new solutions.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/alternative_solver.py\":44-80",
            "content": "    else:\n        has_solution = True\n    has_difference = sol_before != sol_after\n    return has_solution, has_difference\nfrom copy import deepcopy\n@contextmanager\ndef modelSolutionContext(model):\n    class ModelSolutionChecker:\n        def __init__(self, model_wr):\n            self.model_wr = model_wr\n            self.previous_solution = None\n            self.update()\n        @property\n        def model(self):\n            return self.model_wr()\n        @property\n        def solution(self):\n            return getModelSolution(self.model)\n        def update(self):\n            self.previous_solution = deepcopy(self.solution)\n        def check(self, update=False):\n            has_solution, has_difference = checkIfSolved(self.previous_solution, self.solution)\n            if update:\n                self.update()\n            return has_solution, has_difference\n        def has_new_solution(self, update=False):\n            has_solution, has_difference = self.check(update=update)\n            return has_solution and has_difference"
        },
        {
            "comment": "Code snippet initializes a model and variable, sets timezone and prints the current time. It also checks solver name and warm start options from environment variables before running the solver.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/alternative_solver.py\":82-119",
            "content": "    modelSolutionChecker = ModelSolutionChecker(weakref.ref(model))\n    try:\n        yield modelSolutionChecker\n    finally:\n        del modelSolutionChecker\ndef clearModelVariableValues(model: ConcreteModel):\n    for v in model.component_data_objects(ctype=Var, active=True, descend_into=True):\n        v: Var\n        v.clear()  # clear value.\nimport pytz\n# with respect to our dearly Py3.6\ntimezone_str = \"Asia/Shanghai\"\n# timezone = pytz.timezone(timezone_str:='Asia/Shanghai')\ntimezone = pytz.timezone(timezone_str)\n# import logging\nimport datetime\nnow = datetime.datetime.now(tz=timezone)\nprint(\"Current time: \" + now.isoformat())\nprint(\"=\" * 60)\nsolver_name = os.environ[\"SOLVER_NAME\"]\ninfeasible = os.environ.get(\"INFEASIBLE\", None) is not None\nwarm_start = os.environ.get(\"WARM_START\", None) is not None\nprint(\"running solver \" + solver_name)\nprint(f\"warm start? {repr(warm_start)}\")\nprint(\"=\" * 60)\n# that is during presolve, not during solve.\n# from pyomo.contrib.iis import write_iis\nmodel = ConcreteModel()\nx = model.\u53d8\u91cfx = Var()"
        },
        {
            "comment": "This code creates a model with variables x and y, sets warm start values for x and y, adds constraints to the model, defines an objective function, writes the model without bounds, creates a NaN objective as well, writes the model without bounds in ILP format, initializes a solver with the specified name based on warm_start and infeasible values, and potentially switches the LP algorithm.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/alternative_solver.py\":120-156",
            "content": "y = model.\u53d8\u91cfy = Var()\nif warm_start:\n    x.set_value(0.5)\n    y.set_value(0.5)\nmodel.constraint_x_y = Constraint(expr=x + y >= 10)\nmodel.constraint_x_y_inv = Constraint(expr=x + y <= 9)\nif not infeasible:\n    model.constraint_x_y_inv.deactivate()\nz = model.z = Var([0, 1])\nx.setlb(-10)\nx.setub(10)\nobj_expr = 2 * x - 5 + y + z[0] + z[1] + 3 * (z[0] + y) + 10\nobj = model.obj = Objective(expr=obj_expr, sense=minimize)\nmodel_write(model, \"no_bound\")\n# warning: shall not be NaN\n# from cmath import nan\n# no_obj = model.no_obj = Objective(expr=nan, sense=minimize) # treated as 0\nno_obj = model.no_obj = Objective(expr=0)\n# write_iis(model, \"no_bound.ilp\", \"cplex\")\n# no conflict! how comes? it is unbounded.\nsolver = SolverFactory(solver_name)\nif warm_start:\n    solver_name += \"_warmstart\"\nif infeasible:\n    solver_name += \"_infeasible\"\n# switch lp algorithm\n# ref: https://www.ibm.com/docs/en/icos/20.1.0?topic=parameters-algorithm-continuous-linear-problems\"\n# working?\n# solver.options['lpmethod'] = 1  # 0(automatic)-6(concurrent)"
        },
        {
            "comment": "This code sets various solver options for a model, including timelimit, conflict display, feasopt tolerance, and simplex tolerances. It also checks if the solver name is \"ipopt\" and sets specific options like maximum iterations, diverging iterates tolerance, and inf_pr_output. The function solver_solve takes a ConcreteModel and optional arguments as input.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/alternative_solver.py\":158-184",
            "content": "# solver.options[\"timelimit\"] = 15\n# solver.options[\"conflict display\"] = 2  # detailed display\n# not working.\n# solver.options['feasopt tolerance'] = 100 # seems not working.\n# solver.options['feasopt mode'] = 5 # 0(default)-5\n# cannot be too big.\n# solver.options['simplex tolerances optimality'] = 1e-1\nsmap_ids = []\nmodel.obj.deactivate()\nsolver_name_base = solver_name.split(\"_\")[0]\n# pass interactive options instead of commandline option.\n# solver.options[\"warm_start_init_point\"] = True\n# scan for \"Number of Iterations\" in output. get the number and set it here. (n-1)\n# ref: https://coin-or.github.io/Ipopt/OPTIONS.html#OPT_Termination\nif solver_name_base == \"ipopt\":\n    # solver.options['acceptable_iter'] = 10\n    # solver.options['max_iter'] = 10\n    solver.options[\"max_iter\"] = 3000\n    # solver.options['max_iter'] = 33-1\n    # solver.options['diverging_iterates_tol'] = 1e10\n    # solver.options['tol'] = 1e30\n    # solver.options['inf_pr_output'] = 'internal'\ndef solver_solve(model: ConcreteModel, **kwargs):"
        },
        {
            "comment": "The code uses a solver to solve a model and checks if the solution is new or not. It also handles exceptions for warm starts, logs results, and appends the solver's ID to a list.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/alternative_solver.py\":185-217",
            "content": "    with modelSolutionContext(model) as modelSolutionChecker:\n        ret = solver.solve(\n            model,\n            **kwargs,\n            **(\n                dict(warmstart=True)\n                if warm_start\n                # if warm_start and solver_name_base not in [\"ipopt\"]\n                else {}\n            ),\n        )\n        # has_solution, _ = modelSolutionChecker.check()  # check if we have new solution\n        has_new_solution = modelSolutionChecker.check()\n        # ret[\"solved\"] = has_solution\n        ret['has_new_solution'] = has_new_solution\n        # scip can find feasible solution, but only if no conflict is found\n        # if solver_name_base == \"scip\":\n        #     breakpoint()\n        return ret\nimport traceback\ntry:\n    result_no_obj = solver_solve(\n        model,\n        tee=True,\n        logfile=f\"no_obj_solver_{solver_name}.log\",\n    )\nexcept:\n    traceback.print_exc()\n    raise Exception(f\"solver {solver_name.split('_')[0]} does not support warmstart\")\nsmap_ids.append(solver._smap_id)"
        },
        {
            "comment": "The code prints the values of X and Y, separates with a line, deactivates the no_obj model and activates obj, solves unbound problem using solver, appends _smap_id to smap_ids list, checks if the exit condition is a forced one (maxIterations, maxTimeLimit, or maxEvaluations), reads log file content, finds the iteration number, subtracts 1 and sets it as max_iter in solver options.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/alternative_solver.py\":218-247",
            "content": "print(f\"X={value(x)}, Y={value(y)}\")\nprint()\nprint(\"=\" * 70)\nmodel.no_obj.deactivate()\nmodel.obj.activate()\n# model.bound_obj.deactivate()\nresult_unbound = solver_solve(\n    model, tee=True, logfile=(unbound_logfile := f\"unbound_solver_{solver_name}.log\")\n)\nimport re\nsmap_ids.append(solver._smap_id)\nITERATION_KW = \"Number of Iterations\"\nif solver_name_base == \"ipopt\":\n    # these are forced exits. could get results nevertheless.\n    if result_unbound.solver.termination_condition not in [\n        TerminationCondition.maxIterations,\n        TerminationCondition.maxTimeLimit,\n        TerminationCondition.maxEvaluations,  # what is this?\n    ]:\n        with open(unbound_logfile, \"r\") as f:\n            content = f.read()\n            content_lines = content.split(\"\\n\")\n            for line in content_lines:\n                if ITERATION_KW in line:\n                    iteration = re.search(r\"\\d+\", line).group()\n                    print(\"ITERATION: \", iteration)\n                    solver.options[\"max_iter\"] = int(iteration) - 1"
        },
        {
            "comment": "Code creates an alternative solver model with bound constraints and solves it. If the solver is IPOPT, a breakpoint is set. The code also sets time limit options for further optimization.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/alternative_solver.py\":248-280",
            "content": "                    result_unbound_rerun = solver_solve(\n                        model,\n                        tee=True,\n                        logfile=(\n                            unbound_logfile := f\"unbound_solver_{solver_name}_rerun.log\"\n                        ),\n                    )\n                    smap_ids.append(solver._smap_id)\n                    break\nprint()\nprint(\"=\" * 70)\n# no need to create new objective. just limit the objective expression to bounds.\nmobjVar = model.mobjVar = Var()\nmobjVar.setub(MAX_BOUND)\nmobjVar.setlb(-MAX_BOUND)\nmodel.constraint_bound_obj = Constraint(expr=mobjVar == obj_expr)\n# bound_obj = model.bound_obj = Objective(expr=mobjVar, sense=minimize)\n# model.obj.deactivate()\n# model.bound_obj.activate()\nclearModelVariableValues(model)\nresult_bound = solver_solve(model, tee=True, logfile=f\"bound_solver_{solver_name}.log\")\nsmap_ids.append(solver._smap_id)\n# if solver_name_base == \"ipopt\":\n#     breakpoint()\n# you still need to set time limit options over this.\nsolverResultDiagosticInfo = ("
        },
        {
            "comment": "The code defines a function to print solver result diagnostic information, with separate print statements for unbound and bound results. If the solver name is \"ipopt\" and \"result_unbound_rerun\" exists in the global scope, it prints the unbound rerun result as well. It then iterates over model solutions by symbol, printing each variable's value using the rich library. Finally, it defines an ExpressionDecomposer class to analyze variables causing havoc in the model.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/alternative_solver.py\":281-316",
            "content": "    lambda banner, solverResult: \"%s TERMINATION CONDITION: %s; SOLVED: %s\"\n    % (banner, solverResult.solver.termination_condition, solverResult[\"has_new_solution\"])\n)\nprintSolverResultDiagosticInfo = lambda banner, solverResult: print(\n    solverResultDiagosticInfo(banner, solverResult)\n)\nprintSolverResultDiagosticInfo(\"UNBOUND\", result_unbound)\nif solver_name_base == \"ipopt\":\n    if \"result_unbound_rerun\" in globals().keys():\n        printSolverResultDiagosticInfo(\"UNBOUND RERUN\", result_unbound_rerun)\nprintSolverResultDiagosticInfo(\"BOUND\", result_bound)\nimport rich\nfor it in model.solutions.symbol_map.values():\n    rich.print(it.bySymbol)\n# now analyze what variable is doing havoc to the model.\nfrom pyomo.core.expr import current as EXPR\n# class ExpressionDecomposer(EXPR.SimpleExpressionVisitor):\n#     def __init__(self):\n#         # self.counter = 0\n#         self.varmap = {}\n#     def visit(self, node):\n#         # self.counter += 1\n#         print(node)\n#         print(type(node))\n#         # breakpoint()"
        },
        {
            "comment": "The code defines a function `decomposeExpression` that takes an expression as input and decomposes it into its constant term, variable names, and their corresponding coefficients. The decomposition is done by iterating over the terms of the expression using EXPR's `decompose_term`, then adding each coefficient to the constant term or storing it in the respective dictionaries for the variable names and coefficients. The function returns a DecomposedExpression object containing this information.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/alternative_solver.py\":317-356",
            "content": "#         print(\"_____\")\n#     def finalize(self):\n#         return self.varmap\n# def decomposeExpression(expr):\n#     #\n#     # Create the visitor object\n#     #\n#     visitor = ExpressionDecomposer()\n#     #\n#     # Compute the varmap using the :func:`xbfs` search method.\n#     #\n#     varmap = visitor.xbfs(expr)\n#     return varmap\nfrom typing import TypedDict, Dict\nclass DecomposedExpression(TypedDict):\n    constant: float\n    varNameToVarObject: Dict[str, str]\n    varNameToVarCoefficient: Dict[str, float]\ndef decomposeExpression(expr):\n    const = 0\n    varNameToVarObject = {}\n    varNameToVarCoefficient = {}\n    is_linear, terms = EXPR.decompose_term(expr)\n    if is_linear:\n        for coef, var in terms:\n            if var is None:\n                const += coef\n            else:\n                varName = str(var)\n                varNameToVarObject[varName] = var\n                varNameToVarCoefficient[varName] = (\n                    varNameToVarCoefficient.get(varName, 0) + coef\n                )\n        return DecomposedExpression("
        },
        {
            "comment": "This code is checking the solution of a model, displaying variable values in sorted order, and decomposing objective expression. It exits if the model is not solved, prints the result if the decomposition is successful, and initializes dictionaries for variable names and term values.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/alternative_solver.py\":357-393",
            "content": "            constant=const,\n            varNameToVarObject=varNameToVarObject,\n            varNameToVarCoefficient=varNameToVarCoefficient,\n        )\nfrom typing import List, Tuple\ndef getValueListFromValueDict(valueDict: Dict[str, float]):\n    valueList = list(valueDict.items())\n    return valueList\ndef sortAndDisplayVarValues(\n    valueList: List[Tuple[str, float]], banner: str, head_count=10, reverse=False\n):\n    print(banner.center(70, \"=\"))  # to be commented out\n    valueList.sort(key=lambda x: x[1], reverse=reverse)\n    head_count = min(len(valueList), head_count)\n    message = [f\"reversed: {reverse}\", \"\"]\n    for i in range(head_count):\n        message.append(\"%s\\t%s\" % valueList[i])\n    output = \"\\n\".join(message)\n    print(output)\nif is_null_solution(getModelSolution(model)):\n    print(\"model not solved.\")\n    exit()\ndecomposedResult = decomposeExpression(obj_expr)\nif decomposedResult:\n    print(decomposedResult)\n    varNameToVarValue = {}\n    varNameToTermValue = {}\n    for varName, varObj in decomposedResult[\"varNameToVarObject\"].items():"
        },
        {
            "comment": "This code calculates the value of variables and their corresponding coefficients from decomposed results. It stores the values in dictionaries, sorts and displays them in specific ways, and then prints a blank line.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/alternative_solver.py\":394-415",
            "content": "        varValue = value(varObj)\n        coef = decomposedResult[\"varNameToVarCoefficient\"][\n            varName\n        ]  # seems to be no typeddict type checking in pyright\n        termValue = coef * varValue\n        varNameToVarValue[varName] = varValue\n        varNameToTermValue[varName] = termValue\n    # sort and display\n    valueListOfVarNameToVarValue = getValueListFromValueDict(varNameToVarValue)\n    valueListOfVarNameToTermValue = getValueListFromValueDict(varNameToTermValue)\n    BANNER_VARNAME_TO_VAR_VALUE = \"VAR NAME TO VAR VALUE\"\n    BANNER_VARNAME_TO_TERM_VALUE = \"VAR NAME TO TERM VALUE\"\n    sortAndDisplayVarValues(valueListOfVarNameToVarValue, BANNER_VARNAME_TO_VAR_VALUE)\n    sortAndDisplayVarValues(\n        valueListOfVarNameToVarValue, BANNER_VARNAME_TO_VAR_VALUE, reverse=True\n    )\n    sortAndDisplayVarValues(valueListOfVarNameToTermValue, BANNER_VARNAME_TO_TERM_VALUE)\n    sortAndDisplayVarValues(\n        valueListOfVarNameToTermValue, BANNER_VARNAME_TO_TERM_VALUE, reverse=True\n    )\n    print()"
        },
        {
            "comment": "This code checks if the objective expression is linear or not. It calculates the objective value and constant part of the objective function from decomposedResult. If the expression is non-linear, it prints a message stating so. It then prints the objective value and constant part separately. Finally, it prints the solver's smap ids and picks up the most recent one to translate the log and exported model in lp format.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/alternative_solver.py\":416-425",
            "content": "    obj_val = value(obj_expr)\n    obj_const = decomposedResult[\"constant\"]\n    print(\"(OBJ - OBJ_CONST)?\", obj_val - obj_const)\n    print(\"OBJ?\", obj_val)\n    print(\"OBJ_CONST?\", obj_const)\nelse:\n    print(\"objective expression is non-linear.\")\nprint(\"solver smap ids:\", smap_ids)  # three unique ids.\n# pick up the most recent one to translate the log and exported model (lp format)."
        }
    ]
}