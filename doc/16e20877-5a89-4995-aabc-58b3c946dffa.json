{
    "summary": "This code uses Pyomo and constraints to generate a task execution sequence, resolves dependencies with a solver, and checks for circular dependencies before worker startup.",
    "details": [
        {
            "comment": "This code generates an execution sequence for interdependent tasks by creating a Pyomo model and defining constraints based on task dependencies. It raises exceptions for task redefinition and unmet dependencies, ensuring valid input.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/resolve_task_dependency.py\":0-28",
            "content": "# virtually run interdependent tasks, generate the execution sequence\nfrom pyomo.environ import *\ndef resolv_task_deps(task_tree: list[dict], solver_name: str = \"cplex\"):\n    model = ConcreteModel()\n    lateinit_constraints = []\n    tasknames = set()\n    depnames = set()\n    for elem in task_tree:\n        name = elem.get(\"name\")\n        deps = elem.get(\"deps\", [])\n        deps = set(deps)\n        if name not in tasknames:\n            tasknames.add(name)\n        else:\n            raise Exception(f\"Redefinition of task <{name}> dependencies: {repr(deps)}\")\n        setattr(model, name, Var(domain=Integers))\n        for dep in deps:\n            depnames.add(dep)\n            lateinit_constraints.append((name, dep))\n    if not depnames.issubset(tasknames):\n        raise Exception(\"Have unmet dependencies: %s\" % depnames.difference(tasknames))\n    for index, (name, dep) in enumerate(lateinit_constraints):\n        setattr(\n            model,\n            f\"constraint_{index}\",\n            Constraint(expr=getattr(model, name) <= getattr(model, dep) - 1),"
        },
        {
            "comment": "This code is resolving task dependencies and determining the execution sequence for tasks in a task tree. It uses a solver to determine task priorities based on certain conditions, and raises an exception if the solver's termination condition is not within the expected range of normal termination conditions. The function `resolv_task_deps` returns a priority map which is then used to generate the task execution sequence in ascending order by priority, and this sequence is printed out.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/resolve_task_dependency.py\":29-60",
            "content": "        )\n    model.obj = Objective(expr=0, sense=minimize)\n    solver = SolverFactory(solver_name)\n    ret = solver.solve(model, tee=True)\n    normalTCs = [\n        TerminationCondition.globallyOptimal,\n        TerminationCondition.locallyOptimal,\n        TerminationCondition.feasible,\n        TerminationCondition.optimal,\n    ]\n    if (TC := ret.solver.termination_condition) not in normalTCs:\n        raise Exception(\n            \"Dependency resolution failed.\\nSolver termination condition: \" + TC\n        )\n    else:\n        priority_map = {}\n        for tn in tasknames:\n            task_priority = value(getattr(model, tn))\n            priority_map[tn] = task_priority\n            print(f\"{tn}:\\t{task_priority}\")\n        return priority_map\ndef get_task_seq(task_tree: list[dict], solver_name: str = \"cplex\"):\n    pm = resolv_task_deps(task_tree, solver_name)\n    if isinstance(pm, dict) and pm != {}:\n        seq = list(pm.items())\n        seq.sort(key=lambda x: -x[1])\n        seq = [x[0] for x in seq]\n        print(f\"Task exec sequence: {', '.join(seq)}\")"
        },
        {
            "comment": "The code defines a list of tasks with dependencies and checks for any circular dependency issues. The goal is to obtain the sequence in which the tasks should be executed, ensuring no circular dependencies are present. This verification is crucial before the worker starts up to avoid potential errors.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/cplex_abnormal_exit_condition_debug/resolve_task_dependency.py\":61-77",
            "content": "        return seq\nif __name__ == \"__main__\":\n    task_tree = [\n        {\"name\": \"task1\", \"deps\": [\"task2\", \"task3\"]},\n        {\"name\": \"task2\", \"deps\": [\"task4\"]},\n        {\"name\": \"task4\"},\n        {\"name\": \"task3\"},\n    ]\n    # task_tree += [ # circular dependency. you might want to use translation tools to identify issue.\n    #     {\"name\": \"task5\", \"deps\": [\"task6\"]},\n    #     {\"name\": \"task6\", \"deps\": [\"task7\"]},\n    #     {\"name\": \"task7\", \"deps\": [\"task5\"]},\n    # ]\n    seq = get_task_seq(task_tree)\n# this verification shall be performed before our worker ever starts up."
        }
    ]
}