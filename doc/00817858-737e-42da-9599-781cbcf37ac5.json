{
    "summary": "The code manages microgrid systems using classes, dictionaries, and functions for rule handling and data validation. It loads device data, verifies conditions, builds segment lists, generates lookup tables, and initializes dictionaries for microgrid components before setting the \"conjugate_port_verifier_constructor_lookup_table\" and calling a function to generate type utilities.",
    "details": [
        {
            "comment": "The code imports necessary libraries and functions, defines a class and functions for handling types and connection options. It loads type utilities JSON data for microgrid and extra ports.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/render_type_utils.py\":0-46",
            "content": "from log_utils import logger_print\nfrom jinja_utils import *\nfrom type_def import *\nfrom parse_params import TYPE_UTILS_MICROGRID_PORTS, TYPE_UTILS_EXTRA_PORTS\nimport json\nfrom typing import Literal\nfrom constants import UNKNOWN\n\u4e92\u65a5 = \"\u4e92\u65a5\"\n\u51b7\u70ed\u4e92\u65a5 = \"\u51b7\u70ed\u4e92\u65a5\"\nUNKNOWN_REPR = repr(UNKNOWN)\n\u53ef\u9009\u8fde\u63a5 = \"\u53ef\u9009\u8fde\u63a5\"\n\u5173\u8054\u8fde\u63a5 = \"\u5173\u8054\u8fde\u63a5\"\n\u81f3\u5c11\u8fde\u63a5 = \"\u81f3\u5c11\u8fde\u63a5\"\nclass AppendableDict(dict):\n    def __init__(self, *args, **kwargs):\n        super(AppendableDict, self).__init__(*args, **kwargs)\n    def append(self, key, value):\n        if key in self:\n            self[key].append(value)\n        else:\n            self[key] = [value]\ndef load_json(filename):\n    with open(filename, \"r\") as f:\n        return json.load(f)\ndef load_type_utils_json_with_added_suffix(fpath):\n    fpath += \".json\"\n    logger_print(\"Loading:\", fpath)\n    dat = load_json(fpath)\n    return dat\nTYPE_UTILS_MICROGRID_PORTS_DATA = load_type_utils_json_with_added_suffix(\n    TYPE_UTILS_MICROGRID_PORTS\n)\nTYPE_UTILS_EXTRA_PORTS_DATA = load_type_utils_json_with_added_suffix(\n    TYPE_UTILS_EXTRA_PORTS"
        },
        {
            "comment": "This code defines special ports for various components in a microgrid system, including unidirectional and mutual exclusive components. It also specifies their input/output ports, basic types, flow directions, and optional requirements.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/render_type_utils.py\":47-85",
            "content": ")\n# import rich\n# logger_print(TYPE_UTILS_EXTRA_PORTS_DATA)\n# # exit()\n# breakpoint()\nTYPE_UTILS_SPECIAL_PORTS = \"<type_utils_special_ports>\"\nANY = \"/\".join(\u57fa\u672c\u7c7b\u578b.__members__.keys())\nTYPE_UTILS_SPECIAL_PORTS_DATA = {\n    \"\u7279\u6b8a\u5143\u4ef6\": {\n        \"\u5355\u5411\u7ebf\": {\n            \"ports\": {\n                \"\u8f93\u5165\u63a5\u53e3\": {\n                    \"info\": None,\n                    \"\u7ec6\u5206\u7c7b\u578b\": None,\n                    \"\u57fa\u672c\u7c7b\u578b\": ANY,\n                    \"\u80fd\u6d41\u65b9\u5411\": \"\u8fdb\",\n                    \"\u5fc5\u6709\u5de5\u51b5\": None,\n                },\n                \"\u8f93\u51fa\u63a5\u53e3\": {\n                    \"info\": None,\n                    \"\u7ec6\u5206\u7c7b\u578b\": None,\n                    \"\u57fa\u672c\u7c7b\u578b\": ANY,\n                    \"\u80fd\u6d41\u65b9\u5411\": \"\u51fa\",\n                    \"\u5fc5\u6709\u5de5\u51b5\": None,\n                },\n            },\n            \"rules\": [\"\u8f93\u5165\u63a5\u53e3 \u8fdb -> \u8f93\u51fa\u63a5\u53e3 \u51fa\", \"\u8f93\u51fa\u63a5\u53e3 \u51fa -> \u8f93\u5165\u63a5\u53e3 \u8fdb\"],\n            \"requirements\": [],\n        },\n        \"\u4e92\u65a5\u5143\u4ef6\": {\n            \"ports\": {\n                \"\u4e92\u65a5\u63a5\u53e3A\": {\n                    \"info\": None,\n                    \"\u7ec6\u5206\u7c7b\u578b\": None,\n                    \"\u57fa\u672c\u7c7b\u578b\": ANY,\n                    \"\u80fd\u6d41\u65b9\u5411\": \"\u8fdb\u51fa\",\n                    \"\u5fc5\u6709\u5de5\u51b5\": None,"
        },
        {
            "comment": "This code defines a dictionary containing information about microgrid ports and their connectivity rules. The 'rules' list outlines the conditions for connecting or disconnecting specific ports, while 'connectivity_check_header_prefixes' defines different types of connections. The '__all__' line specifies exported variables from this module.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/render_type_utils.py\":86-121",
            "content": "                },\n                \"\u4e92\u65a5\u63a5\u53e3B\": {\n                    \"info\": None,\n                    \"\u7ec6\u5206\u7c7b\u578b\": None,\n                    \"\u57fa\u672c\u7c7b\u578b\": ANY,\n                    \"\u80fd\u6d41\u65b9\u5411\": \"\u8fdb\u51fa\",\n                    \"\u5fc5\u6709\u5de5\u51b5\": None,\n                },\n                \"\u5916\u90e8\u63a5\u53e3\": {\n                    \"info\": None,\n                    \"\u7ec6\u5206\u7c7b\u578b\": None,\n                    \"\u57fa\u672c\u7c7b\u578b\": ANY,\n                    \"\u80fd\u6d41\u65b9\u5411\": \"\u8fdb\u51fa\",\n                    \"\u5fc5\u6709\u5de5\u51b5\": None,\n                },\n            },\n            \"rules\": [\n                \"\u4e92\u65a5\u63a5\u53e3A \u8fdb -> \u4e92\u65a5\u63a5\u53e3B \u7a7a\u95f2; \u5916\u90e8\u63a5\u53e3 \u51fa\",\n                \"\u4e92\u65a5\u63a5\u53e3A \u51fa -> \u4e92\u65a5\u63a5\u53e3B \u7a7a\u95f2; \u5916\u90e8\u63a5\u53e3 \u8fdb\",\n                \"\u4e92\u65a5\u63a5\u53e3B \u8fdb -> \u4e92\u65a5\u63a5\u53e3A \u7a7a\u95f2; \u5916\u90e8\u63a5\u53e3 \u51fa\",\n                \"\u4e92\u65a5\u63a5\u53e3B \u51fa -> \u4e92\u65a5\u63a5\u53e3A \u7a7a\u95f2; \u5916\u90e8\u63a5\u53e3 \u8fdb\",\n                \"\u5916\u90e8\u63a5\u53e3 \u7a7a\u95f2 -> \u4e92\u65a5\u63a5\u53e3A \u7a7a\u95f2; \u4e92\u65a5\u63a5\u53e3B \u7a7a\u95f2\",\n            ],\n            \"requirements\": [],\n        },\n    }\n}\nconnectivity_check_header_prefixes = [\u53ef\u9009\u8fde\u63a5, \u5173\u8054\u8fde\u63a5, \u81f3\u5c11\u8fde\u63a5]\n# if UNKNOWN then the port must not be connected\n__all__ = [\n    \"TYPE_UTILS_MICROGRID_PORTS_DATA\",\n    \"TYPE_UTILS_EXTRA_PORTS_DATA\",\n    \"TYPE_UTILS_MICROGRID_PORTS\",\n    \"TYPE_UTILS_EXTRA_PORTS\","
        },
        {
            "comment": "This code defines several utility functions for parsing and manipulating rules related to ports and port conditions. It includes dictionaries for translating port conditions, defining rules for mandatory and optional operating conditions, generating parameter lists for rule construction, and parsing a rule side (left or right) by removing leading/trailing whitespaces.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/render_type_utils.py\":122-156",
            "content": "    \"TYPE_UTILS_SPECIAL_PORTS\",\n    \"TYPE_UTILS_SPECIAL_PORTS_DATA\",\n]\nif __name__ == \"__main__\":\n    # def parse_leftover(leftover):\n    #     segments = leftover.split(\";\")\n    #     ret = []\n    #     for s in segments:\n    #         s = s.strip()\n    #         if s:\n    #             ret.append(s)\n    #     return ret\n    \u5de5\u51b5\u7ffb\u8bd1 = dict(\u8fdb=\"input\", \u51fa=\"output\", \u7a7a\u95f2=\"idle\")\n    \u5fc5\u6709\u5de5\u51b5\u8f6c\u5b9a\u4e49 = dict(\n        \u4e00\u76f4\u4e0d\u5de5\u4f5c=f\"set(conds).difference({{ 'idle', {UNKNOWN_REPR} }}) == set()\",\n        **{\n            k: f\"{repr(v)} in conds or {UNKNOWN_REPR} in conds\" for k, v in \u5de5\u51b5\u7ffb\u8bd1.items()\n        },\n    )\n    make_param_list = lambda e: [e + str(i) for i in range(len(k))]\n    makeRule = (\n        lambda c0, c1: f\"{c0} not in [{UNKNOWN_REPR}, 'idle']\"\n        if c1 is None\n        else f\"{c0} in [{UNKNOWN_REPR}, {repr(\u5de5\u51b5\u7ffb\u8bd1[c1])}]\"\n    )\n    makeRuleWithoutUnknown = (\n        lambda c0, c1: f\"{c0} not in ['idle']\"\n        if c1 is None\n        else f\"{c0} in [{repr(\u5de5\u51b5\u7ffb\u8bd1[c1])}]\"\n    )\n    def parse_rule_side(left_or_right: str):\n        left_or_right = left_or_right.strip()"
        },
        {
            "comment": "This code defines several functions for rule manipulation. It splits a rule into components, parses the rule key, replaces key with table values, and replaces keys as condition or event type. These functions can be used to process rule definitions in a microgrid system.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/render_type_utils.py\":157-189",
            "content": "        comps = left_or_right.split(\";\")\n        ret = []\n        for c in comps:\n            c = c.strip()\n            if len(c) > 0:\n                cs = c.split()\n                assert len(cs) >= 1, f\"invalid rule segment: {c}\"\n                assert len(cs) <= 2, f\"invalid rule segment: {c}\"\n                if len(cs) == 1:\n                    cs += [None]\n                ret.append(tuple(cs))\n        return ret\n    def parse_rule_key(content):\n        k = [c0 for c0, _ in content]\n        k = tuple(set(k))\n        return k\n    def replace_with_table(content, table):\n        ret = content\n        for k, v in table.items():\n            ret = ret.replace(k, v)\n        return ret\n    def replace_as_cond_or_etype(\n        rule_definition: str, rule_key: tuple[str], target: Literal[\"cond\", \"etype\"]\n    ):\n        translation_table = {k: f\"{target}{i}\" for i, k in enumerate(rule_key)}\n        ret = replace_with_table(rule_definition, translation_table)\n        return ret\n    def parse_rule(rule):\n        _, content = rule_parser(rule)"
        },
        {
            "comment": "This code defines a function to generate an optional connectivity rule for microgrid. It checks the etype of each port and returns True if all are not UNCHECK_CONNECTIVITY_IN_DYNAMIC_TYPE_VERIFICATION, or False otherwise. The function takes port names and optional_port_names as inputs and generates the rule accordingly.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/render_type_utils.py\":190-213",
            "content": "        _left, _right = content.split(\"->\")\n        left = parse_rule_side(_left)\n        right = parse_rule_side(_right)\n        k = parse_rule_key(left + right)\n        assert len(left) == 1, f\"abnormal rule because of multiple left side: {rule}\"\n        # v_left = makeRule(*left[0])\n        v_left = makeRuleWithoutUnknown(*left[0])\n        v_right = \", \".join([makeRule(*r) for r in right])\n        v = f\"all([{v_right}]) if {v_left} else True\"\n        v = replace_as_cond_or_etype(v, k, \"cond\")\n        return k, v\n    def generate_optional_connectivity_rule(port_names, optional_port_names):\n        remained_et_params = [\n            f\"etype{i}\"\n            for i, pn in enumerate(port_names)\n            if pn not in optional_port_names\n        ]\n        v = \"True\"\n        if remained_et_params != []:\n            connectivity_check_rule_content = \", \".join(\n                [f\"{pn_et} != {UNKNOWN_REPR}\" for pn_et in remained_et_params]\n            )\n            v = f\"True if ies_env.UNCHECK_CONNECTIVITY_IN_DYNAMIC_TYPE_VERIFICATION else all([{connectivity_check_rule_content}])\""
        },
        {
            "comment": "This code defines a function that parses and evaluates different types of requirements for microgrid components. It checks for connectivity, mutual exclusivity, and hot-cold mutex constraints in the given requirement string and returns an evaluated expression based on the rule type found.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/render_type_utils.py\":214-236",
            "content": "            # v = f\"all([{connectivity_check_rule_content}])\"\n        return v\n    def parse_requirement(requirement, port_names):\n        header, _content = rule_parser(requirement)\n        content = parse_rule_side(_content)\n        k = parse_rule_key(content)\n        t = splited_header = (\n            None if not isinstance(header, str) else header.split(\"[\")[0]\n        )\n        exc = Exception(\"unknown header:\", header, \"content:\", content)\n        if header == \u4e92\u65a5:\n            v = \", \".join(\n                [f\"int({makeRuleWithoutUnknown(c0, c1)})\" for c0, c1 in content]\n            )\n            # v = \", \".join([f\"int({makeRule(c0, c1)})\" for c0, c1 in content])\n            v = f\"sum([{v}]) <= 1\"\n            v = replace_as_cond_or_etype(v, k, \"cond\")\n        elif header == \u51b7\u70ed\u4e92\u65a5:\n            c0s = [c0 for c0, _ in content]\n            c0s = \", \".join(c0s)\n            enforce_heat_or_cold = (\n                lambda heat_or_cold: f\"all([{repr(heat_or_cold)} in it or it == {UNKNOWN_REPR} for it in [{c0s}]])\""
        },
        {
            "comment": "The code checks the header of a content and performs different actions based on its value. If the header is a connectivity check, it generates rules for optional or mandatory connections between ports. The code also handles unknown values by considering them in the conditions for connection enforcement. It uses lists and joins to create strings representing conditions for each port.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/render_type_utils.py\":237-257",
            "content": "            )\n            v = \" or \".join([enforce_heat_or_cold(e) for e in [\"\u51b7\", \"\u70ed\"]])\n            v = replace_as_cond_or_etype(v, k, \"etype\")\n        elif (\n            # isinstance(header, str)\n            # and\n            splited_header\n            in connectivity_check_header_prefixes\n        ):\n            # port_candidates = [c0 for c0, _ in content]\n            # port_candidates = k\n            # skipped for now.\n            # use 'and' to join all together\n            et_param = \",\".join([f\"etype{i}\" for i in range(len(k))])\n            # et_param = \",\".join([f\"etype{i}\" for i in range(len(port_names))])\n            # if has optional ports, then do not add connectivity enforcement to all ports\n            if splited_header == \u53ef\u9009\u8fde\u63a5:  # we need to have the port list later\n                v = generate_optional_connectivity_rule(port_names, k)\n                k = port_names\n            elif splited_header == \u5173\u8054\u8fde\u63a5:\n                v = f\"sum([int(it != {UNKNOWN_REPR}) for it in [{et_param}]]) in [0, {len(k)}]\""
        },
        {
            "comment": "This code defines two functions, `render_type` and `rule_parser`, which seem to be part of a larger program for handling rules and rendering types. The `render_type` function takes in three parameters (k, v, t), splits the header based on certain conditions, and returns the key (k), value (v) with specific conditions applied, and the type (t). The `rule_parser` function parses a given rule string into a header and content components, ensuring they are not empty, and returns them as separate values.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/render_type_utils.py\":258-285",
            "content": "            elif splited_header == \u81f3\u5c11\u8fde\u63a5:  # \u83b7\u5f97\u81f3\u5c11\u8fde\u63a5\u7684\u63a5\u53e3\u6570\u91cf\n                \u81f3\u5c11\u8fde\u63a5\u7684\u63a5\u53e3\u6570\u91cf = int(header.split(\"[\")[-1].strip(\"]\"))\n                v = f\"sum([int(it != {UNKNOWN_REPR}) for it in [{et_param}]]) >= {\u81f3\u5c11\u8fde\u63a5\u7684\u63a5\u53e3\u6570\u91cf}\"\n            else:\n                raise exc\n        else:\n            raise exc\n        return k, v, t\n    def rule_parser(rule):\n        rule = rule.replace(\"\uff1a\", \":\").replace(\"\uff1b\", \";\")\n        segments = rule.split(\":\")\n        if len(segments) == 1:\n            header = None\n            leftover = segments[0]\n        elif len(segments) == 2:\n            header = segments[0].strip()\n            assert header, \"empty header at rule: %s\" % rule\n            leftover = segments[1]\n        else:\n            raise Exception(\n                \"Invalid segment count: %d\\nSegments: %s\"\n                % (len(segments), str(segments))\n            )\n        content = leftover.strip()\n        assert content, \"empty content at rule: %s\" % rule\n        # content = parse_leftover(leftover)\n        return header, content"
        },
        {
            "comment": "The code defines functions for asserting non-empty dictionaries, translating flow directions, and retrieving energy types from a port definition. It also handles cases where candidates or refinements are not specified correctly. The code appears to be related to data validation and translation in the context of a microgrid system.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/render_type_utils.py\":287-323",
            "content": "    output_path, template_path = code_and_template_path(\"type_utils\")\n    render_params = {}\n    deviceTypeTriplets = []\n    deviceTypes = []\n    energyTypes = set()\n    port_verifier_lookup_table = {}\n    conjugate_port_verifier_constructor_lookup_table = {}\n    def assert_is_nonempty_dict(d):\n        assert isinstance(d, dict)\n        assert d != {}\n    \u80fd\u6d41\u65b9\u5411\u7ffb\u8bd1\u8868 = dict(\u8fdb=\"input\", \u51fa=\"output\")\n    def \u80fd\u6d41\u65b9\u5411\u7ffb\u8bd1(\u80fd\u6d41\u65b9\u5411):\n        directions = []\n        if \u80fd\u6d41\u65b9\u5411:\n            for \u65b9\u5411 in \u80fd\u6d41\u65b9\u5411.strip():\n                if \u65b9\u5411 in \u80fd\u6d41\u65b9\u5411\u7ffb\u8bd1\u8868.keys():\n                    directions.append(\u80fd\u6d41\u65b9\u5411\u7ffb\u8bd1\u8868[\u65b9\u5411])\n                else:\n                    raise Exception(\"\u4e0d\u5b58\u5728\u7684\u65b9\u5411:\" + \u65b9\u5411)\n        return directions\n    def portDefToEnergyTypes(portDef: dict):\n        eTypes = []\n        _\u7ec6\u5206\u7c7b\u578b = portDef[\"\u7ec6\u5206\u7c7b\u578b\"]\n        _\u57fa\u672c\u7c7b\u578b = portDef[\"\u57fa\u672c\u7c7b\u578b\"]\n        candidates = _\u57fa\u672c\u7c7b\u578b if _\u7ec6\u5206\u7c7b\u578b is None else _\u7ec6\u5206\u7c7b\u578b\n        if candidates is None:\n            raise Exception(\"No candidates\")\n            # breakpoint()\n        for t in candidates.split(\"/\"):\n            # if isinstance(t, list):"
        },
        {
            "comment": "This code loads and parses various device types from multiple data files, checks the non-empty status of each dictionary, extracts the sub-type for each device, and appends it to a list called 'deviceTypes'. The code also breaks if the set of 't' equals {'\u9187', '\u4e59', '\u4e8c'}, logs messages, and defines various constants related to microgrid ports.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/render_type_utils.py\":324-347",
            "content": "            #     if set(t) == set(['\u9187', '\u4e59', '\u4e8c']): breakpoint()\n            # logger_print('t:', t, type(t))\n            t_resolved = \u89e3\u6790\u57fa\u672c\u7c7b\u578b(t)\n            eTypes.extend(t_resolved)\n        logger_print(eTypes)\n        return eTypes\n    for fpath, dat in {\n        TYPE_UTILS_MICROGRID_PORTS: TYPE_UTILS_MICROGRID_PORTS_DATA,\n        TYPE_UTILS_EXTRA_PORTS: TYPE_UTILS_EXTRA_PORTS_DATA,  # TODO: add synthetic data here.\n        TYPE_UTILS_SPECIAL_PORTS: TYPE_UTILS_SPECIAL_PORTS_DATA,\n    }.items():\n        logger_print(\"Parsing:\", fpath)\n        # dat = load_json(fpath + \".json\")\n        # breakpoint()\n        for devType, devDict in dat.items():\n            logger_print(\"parsing devType:\", devType)\n            assert_is_nonempty_dict(devDict)\n            for devSubType, devDef in devDict.items():\n                assert devSubType != \"null\"\n                assert len(devSubType) > 0\n                logger_print(\"parsing devSubType:\", devSubType)\n                deviceTypes.append(devSubType)\n                ports = devDef[\"ports\"]"
        },
        {
            "comment": "This code asserts that the 'ports' dictionary is not empty, and then initializes three dictionaries to store information about port states, energy types, and creates a lookup table for device-port verifiers. It iterates through each port in the 'ports' dictionary, adding its frontend name, possible states (including \"idle\"), and energy types. It also checks if there are mandatory operating conditions specified for each port and builds a verification condition segment list accordingly. The final result is joined with \"or\" connectors to create a verifier definition string.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/render_type_utils.py\":348-371",
            "content": "                assert_is_nonempty_dict(ports)\n                requiredPortFrontendNameToPortPossibleStates = {}\n                requiredPortFrontendNameToEnergyTypes = {}\n                device_port_verifier_lookup_table = {}\n                for portName, portDef in ports.items():\n                    requiredPortFrontendNameToPortPossibleStates[portName] = [\n                        \"idle\"\n                    ] + \u80fd\u6d41\u65b9\u5411\u7ffb\u8bd1(portDef[\"\u80fd\u6d41\u65b9\u5411\"])\n                    requiredPortFrontendNameToEnergyTypes[\n                        portName\n                    ] = portDefToEnergyTypes(portDef)\n                    cond_segment_list = []\n                    \u5fc5\u6709\u5de5\u51b5 = portDef[\"\u5fc5\u6709\u5de5\u51b5\"]\n                    if \u5fc5\u6709\u5de5\u51b5:\n                        for item in \u5fc5\u6709\u5de5\u51b5.split(\"/\"):\n                            cond_segment = \u5fc5\u6709\u5de5\u51b5\u8f6c\u5b9a\u4e49[item]\n                            cond_segment_list.append(cond_segment)\n                    verifier_definition = \" or \".join(\n                        [\n                            f\"logFailedRule({cond_segment}, '#{_i} (port, {portName}, {devSubType})')\""
        },
        {
            "comment": "This code creates a lookup table for device port verifiers based on the given condition segments and device subtype. It also adds energy types from requiredPortFrontendNameToEnergyTypes to the list, and initializes an _conjugate_verifiers dictionary.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/render_type_utils.py\":372-396",
            "content": "                            for _i, cond_segment in enumerate(cond_segment_list)\n                        ]\n                        # [f\"({cond_segment})\" for cond_segment in cond_segment_list]\n                    )\n                    if verifier_definition:\n                        device_port_verifier_lookup_table[\n                            portName\n                        ] = f\"lambda conds: {verifier_definition}\"\n                if device_port_verifier_lookup_table:\n                    port_verifier_lookup_table[\n                        devSubType\n                    ] = device_port_verifier_lookup_table\n                for _, etypes in requiredPortFrontendNameToEnergyTypes.items():\n                    for energyType in etypes:\n                        energyTypes.add(energyType)\n                _conjugate_verifiers = AppendableDict()\n                # _conjugate_verifiers = {}\n                rule_list = devDef[\"rules\"]\n                requirement_list = devDef[\"requirements\"]\n                port_names = tuple(ports.keys())"
        },
        {
            "comment": "This code generates a list of verifiers for microgrid components based on provided rules and requirements. It checks if there is a rule for optional ports, and if not, it generates one. The list of verifiers is stored in the _conjugate_verifiers dictionary.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/render_type_utils.py\":397-419",
            "content": "                # tuple of port names\n                # \"lambda cond0, cond1: ...\"\n                for rule in rule_list:\n                    k, v = parse_rule(rule)\n                    _conjugate_verifiers.append(k, v)\n                    # _conjugate_verifiers[k] = _conjugate_verifiers.get(k, []) + [v]\n                has_optional_port_rule = False\n                for requirement in requirement_list:\n                    k, v, t = parse_requirement(requirement, port_names)\n                    # k, v, t = parse_requirement(requirement)\n                    if t == \u53ef\u9009\u8fde\u63a5:\n                        has_optional_port_rule = True\n                        # k = port_names\n                    _conjugate_verifiers.append(k, v)\n                    # _conjugate_verifiers[k] = _conjugate_verifiers.get(k, []) + [v]\n                if not has_optional_port_rule:\n                    v = generate_optional_connectivity_rule(port_names, [])\n                    k = port_names\n                    _conjugate_verifiers.append(k, v)"
        },
        {
            "comment": "The code creates a dictionary of conjugate verifiers by iterating through _conjugate_verifiers. It generates lambda functions for each verifier, using the key and its elements to create the function's parameters. The code then checks if there are any conjugate verifiers and asserts that the keys exist in the ports dictionary.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/render_type_utils.py\":421-443",
            "content": "                conjugate_verifiers = {}\n                for k, v in _conjugate_verifiers.items():\n                    lambda_params = \", \".join(\n                        make_param_list(\"cond\") + make_param_list(\"etype\")\n                    )\n                    v = \" and \".join(\n                        [\n                            f\"logFailedRule({_v}, '#{_i} (conjugate, ({', '.join(k)}), {devSubType})')\"\n                            for _i, _v in enumerate(v)\n                        ]\n                    )\n                    # v = \" and \".join([f\"({_v})\" for _v in v])\n                    v = f\"lambda {lambda_params}: {v}\"\n                    conjugate_verifiers[k] = v\n                if conjugate_verifiers:\n                    for k in conjugate_verifiers.keys():\n                        for e_k in k:\n                            assert (\n                                e_k in ports.keys()\n                            ), f\"found nonexistant key {e_k} at device {devSubType}\"\n                    conjugate_verifiers_repr = \", \".join("
        },
        {
            "comment": "Creates a dictionary of verifiers for different port kinds, adds the dictionary to the lookup table based on device subtype, and updates render_params with the new information.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/render_type_utils.py\":444-465",
            "content": "                        [f\"{repr(k)}: {v}\" for k, v in conjugate_verifiers.items()]\n                    )\n                    conjugate_verifiers_repr = f\"{{{conjugate_verifiers_repr}}}\"\n                    conjugate_verifiers_constructor = f\"lambda port_kind_to_port_name: {{tuple([port_kind_to_port_name[it] for it in k]): v for k, v in {conjugate_verifiers_repr}.items()}}\"\n                    conjugate_port_verifier_constructor_lookup_table[\n                        devSubType\n                    ] = conjugate_verifiers_constructor\n                deviceTypeTriplets.append(\n                    (\n                        devSubType,\n                        requiredPortFrontendNameToPortPossibleStates,\n                        requiredPortFrontendNameToEnergyTypes,\n                    )\n                )\n    render_params[\"deviceTypeTriplets\"] = deviceTypeTriplets\n    render_params[\"deviceTypes\"] = deviceTypes\n    render_params[\"energyTypes\"] = list(energyTypes)\n    # breakpoint()\n    render_params[\"port_verifier_lookup_table\"] = port_verifier_lookup_table"
        },
        {
            "comment": "This code sets the \"conjugate_port_verifier_constructor_lookup_table\" in render_params and then calls a function called load_render_and_format with template_path, output_path, and additional parameters. The banner argument is set to \"GENERATING TYPE UTILS\".",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/render_type_utils.py\":466-475",
            "content": "    render_params[\n        \"conjugate_port_verifier_constructor_lookup_table\"\n    ] = conjugate_port_verifier_constructor_lookup_table\n    load_render_and_format(\n        template_path,\n        output_path,\n        render_params=render_params,\n        banner=\"GENERATING TYPE UTILS\",\n    )"
        }
    ]
}