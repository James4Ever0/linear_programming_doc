{
    "summary": "The code manages device ports, connection lines, and microgrid types, ensuring uniqueness and raising exceptions. It transforms data structures, logs information, reads CSV files, creates DataFrames, defines mappings, converts ports, populates dictionaries, handles errors, and visualizes graphs for analysis.",
    "details": [
        {
            "comment": "The code defines functions for type system management in a microgrid. It handles device ports and connection lines, assigns unique hashes to non-connecting wires, and specifies device types and their input/output connections. The code also includes functions for revert dictionary, checking valid type base name, and saving data to an Excel file.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_system.py\":0-57",
            "content": "from log_utils import logger_print\n# \u98ce\u529b\u3001\u5149\u4f0f\u3001\u67f4\u6cb9\u673a \u589e\u52a0\u4e0d\u53ef\u8fde\u63a5\u7684\u7ebf \u5220\u9664\u53d8\u6d41\u5668\u8282\u70b9\u7684\u4e0d\u53ef\u8fde\u63a5\u7ebf\n# \u589e\u52a0\u53d8\u6d41\u5668\u548c\u4e0d\u53ef\u8fde\u63a5\u6bcd\u7ebf\u7684\u8fde\u63a5\nimport rich\n# \u533a\u5206\u8bbe\u5907\u7aef\u53e3\u548c\u8fde\u63a5\u7ebf \u7aef\u53e3\u662f\u70b9 \u8fde\u63a5\u7ebf\u662f\u8fb9\n# \u7ed9\u6240\u6709\u4e0d\u53ef\u8fde\u63a5\u7ebf\u589e\u52a0\u968f\u673ahash\u503c \u65b9\u4fbf\u89c2\u5bdf\nPLOT_ONLY = False\n# from turtle import backward\n# import pandas\nimport uuid\nhash_set = set()\ndef get_uniq_hash():\n    while True:\n        mhash = str(uuid.uuid4()).split(\"-\")[0][:2]\n        if mhash not in hash_set:\n            hash_set.add(mhash)\n            return mhash\noutput_path = \"microgrid_type_system.xlsx\"\nsheet1_name = \"\u7c7b\u578b\u8fde\u63a5\u77e9\u9635\"\nsheet2_name = \"\u8bbe\u5907\u7aef\u53e3\u7c7b\u578b\u8868\"\n# \u6bcd\u7ebf\u8f93\u5165 = 0\n# \u6bcd\u7ebf\u8f93\u51fa = 0\n# \u50a8\u80fd\u7aef\u8f93\u5165\u8f93\u51fa = 1\n# \u53cc\u5411\u53d8\u6d41\u5668\u8f93\u5165\u8f93\u51fa = 1\n# \u53ef\u8fde\u63a5\u6bcd\u7ebf = 2\n# \u4e0d\u53ef\u8fde\u63a5\u6bcd\u7ebf = 2\n# \u53ef\u8fde\u63a5\u4f9b\u7535\u7aef\u6bcd\u7ebf = 3\n# \u4e0d\u53ef\u8fde\u63a5\u4f9b\u7535\u7aef\u6bcd\u7ebf = 3\n# \u53ef\u8fde\u63a5\u50a8\u80fd\u7aef\u6bcd\u7ebf = 4\n# \u4e0d\u53ef\u8fde\u63a5\u50a8\u80fd\u7aef\u6bcd\u7ebf = 4\n# \u4f9b\u7535\u7aef\u8f93\u51fa,\u53d8\u6d41\u5668\u8f93\u5165 = 0\ndef revert_dict(mdict: dict):\n    result = {e: k for k, v in mdict.items() for e in v}\n    return result\ndef check_valid_type_base_name(type_base_name):\n    try:\n        assert \"\u8f93\" not in type_base_name\n        assert \"\u51fa\" not in type_base_name\n        assert \"\u5165\" not in type_base_name\n    except:\n        raise Exception(\"Invalid type base name:\", type_base_name)\n    return type_base_name.strip()"
        },
        {
            "comment": "This code defines functions to represent inputs, outputs, and I/O operations for various types. It also includes dictionaries representing coaxial triplet connections for source, load, and IO devices with specific types (e.g., \"\u7535\" or \"\u67f4\u6cb9\"). The code further creates mappings between certain IO types and their associated wire types, as well as a function to generate a connectivity matrix based on the provided type mapping and length of triplets.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_system.py\":60-104",
            "content": "def Input(type_base_name):\n    type_base_name = check_valid_type_base_name(type_base_name)\n    return f\"{type_base_name.strip()}\u8f93\u5165\"\ndef Output(type_base_name):\n    type_base_name = check_valid_type_base_name(type_base_name)\n    return f\"{type_base_name.strip()}\u8f93\u51fa\"\ndef IO(type_base_name):\n    type_base_name = check_valid_type_base_name(type_base_name)\n    return f\"{type_base_name.strip()}\u8f93\u5165\u8f93\u51fa\"\nsource_coax_triplets = {  # Input, Output, ConnectionBaseName\n    \"\u7535\": [(\"\u53d8\u6d41\u5668\", \"\u4f9b\u7535\u7aef\", \"\u4f9b\u7535\u7aef\u6bcd\u7ebf\")],\n}\nsource_and_load_coax_triplets = {\n    \"\u7535\": [(\"\u7535\u6bcd\u7ebf\", \"\u7535\u6bcd\u7ebf\", \"\u7535\u6bcd\u7ebf\")],\n}\nload_coax_triplets = {  # Input, Output, ConnectionBaseName\n    \"\u7535\": [\n        (\"\u8d1f\u8377\u7535\", \"\u53d8\u538b\u5668\", \"\u8d1f\u8377\u7535\u6bcd\u7ebf\"),\n    ],\n    \"\u67f4\u6cb9\": [\n        (\"\u67f4\u6cb9\", \"\u67f4\u6cb9\", \"\u67f4\u6cb9\u6bcd\u7ebf\"),\n    ],\n}\n# IO_1, IO_2, ConnectionBaseName\nio_storage_coax_triplets = {\"\u7535\": [(\"\u7535\u50a8\u80fd\u7aef\", \"\u53cc\u5411\u53d8\u6d41\u5668\u50a8\u80fd\u7aef\", \"\u7535\u50a8\u80fd\u7aef\u6bcd\u7ebf\")]}\n#\nio_to_wire = {\"\u7535\": [(\"\u53cc\u5411\u53d8\u6d41\u5668\u7ebf\u8def\u7aef\", \"\u7535\u6bcd\u7ebf\")]}\ntypes = {}  # {str: set()}\nwire_types = {}\ntypes_connectivity_matrix = {}  # {frozenset([start, end]): generated_type}\ndef triplets_with_supertype(triplet_map, length=3):"
        },
        {
            "comment": "This code seems to be a part of a type system in a microgrid management system. It checks the length of triplet lists in a map and yields a new list with supertype added to each triplet. The `get_types` function returns either wire types or non-wire types depending on the input parameter, and `get_other_sets` gets other sets based on a given supertype. Lastly, `add_to_types` adds a new type to the map based on the given supertype.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_system.py\":105-140",
            "content": "    for supertype, triplet_list in triplet_map.items():\n        for triplet in triplet_list:\n            try:\n                assert len(triplet) == length\n            except:\n                logger_print()\n                logger_print(\"ERROR!\")\n                logger_print()\n                logger_print(triplet_map)\n                raise Exception(\n                    f\"Error when unpacking triplet map with length {length}.\",\n                )\n            yield (*triplet, supertype)\ndef get_types(is_wire):\n    if is_wire:\n        return wire_types\n    else:\n        return types\ndef get_other_sets(supertype, is_wire=False):\n    mtypes = get_types(is_wire)\n    other_sets = set([e for k in mtypes.keys() if k != supertype for e in types[k]])\n    return other_sets\ndef add_to_types(supertype, typename, is_wire=False):\n    mtypes = get_types(is_wire)\n    if mtypes.get(supertype, None) is None:\n        mtypes[supertype] = set()\n    if is_wire:\n        other_sets = set([e for k, v in types.items() for e in v])\n        wire_other_sets = get_other_sets(supertype, is_wire=is_wire)"
        },
        {
            "comment": "This code is checking for duplicate types in different categories and raising exceptions if found. It also creates Connectable, Unconnectable, and other type instances based on input parameters. The code seems to be part of a larger program that handles wire and device types within different supertype categories.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_system.py\":141-172",
            "content": "    else:\n        other_sets = get_other_sets(supertype)\n        wire_other_sets = set([e for k, v in wire_types.items() for e in v])\n    if typename not in other_sets:\n        if typename not in wire_other_sets:\n            mtypes[supertype].add(typename)\n        else:\n            raise Exception(\n                f\"{'Wire ' if is_wire else ''}Type {typename} in category {supertype} appeared to be duplicated with wire types.\"\n            )\n    else:\n        raise Exception(\n            f\"{'Wire ' if is_wire else ''}Type {typename} in category {supertype} appeared to be duplicated with device types.\"\n        )\ndef Connectable(wire_name):\n    return f\"\u53ef\u8fde\u63a5{wire_name}\"\ndef Unconnectable(wire_name):\n    return f\"\u4e0d\u53ef\u8fde\u63a5{wire_name}\"\nfor io, wire_name, supertype in triplets_with_supertype(io_to_wire, length=2):\n    start = IO(io)\n    end = Connectable(wire_name)\n    created = Unconnectable(wire_name)\n    add_to_types(supertype, start)\n    add_to_types(supertype, end, is_wire=True)\n    add_to_types(supertype, created, is_wire=True)"
        },
        {
            "comment": "This code defines a function called `transform_triplets` that takes in four parameters: triplets, is_io, forward, and backward. It returns a new list of tuples where each tuple contains the original triplet along with boolean values for is_io, forward, and backward.\n\nThe variable `triplets_config` contains a list of configurations for different types of triplets. Each configuration consists of four elements: a list of triplets, a boolean value for is_io, two boolean values for forward and backward direction.\n\nA loop iterates over each configuration in `triplets_config`, applies the transformations using `transform_triplets` function, and assigns the start and end nodes based on the boolean value of is_io. The rest of the code is missing due to the truncation.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_system.py\":174-207",
            "content": "    types_connectivity_matrix.update({frozenset([start, end]): created})\n# a = [(e, True) for e in triplets_with_supertype(io_coax_triplets)]\n# logger_print(a)\n# breakpoint()\ndef transform_triplets(triplets, is_io, forward, backward):\n    return [(e, is_io, forward, backward) for e in triplets_with_supertype(triplets)]\nfrom functools import reduce\ntriplets_config = [  # triplets, is_io, forward, backward\n    (source_coax_triplets, False, False, True),\n    (load_coax_triplets, False, True, False),\n    (source_and_load_coax_triplets, False, True, True),\n    #############################################\n    (io_storage_coax_triplets, True, True, False),\n]\nfor (i, o, wire_name, supertype), is_io, forward, backward in reduce(\n    lambda x, y: x + y,\n    [transform_triplets(*c) for c in triplets_config],\n):\n    if is_io:\n        start = IO(i)\n        end = IO(o)\n    else:\n        start = Input(i)\n        end = Output(o)\n    # logger_print(i,o, start, end,wire_name)\n    # breakpoint()\n    connectable_wire_name, unconnectable_wire_name = ("
        },
        {
            "comment": "This code is defining and updating types in a type system for a microgrid. It adds elements related to connectable and unconnectable wires, and updates the types_connectivity_matrix accordingly. The logger_print function logs the updated types dictionary.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_system.py\":208-244",
            "content": "        Connectable(wire_name),\n        Unconnectable(wire_name),\n    )\n    # if types.get(supertype, None) is None:\n    #     types[supertype] = set()\n    # other_sets = set([e for k in types.keys() if k!=supertype for e in types[k]])\n    # if \"\u50a8\u80fd\u7aef\" in start:\n    #     breakpoint()\n    add_to_types(supertype, start)\n    add_to_types(supertype, end)\n    add_to_types(supertype, connectable_wire_name, is_wire=True)\n    add_to_types(supertype, unconnectable_wire_name, is_wire=True)\n    types_connectivity_matrix.update({frozenset([start, end]): connectable_wire_name})\n    if forward:  # original\n        types_connectivity_matrix.update(\n            {frozenset([start, connectable_wire_name]): unconnectable_wire_name}\n        )\n    if backward:\n        types_connectivity_matrix.update(\n            {frozenset([end, connectable_wire_name]): unconnectable_wire_name}\n        )\n# logger_print(types)\n# {\n#     '\u6bcd\u7ebf\u8f93\u5165',\n#     '\u4e0d\u53ef\u8fde\u63a5\u6bcd\u7ebf',\n#     '\u53ef\u8fde\u63a5\u50a8\u80fd\u7aef\u6bcd\u7ebf',\n#     '\u4e0d\u53ef\u8fde\u63a5\u4f9b\u7535\u7aef\u6bcd\u7ebf',\n#     '\u6bcd\u7ebf\u8f93\u51fa',\n#     '\u4f9b\u7535\u7aef\u8f93\u51fa',\n#     '\u4e0d\u53ef\u8fde\u63a5\u50a8\u80fd\u7aef\u6bcd\u7ebf',\n#     '\u53cc\u5411\u53d8\u6d41\u5668\u8f93\u5165\u8f93\u51fa',"
        },
        {
            "comment": "This code reads a CSV file, \"\u8bbe\u5907\u63a5\u53e3-\u79bb\u7f51\u578b\u5fae\u7535\u7f51.csv\", and updates it to ensure each line contains the same number of columns. The file is then rewritten with the corrected lines. The resulting DataFrame, port_df, will likely be used further in the program's execution.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_system.py\":245-284",
            "content": "#     '\u53ef\u8fde\u63a5\u4f9b\u7535\u7aef\u6bcd\u7ebf',\n#     '\u50a8\u80fd\u7aef\u8f93\u5165\u8f93\u51fa',\n#     '\u53ef\u8fde\u63a5\u6bcd\u7ebf',\n#     '\u53d8\u6d41\u5668\u8f93\u5165'\n# }\nimport json\n# keys = []\n# with open(\"microgrid_device_params_intermediate.json\",'r') as f:\n#     data = json.load(f)\n#     for k,v in data.items():\n#         for k0, v0 in v.items():\n#             keys.append(k0)\n# logger_print(keys)\ncsv_path = \"\u8bbe\u5907\u63a5\u53e3-\u79bb\u7f51\u578b\u5fae\u7535\u7f51.csv\"\nfrom csv_utils import fix_csv_and_return_dataframe\nport_df = fix_csv_and_return_dataframe(csv_path)\n# lines = []\n# line_sep_count_list = []\n# with open(csv_path, \"r\") as f:\n#     for line in f.readlines():\n#         line_sep_count = line.count(\",\")\n#         if line_sep_count == 0:\n#             continue\n#         lines.append(line)\n#         line_sep_count_list.append(line_sep_count)\n# line_sep_count_max = max(line_sep_count_list)\n# for index, line_sep_count in enumerate(line_sep_count_list):\n#     lines[index] = lines[index].strip() + \",\" * (line_sep_count_max - line_sep_count)\n# with open(csv_path, \"w+\") as f:\n#     for line in lines:\n#         f.write(line + \"\\n\")\n# port_df = pandas.read_csv(csv_path, header=None, on_bad_lines=\"warn\")"
        },
        {
            "comment": "This code defines mappings for device types and ports, including energy devices, load devices, storage devices, and their input/output types. It creates dictionaries for each type of device, converts the values to Input, Output or IO based on the key, and combines them into a single dictionary 'device_with_single_port_to_port_type'. The set 'mapped_types' will be used later.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_system.py\":286-333",
            "content": "# logger_print(port_df)\nimport numpy\nmycat = None\ndevice_port_dict = {}\nmydevice = None\ncontent_split = True\n# \u80fd\u6e90\u7aef\noutput_device_with_single_port_to_port_type = revert_dict(\n    {\n        \"\u67f4\u6cb9\": [\"\u67f4\u6cb9\"],\n        \"\u4f9b\u7535\u7aef\": [\"\u5149\u4f0f\u53d1\u7535\", \"\u98ce\u529b\u53d1\u7535\", \"\u67f4\u6cb9\u53d1\u7535-\u7535\u63a5\u53e3\"],\n        \"\u7535\u6bcd\u7ebf\": [\"\u53d8\u6d41\u5668-\u7535\u8f93\u51fa\", \"\u4f20\u8f93\u7ebf-\u7535\u8f93\u51fa\"],\n        \"\u53d8\u538b\u5668\": [\"\u53d8\u538b\u5668-\u7535\u8f93\u51fa\"],\n    }\n)\n# \u8d1f\u8377\u7aef\ninput_device_with_single_port_to_port_type = revert_dict(\n    {\n        \"\u8d1f\u8377\u7535\": [\"\u7535\u8d1f\u8377\"],\n        \"\u67f4\u6cb9\": [\"\u67f4\u6cb9\u53d1\u7535-\u71c3\u6599\u63a5\u53e3\"],\n        \"\u7535\u6bcd\u7ebf\": [\"\u53d8\u538b\u5668-\u7535\u8f93\u5165\", \"\u4f20\u8f93\u7ebf-\u7535\u8f93\u5165\"],\n        \"\u53d8\u6d41\u5668\": [\"\u53d8\u6d41\u5668-\u7535\u8f93\u5165\"],\n    }\n)\n# \u50a8\u80fd\u7aef\nio_device_with_single_port_to_port_type = revert_dict(\n    {\"\u7535\u50a8\u80fd\u7aef\": [\"\u9502\u7535\u6c60\"], \"\u53cc\u5411\u53d8\u6d41\u5668\u50a8\u80fd\u7aef\": [\"\u53cc\u5411\u53d8\u6d41\u5668-\u50a8\u80fd\u7aef\"], \"\u53cc\u5411\u53d8\u6d41\u5668\u7ebf\u8def\u7aef\": [\"\u53cc\u5411\u53d8\u6d41\u5668-\u7ebf\u8def\u7aef\"]}\n)\ndevice_with_single_port_to_port_type = {\n    k: Input(v) for k, v in input_device_with_single_port_to_port_type.items()\n}\ndevice_with_single_port_to_port_type.update(\n    {k: Output(v) for k, v in output_device_with_single_port_to_port_type.items()}\n)\ndevice_with_single_port_to_port_type.update(\n    {k: IO(v) for k, v in io_device_with_single_port_to_port_type.items()}\n)\nmapped_types = set()"
        },
        {
            "comment": "This code populates a dictionary called `device_port_dict` based on the rows of `port_df`. It checks if the category (cat) and content columns are not NaN or None. If they aren't, it assigns `mycat`, initializes a nested dictionary for each unique `mycat`, and handles cases where the content column is NaN or None by setting `content_split` accordingly. Finally, it retrieves the port type from `device_with_single_port_to_port_type` and updates the corresponding dictionary entries in `device_port_dict`.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_system.py\":334-361",
            "content": "type_to_device_LUT = {}\nlogger_print(device_with_single_port_to_port_type)\nfor index, row in port_df.iterrows():\n    # logger_print(row.tolist())\n    # logger_print(row.tolist())\n    cat, content = row.tolist()[:2]\n    logger_print([cat, content])\n    if not (cat is numpy.nan or cat is None):\n        mycat = cat\n        device_port_dict[mycat] = {}  # init\n    if mycat:\n        if content is numpy.nan or content is None:\n            content_split = True\n        elif content_split:\n            content_split = False\n            mydevice = content.replace(\"\uff08\", \"(\").split(\"(\")[0]\n            device_port_dict[mycat][mydevice] = {}\n        else:\n            # append port?\n            port_type = device_with_single_port_to_port_type.get(mydevice, None)\n            if port_type:\n                device_with_single_port_to_port_type[mydevice] = None\n            else:\n                port_id = f\"{mydevice}-{content}\"\n                port_type = device_with_single_port_to_port_type.get(port_id, None)\n                if port_type:"
        },
        {
            "comment": "The code maps device ports to their types and updates a LUT. If no port type is defined, it raises an exception with the relevant details. It also defines a function for printing content with a banner and saves it to a JSON file.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_system.py\":362-385",
            "content": "                    device_with_single_port_to_port_type[port_id] = None\n            if port_type is not None:\n                device_port_dict[mycat][mydevice][content] = port_type\n                mapped_types.add(port_type)\n                type_to_device_LUT[port_type] = type_to_device_LUT.get(\n                    port_type, []\n                ) + [f\"{mydevice}-{content}\"]\n            else:\n                # logger_print(device_port_dict)\n                # breakpoint()\n                raise Exception(\n                    \"No port type definition for:\", (mycat, mydevice, content)\n                )\ndef print_with_banner(content, hyphen_saved_name, prefix):\n    banner = hyphen_saved_name.strip().replace(\"_\", \" \").upper().strip()\n    logger_print(f\"=========[{banner}]=========\")\n    logger_print(content)\n    filepath = f\"{prefix}_{hyphen_saved_name.strip()}.json\"\n    logger_print(\"SAVING TO:\", filepath)\n    with open(filepath, \"w+\") as f:\n        str_content = json.dumps(content, indent=4, ensure_ascii=False)"
        },
        {
            "comment": "This code writes device port type mapping, connectivity matrix, and structured data to a file, then compares the mapped types with the original types. It ensures no differences exist between the two sets before proceeding.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_system.py\":386-412",
            "content": "        f.write(str_content)\n# logger_print(\"=========[DEVICE PORT TYPE MAPPING]=========\")\nprint_with_banner(device_port_dict, \"device_port_type_mapping\", \"microgrid\")\n# logger_print(\"=========[CONNECTIVITY MATRIX]=========\")\ntypes_connectivity_matrix_for_json = {\n    \"{}_{}\".format(*list(k)): v for k, v in types_connectivity_matrix.items()\n}\nprint_with_banner(\n    types_connectivity_matrix_for_json, \"connectivity_matrix\", \"microgrid\"\n)  # must convert this one.\n# logger_print(\"=========[DEVICE PORT TYPES]=========\")\n# print_with_banner(types,'device_port_types',\"microgrid\")\n# logger_print(\"=========[ALL TYPES STRUCTURED]=========\")\nall_types_structured = {\n    \"\u8bbe\u5907\": {k: list(v) for k, v in types.items()},\n    \"\u8fde\u63a5\u7ebf\": {k: list(v) for k, v in wire_types.items()},\n}\nprint_with_banner(all_types_structured, \"all_types_structured\", \"microgrid\")\nmtypes = set([e for k, v in types.items() for e in v])\ndiff_1 = mapped_types.difference(mtypes)\ndiff_2 = mtypes.difference(mapped_types)\nif not (diff_1 == set() and diff_2 == set()):"
        },
        {
            "comment": "The code is checking the equality between mapped types and existing device types. It creates a graph and modifies some type names to add unique identifiers before adding them to the graph as nodes and edges. The purpose seems to ensure distinct identities for the types within the network. If the mapped types do not match with existing device types, an exception is raised.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_system.py\":413-453",
            "content": "    logger_print(\"MAPPED TYPES UNIQ:\", diff_1)\n    logger_print(\"DEVICE TYPES UNIQ:\", diff_2)\n    raise Exception(\"Mapped types does not equal to existing device types\")\n# now the final: validity check!\n# reachable?\nimport networkx\nG = networkx.Graph()\nall_types = mtypes.union(set([e for k, v in wire_types.items() for e in v]))\n# for node_name in all_types:\n#     G.add_node(node_name)\nimport copy\ndef alter_type_name(type_name):\n    logger_print(\"ALTER TYPE NAME:\", type_name)\n    if type_name.startswith(\"\u4e0d\u53ef\u8fde\u63a5\"):\n        if type_name.endswith(\"]\"):\n            type_name = type_name[:-4]\n        result = copy.copy(type_name) + f\"[{get_uniq_hash()}]\"\n        # breakpoint()\n    else:\n        result = type_name\n    # logger_print(\"RESULT?\", result)\n    # breakpoint()\n    return result\nfor fzset, wire_name in types_connectivity_matrix.items():\n    # logger_print(fzset, wire_name)\n    start, end = list(fzset)\n    start = alter_type_name(start)\n    end = alter_type_name(end)\n    wire_name = alter_type_name(wire_name)\n    G.add_edge(start, wire_name)"
        },
        {
            "comment": "This code is defining a function `plot_graph` that takes a graph (G) as input and creates a visual representation of the graph using Matplotlib. The graph nodes will be colored yellow, edges blue, and font color red. The font will use the \"Songti SC\" font. The size of the figure is adjustable by setting the `width` and `height` parameters. The function also saves the plot as a figure in the specified file path (`figure_path`) if `plot_only=False`, otherwise it only plots the graph without saving it.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_system.py\":454-487",
            "content": "    G.add_edge(wire_name, end)\n# logger_print(G.nodes)\nfor node_name in G.nodes:\n    neighbors = G.neighbors(node_name)\n    logger_print(\"NODE:\", node_name)\n    logger_print(\"    NEIGHBOR:\", [n for n in neighbors])\n# import matplotlib.font_manager as fm\n# font_path = \"/Volumes/CaseSensitive/pyjom/tests/render_and_recognize_long_text_to_filter_unwanted_characters/get_and_merge_fonts/GoNotoCurrent.ttf\"\n# font_path = \"/Users/jamesbrown/Desktop/works/jubilant-adventure/GoNotoCurrent.ttf\"\n# WRYH = fm.FontProperties(fname = '/Users/liuhuanshuo/Desktop/\u53ef\u89c6\u5316\u56fe\u9274/font/WeiRuanYaHei-1.ttf')\nimport matplotlib\nmatplotlib.rcParams[\"font.sans-serif\"] = [\"Songti SC\"]\nimport matplotlib.pyplot as plt\ndef plot_graph(G, figure_path: str, width=10, height=20, plot_only=False):\n    plt.figure(figsize=(width, height))\n    draw_options = {\n        \"node_color\": \"yellow\",\n        \"node_size\": 0,\n        \"font_color\": \"red\",\n        \"edge_color\": \"blue\",\n        # \"fontproperties\":WRYH\n    }\n    networkx.draw_kamada_kawai(G, with_labels=True, font_weight=\"bold\", **draw_options)"
        },
        {
            "comment": "This code saves a graph figure and then creates a networkx Graph object. It defines a function to lookup device types based on type names, iterates over connectivity matrix, looks up device types for start and end nodes, adds edges to the graph G1 with altered type names, and finally adds an edge between modified start and end nodes and the wire name.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_system.py\":489-528",
            "content": "    logger_print(\"Saving graph figure to:\", figure_path)\n    plt.savefig(figure_path)\n    if not plot_only:\n        plt.show()\nfigure_path = \"type_system.png\"\nplot_graph(G, figure_path, plot_only=PLOT_ONLY)\nG1 = networkx.Graph()\ndef lookup_type_to_device(type_name):\n    result = [e.split(\"-\") for e in type_to_device_LUT.get(type_name, [])]\n    if result == []:\n        return [(None, type_name)]\n    return result\nfor fzset, wire_name in types_connectivity_matrix.items():\n    # logger_print(fzset, wire_name)\n    start, end = list(fzset)\n    for ds, ds_port in lookup_type_to_device(start):\n        for de, de_port in lookup_type_to_device(end):\n            if ds:\n                mstart = ds\n            else:\n                mstart = ds_port\n            if de:\n                mend = de\n            else:\n                mend = de_port\n            mstart = alter_type_name(mstart)\n            mend = alter_type_name(mend)\n            wire_name = alter_type_name(wire_name)\n            G1.add_edge(mstart, wire_name)\n            G1.add_edge(mend, wire_name)"
        },
        {
            "comment": "This code generates a device connectivity matrix graph and saves it as \"device_connectivity_matrix.png\" using the plot_graph function, with optional plotting restrictions specified by PLOT_ONLY parameter.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/type_system.py\":530-531",
            "content": "figure_path = \"device_connectivity_matrix.png\"\nplot_graph(G1, figure_path, plot_only=PLOT_ONLY)"
        }
    ]
}