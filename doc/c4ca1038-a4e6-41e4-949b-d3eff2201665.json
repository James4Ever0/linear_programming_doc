{
    "summary": "This code retrieves DSL files and ensures corresponding JSON files, defines fixtures for a test suite using TextX to parse sample code with specified grammar, and tests the parsing functionality.",
    "details": [
        {
            "comment": "The code retrieves all DSL files from a directory and ensures that there is a corresponding JSON file for each DSL file. It creates dictionaries of the DSL paths and parsed output paths based on their respective marks. This code seems to be part of a test suite, likely testing the functionality of parsing DSLs into JSON outputs.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/dsl_parser/test/test_dsl.py\":0-35",
            "content": "from pytest import fixture, FixtureRequest\nimport os\nimport json\nimport sys\nsys.path.append(\"../\")\nfrom ast_utils import walkModel\nsample_code_dir = \"sample_code\"\npath_to_mark = lambda path: os.path.basename(path).split(\".\")[0]\nsample_code_paths = [\n    os.path.join(sample_code_dir, code_path)\n    for code_path in os.listdir(sample_code_dir)\n    if code_path.endswith(\".dsl\")\n]\nsample_code_parsed_paths = [\n    os.path.join(sample_code_dir, code_parsed_paths)\n    for code_parsed_paths in os.listdir(sample_code_dir)\n    if code_parsed_paths.endswith(\".json\")\n]\nsample_code_marks = [\n    os.path.basename(rel_code_path).split(\".\")[0] for rel_code_path in sample_code_paths\n]\n# check if all code has parsed output\nfor mark in sample_code_marks:\n    assert (\n        os.path.join(sample_code_dir, mark + \".json\") in sample_code_parsed_paths\n    ), f\"Missing parsed output: {mark}\"\nsample_code_parsed_paths_dict = {path_to_mark(p): p for p in sample_code_parsed_paths}\nsample_code_paths_dict = {path_to_mark(p): p for p in sample_code_paths}"
        },
        {
            "comment": "This code defines fixtures for a test suite and uses TextX to parse sample code according to the specified grammar. The `metamodel` fixture loads the grammar from a file, while the `sample_code` fixture reads both the original code and its expected parsed result from separate files given by the `sample_code_marks`. The `test_parse_code` function uses the loaded metamodel to parse a sample of code and asserts that the resulting model matches the expected parsed JSON.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/dsl_parser/test/test_dsl.py\":37-74",
            "content": "from collections import namedtuple\nCPJ = namedtuple(\"CPJ\", [\"code\", \"parsed_json\"])\nimport textx\n@fixture\ndef metamodel():\n    grammar_path = \"../grammar.tx\"\n    with open(grammar_path, \"r\") as f:\n        grammar_content = f.read()\n    mm = textx.metamodel_from_str(grammar_content)\n    return mm\n@fixture(params=sample_code_marks)\ndef sample_code(request: FixtureRequest):\n    mark = request.param\n    code_path = sample_code_paths_dict[mark]\n    parsed_path = sample_code_parsed_paths_dict[mark]\n    print(\"READING CODE AT:\", code_path)\n    with open(code_path, \"r\") as f:\n        code_content = f.read()\n    with open(parsed_path, \"r\") as f:\n        parsed_content = f.read()\n        parsed_json = json.loads(parsed_content)\n    return CPJ(code=code_content, parsed_json=parsed_json)\nfrom textx.metamodel import TextXMetaModel\ndef test_parse_code(sample_code: CPJ, metamodel: TextXMetaModel):\n    model = metamodel.model_from_str(sample_code.code)\n    tree = walkModel(model)\n    target_tree = sample_code.parsed_json\n    assert tree == target_tree"
        }
    ]
}