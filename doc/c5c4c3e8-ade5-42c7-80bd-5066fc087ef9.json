{
    "summary": "The code imports modules, defines paths and formats, retrieves table data, checks microgrid devices, processes nested tables, handles exceptions, updates dictionaries, converts units, categorizes units, populates output data, ensures unit compatibility, and writes JSON data.",
    "details": [
        {
            "comment": "The code imports necessary modules, defines paths and constants for device parameter parsing and processing. It uses dictionaries to specify formats and units, and a makefile to define inputs and outputs for the process. The code also utilizes unit conversion and translation functions from external libraries.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/parse_units_and_names.py\":0-45",
            "content": "from log_utils import logger_print\n# main_path = \"device_params_intermediate.json\" # data parse here. since we are changing the main table.\n# device_name_path = \"microgrid_device_params_intermediate.json\" # just for reference.\ndevice_data_path_base = \"device_params_intermediate.json\"\nfrom render_type_utils import (\n    TYPE_UTILS_MICROGRID_PORTS_DATA,\n    TYPE_UTILS_EXTRA_PORTS_DATA,\n)\nmicrogrid_device_port_path = \"microgrid_v2_device_port_type_mapping.json\"\n# microgrid_device_port_path = \"microgrid_device_port_type_mapping.json\" # shall you update this to v2.\noutput_path = \"microgrid_jinja_param_base.json\"\nMAKEFILE = dict(\n    inputs=[\n        device_data_path_base,\n        #  microgrid_device_port_path\n    ],\n    outputs=[output_path],\n    args=[],\n)\nimport pint\nimport json\nimport rich\nfrom unit_utils import (\n    unitFactorCalculator,\n    ureg,\n    standard_units,\n    getSingleUnitConverted,\n    translateUnit,\n)\nEXCEL = \"\u5d4c\u5957\"\nMEASURE = \"\u8c03\u5ea6\"\nTABLE_FORMATS = {\n    \"\u71c3\u6cb9\u6d88\u8017\u7387\": {str(ureg.Unit(\"m3 / kWh\")): (\"\u8d1f\u8f7d\u7387\", \"%\")},\n    \"\u71c3\u6c14\u6d88\u8017\u7387\": {str(ureg.Unit(\"m3 / kWh\")): (\"\u8d1f\u8f7d\u7387\", \"%\")},"
        },
        {
            "comment": "Code defines a function to retrieve table formats based on key and unit, reads device data and port dictionary from JSON files, checks for microgrid devices in the device_whitelist, and returns the data.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/parse_units_and_names.py\":46-88",
            "content": "}\ndef get_table_format(k, u):\n    try:\n        t = TABLE_FORMATS\n        return t[k][str(u)]  # name, unit\n    except:\n        raise Exception(\"No table format for\", k, u)\nwith open(device_data_path_base, \"r\") as f:\n    device_data = json.load(f)\nwith open(microgrid_device_port_path, \"r\") as f:\n    port_dict = json.load(f)\ndata = {}\nfrom device_whitelist import device_whitelist\n# device_whitelist = ['\u67f4\u6cb9', '\u7535\u8d1f\u8377', '\u5149\u4f0f\u53d1\u7535', '\u98ce\u529b\u53d1\u7535', '\u67f4\u6cb9\u53d1\u7535', '\u9502\u7535\u6c60', '\u53d8\u538b\u5668', '\u53d8\u6d41\u5668', '\u53cc\u5411\u53d8\u6d41\u5668', '\u4f20\u8f93\u7ebf']\nall_microgrid_device_keys = []  # replace this with something else.\nfor port_dict in [TYPE_UTILS_MICROGRID_PORTS_DATA, TYPE_UTILS_EXTRA_PORTS_DATA]:\n    for k, v in port_dict.items():\n        for k1, v1 in v.items():\n            # if True:\n            if k1 in device_whitelist:\n                k0 = f\"{k}-{k1}\"\n                device_whitelist.append(k1)\n                all_microgrid_device_keys.append(k0)\n# logger_print(device_whitelist)\n# exit()\ndata = {}\ndata_is_excel = {}\ndef none_fallback(e):\n    if type(e) != str:\n        return \"\"\n    return e"
        },
        {
            "comment": "This code is iterating through device data, extracting and parsing specific key-value pairs. If a certain key is found in all_microgrid_device_keys, it creates lists to store the values and their corresponding excel flags, otherwise it continues without doing anything. This process does not include other elements such as busbars and busbar taps. The code then prints the data regarding excel usage.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/parse_units_and_names.py\":91-125",
            "content": "# breakpoint()\nfor k, v in device_data.items():\n    for k1, v1 in v.items():\n        k1 = k1.replace(\"\uff08\", \"(\").split(\"(\")[0].strip()\n        k0 = f\"{k}-{k1}\"\n        # if k1 == '\u4f20\u8f93\u7ebf': breakpoint()\n        if (\n            k0 in all_microgrid_device_keys\n        ):  # all_microgrid_device_keys does not have \u4f20\u8f93\u7ebf\n            vlist = []\n            v_is_excel_list = []\n            for v2 in v1:\n                v2 = [none_fallback(e) for e in v2]\n                val = v2[0].strip()\n                if val == \"-\":\n                    continue\n                v_is_excel = (EXCEL in v2[1]) or (EXCEL in v2[2])\n                v_is_measured = MEASURE in v2[2]\n                if not v_is_measured:\n                    vlist.append(val)\n                    v_is_excel_list.append(v_is_excel)\n            data[k] = data.get(k, {})\n            data[k][k1] = vlist\n            data_is_excel[k] = data_is_excel.get(k, {})\n            data_is_excel[k][k1] = v_is_excel_list\n        else:\n            continue\n# \u6ca1\u6709\u5176\u4ed6\u7c7b\u5143\u4ef6\uff1a\u6bcd\u7ebf\u548c\u6bcd\u7ebf\u63a5\u53e3\n# logger_print(data_is_excel)"
        },
        {
            "comment": "This code appears to be parsing various unit types and their corresponding names from a JSON file. The units include Area, Load, Efficiency, Parameter, and Count. These units likely represent different attributes or specifications of various devices in a microgrid system. The code is also categorizing these units into different categories such as CHAR_TYPE, COMMENT_TYPE, META_TYPE, and SKIP_TYPE.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/parse_units_and_names.py\":126-178",
            "content": "# breakpoint()\n# cat -> name -> [bool]\n# \u9502\u7535\u6c60\n# \u5e74\u653e\u7535\u91cf\u9700\u6c42(kWh) * \u6362\u82af\u5468\u671f(\u5e74) <= \u7535\u6c60\u673a\u7ec4\u5bb9\u91cf(kWh) * \u5faa\u73af\u5bff\u547d(\u5e74) * 0.85\n# \u4f5c\u4e3a\u7535\u6c60\u6570\u91cf\u9650\u5236\u7684\u4e00\u90e8\u5206\nimport parse\n# import pint\n# with open(path, \"r\") as f:\n#     data = json.load(f)\nkeys = list(data.keys())\nlogger_print(keys)\nlogger_print(data)\nCHAR_TYPE = [\"\u751f\u4ea7\u5382\u5546\", \"\u8bbe\u5907\u578b\u53f7\"]\nCOMMENT_TYPE = [\"\u4ece\u6587\u4ef6\u5bfc\u5165\u3001\u4fdd\u5b58\u6570\u636e\u3001\u4ece\u5178\u578b\u5e93\u5bfc\u5165\"]\nMETA_TYPE = [\n    \"\u8bbe\u5907\u989d\u5b9a\u8fd0\u884c\u53c2\u6570\",\n    \"\u8bbe\u5907\u7ecf\u6d4e\u6027\u53c2\u6570\",\n    \"\u8bbe\u5907\u8fd0\u884c\u7ea6\u675f\",\n]  # parse this?\nSKIP_TYPE = [\"\u8bbe\u8ba1\u89c4\u5212\u62d3\u6251\u56fe\u53f3\u4fa7\u83dc\u5355\", \"\u8bbe\u8ba1\u89c4\u5212\u7cfb\u7edf-\u62d3\u6251\u56fe\u53f3\u4fa7\u83dc\u5355\"]\nBASE_TRANSLATION_TABLE_WITH_BASE_UNIT = {\n    \"Area\": (\n        \"m2\",\n        {\"\": [\"\u5149\u4f0f\u677f\u9762\u79ef\"], \"MaxInstall-\": [\"\u6700\u5927\u5b89\u88c5\u9762\u79ef\"], \"MinInstall-\": [\"\u6700\u5c0f\u5b89\u88c5\u9762\u79ef\"]},\n    ),\n    \"Load\": (\"percent\", {\"\": [\"\u8d1f\u8f7d\u7387\"]}),\n    \"Efficiency\": (\n        \"one\",\n        {\n            \"HydrogenGeneration-\": [\"\u5236\u6c22\u6548\u7387\"],\n            \"PowerConversion-\": [\"\u7535\u7535\u8f6c\u6362\u6548\u7387\"],\n            \"HeatRecycle-\": [\"\u70ed\u91cf\u56de\u6536\u6548\u7387\"],\n            \"Charge-\": [\"\u5145\u80fd\u6548\u7387\"],\n            \"Discharge-\": [\"\u653e\u80fd\u6548\u7387\"],\n            \"\": [\"\u6548\u7387\"],\n        },\n    ),\n    \"Parameter\": (\"one\", {\"Power-\": [\"\u529f\u7387\u56e0\u6570\"], \"LoadRedundancy-\": [\"\u53d8\u538b\u5668\u5197\u4f59\u7cfb\u6570\"]}),\n    \"Count\": (\n        \"\u53f0\",\n        {\"Device-\": [\"\u5b89\u88c5\u53f0\u6570\"], \"MaxDevice-\": [\"\u6700\u5927\u5b89\u88c5\u53f0\u6570\"], \"MinDevice-\": [\"\u6700\u5c0f\u5b89\u88c5\u53f0\u6570\"]},"
        },
        {
            "comment": "This code defines various units and names used in the microgrid system. It includes units like \"kW\" for power, \"km\" for length, and \"percent\" for rate, startup limit, and power consumption variation rate. The code also contains translations for different languages and specific terms related to power generation, gas consumption, wind speed, diesel usage, and battery charging/discharging rates.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/parse_units_and_names.py\":179-211",
            "content": "    ),\n    \"Length\": (\"km\", {\"\": [\"\u957f\u5ea6\"]}),\n    \"Power\": (\n        \"kW\",\n        {\n            \"RatedInput-\": [\"\u989d\u5b9a\u8f93\u5165\u529f\u7387\"],\n            \"Rated-\": [\"\u989d\u5b9a\u529f\u7387\", \"\u989d\u5b9a\u53d1\u7535\u529f\u7387\", \"\u53d8\u538b\u5668\u5bb9\u91cf\"],\n            \"UnitRated-\": [\"\u7ec4\u4ef6\u989d\u5b9a\u529f\u7387\"],\n            \"Max-\": [\"\u6700\u5927\u53d1\u7535\u529f\u7387\"],\n            \"Cutout-\": [\"\u5207\u51fa\u529f\u7387\"],\n        },\n    ),\n    \"Rate\": (\n        \"one\",\n        {\"HotWaterToElectricity-\": [\"\u7f38\u5957\u6c34\u70ed\u7535\u6bd4\"], \"HotGasToElectricity-\": [\"\u70df\u6c14\u70ed\u7535\u6bd4\"]},\n    ),\n    \"HydrogenGenerationStartupRate\": (\"percent\", {\"\": [\"\u5236\u6c22\u542f\u52a8\u529f\u7387\u6bd4\u503c\"]}),\n    \"WindSpeed\": (\"m/s\", {\"Rated-\": [\"\u989d\u5b9a\u98ce\u901f\"], \"Min-\": [\"\u5207\u5165\u98ce\u901f\"], \"Max-\": [\"\u5207\u51fa\u98ce\u901f\"]}),\n    \"DieselToPower\": (\"L/kWh\", {\"\": [\"\u71c3\u6cb9\u6d88\u8017\u7387\"]}),\n    \"NaturalGasToPower\": (\"m3/kWh\", {\"\": [\"\u71c3\u6c14\u6d88\u8017\u7387\"]}),\n    \"StartupLimit\": (\"percent\", {\"Power-\": [\"\u542f\u52a8\u529f\u7387\u767e\u5206\u6bd4\"]}),\n    \"PowerConsumptionVariationRate\": (\"percent\", {\"\": [\"\u7528\u7535\u6ce2\u52a8\u7387\"]}),\n    \"DeltaLimit\": (\n        \"one/second\",\n        {\n            \"\": [\"\u722c\u5761\u7387\"],\n            \"Power-\": [\n                \"\u53d1\u7535\u722c\u5761\u7387\",\n            ],\n            \"Battery-\": [\"\u7535\u6c60\u5145\u653e\u7535\u500d\u7387\"],\n        },\n    ),  # two unit system.\n    \"SOC\": (\"percent\", {\"Min-\": [\"\u6700\u5c0fSOC\"], \"Max-\": [\"\u6700\u5927SOC\"], \"Init-\": [\"\u521d\u59cbSOC\"]}),"
        },
        {
            "comment": "This code defines various cost and decay parameters for microgrid components, such as storage decay, transfer decay, build base cost, and cost per capacity. It also includes details like lifecycle counts and design life for different components. The code is in Chinese.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/parse_units_and_names.py\":212-234",
            "content": "    \"StorageDecay\": (\"percent/hour\", {\"Battery-\": [\"\u5b58\u50a8\u8870\u51cf\"]}),\n    \"TransferDecay\": (\"kW/km\", {\"Power-\": [\"\u80fd\u91cf\u8870\u51cf\u7cfb\u6570\"]}),\n    \"BuildBaseCost\": (\"\u4e07\u5143\", {\"\": [\"\u5efa\u8bbe\u8d39\u7528\u57fa\u6570\"]}),\n    \"CostPerKilowatt\": (\"\u4e07\u5143/kW\", {\"\": [\"\u91c7\u8d2d\u6210\u672c\"], \"Build-\": [\"\u5efa\u8bbe\u8d39\u7528\u7cfb\u6570\"]}),\n    \"CostPerCapacity\": (\"\u4e07\u5143/kWh\", {\"\": [\"\u91c7\u8d2d\u6210\u672c\"], \"Build-\": [\"\u5efa\u8bbe\u8d39\u7528\u7cfb\u6570\"]}),\n    \"CostPerKilometer\": (\"\u4e07\u5143/km\", {\"\": [\"\u91c7\u8d2d\u6210\u672c\"], \"Build-\": [\"\u5efa\u8bbe\u8d39\u7528\u7cfb\u6570\"]}),\n    \"CostPerMachine\": (\"\u4e07\u5143/\u53f0\", {\"\": [\"\u91c7\u8d2d\u6210\u672c\"], \"Build-\": [\"\u5efa\u8bbe\u8d39\u7528\u7cfb\u6570\"]}),\n    \"CostPerYearPerMachine\": (\n        \"\u4e07\u5143/(\u53f0*\u5e74)\",\n        {\n            \"\": [\"\u56fa\u5b9a\u7ef4\u62a4\u6210\u672c\"],\n        },\n    ),\n    \"CostPerYearPerKilowatt\": (\"\u4e07\u5143/(kW*\u5e74)\", {\"\": [\"\u56fa\u5b9a\u7ef4\u62a4\u6210\u672c\"]}),\n    \"CostPerYearPerCapacity\": (\"\u4e07\u5143/(kWh*\u5e74)\", {\"\": [\"\u56fa\u5b9a\u7ef4\u62a4\u6210\u672c\"]}),\n    \"VariationalCostPerWork\": (\"\u5143/kWh\", {\"\": [\"\u53ef\u53d8\u7ef4\u62a4\u6210\u672c\"]}),\n    # \"VariationalCostPerVolume\": (\"\u5143/m3\", {\"\": [\"\u53ef\u53d8\u7ef4\u62a4\u6210\u672c\"]}),\n    \"CostPerYearPerKilometer\": (\"\u4e07\u5143/(km*\u5e74)\", {\"\": [\"\u7ef4\u62a4\u6210\u672c\"]}),\n    \"Life\": (\"\u5e74\", {\"\": [\"\u8bbe\u8ba1\u5bff\u547d\"], \"Battery-\": [\"\u7535\u6c60\u6362\u82af\u5468\u671f\"]}),\n    \"LifetimeCycleCount\": (\"one\", {\"\": [\"\u7b49\u6548\u5b8c\u5168\u5faa\u73af\u6b21\u6570\"]}),\n    \"Capacity\": (\n        \"kWh\",\n        {"
        },
        {
            "comment": "This code checks the units in the BASE_TRANSLATION_TABLE_WITH_BASE_UNIT and ensures they are within acceptable limits. It uses unitFactorCalculator to convert and compare the original unit with a standard unit, raising an exception if the magnitude is not 1. The function parse_convert_string takes a convert_string argument, which contains either one or no hyphen and is expected to be empty if it contains no hyphen.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/parse_units_and_names.py\":235-267",
            "content": "            \"Rated-\": [\"\u989d\u5b9a\u5bb9\u91cf\"],\n            \"MaxTotal-\": [\"\u6700\u5927\u8bbe\u5907\u5bb9\u91cf\"],\n            \"MinTotal-\": [\"\u6700\u5c0f\u8bbe\u5907\u5bb9\u91cf\"],\n            \"Total-\": [\"\u8bbe\u5907\u5bb9\u91cf\"],\n            \"TotalDischarge-\": [\"\u751f\u547d\u5468\u671f\u603b\u653e\u7535\u91cf\"],\n        },\n    ),\n}  # EnglishName: (ReferenceBaseUnit, {convert_string:[ChineseName, ...], ...})\n# checking these units.\n# they shall never be going too far.\n# for k, v in BASE_TRANSLATION_TABLE_WITH_BASE_UNIT.items():\n#     v_unit = v[0]\n#     mag, munit = unitFactorCalculator(ureg, standard_units, v_unit)\n#     if mag != 1:\n#         logger_print(\"-\"*20)\n#         logger_print(\"ERROR! MAGNITUDE:\", mag)\n#         logger_print(\"KEY:\", k)\n#         logger_print(\"ORIGINAL UNIT:\", v_unit)\n#         logger_print(\"CONVERTED UNIT:\", munit)\n#         logger_print(\"-\"*20)\n#         raise Exception(\"Standard Unit Error\")\n# TODO: check if units are compatible. set standard units.\n##################\n# convert_string: \"[prefix][-][suffix]\"\n# contain either 1 or no hyphen.\n# if contain no hyphen, it must be empty string.\ndef parse_convert_string(convert_string: str):"
        },
        {
            "comment": "The code segment is responsible for parsing the convert string, which contains a prefix and suffix separated by hyphens. It checks if there's only one hyphen in the convert string, and then determines whether the prefix or suffix is at the start or end of the string. If there are more than one hyphens or an empty string is passed, it raises exceptions. The code also populates a translation table using the prefix, suffix, base, and unit information from the input dictionary.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/parse_units_and_names.py\":268-298",
            "content": "    convert_string = convert_string.strip()\n    hyphen_count = convert_string.count(\"-\")\n    prefix = \"\"\n    suffix = \"\"\n    if hyphen_count == 1:\n        if convert_string.startswith(\"-\"):\n            suffix = convert_string.strip(\"-\")\n        elif convert_string.endswith(\"-\"):\n            prefix = convert_string.strip(\"-\")\n        else:  # in the middle!\n            prefix, suffix = convert_string.split(\"-\")\n        prefix = prefix.strip()\n        suffix = suffix.strip()\n    elif hyphen_count == 0:\n        if len(convert_string) != 0:\n            raise Exception(\"You should pass an empty string this time\")\n    else:\n        raise Exception(\"Invalid convert string:\", convert_string)\n    return prefix, suffix\nTRANSLATION_TABLE = {}\n# BASE_TRANSLATION_TABLE = {}\nBASE_CLASS_TO_UNIT_TABLE = {}\nfor k, v in BASE_TRANSLATION_TABLE_WITH_BASE_UNIT.items():\n    for k1, v1 in v[1].items():\n        prefix, suffix = parse_convert_string(k1)\n        k0 = prefix + k.strip() + suffix\n        # BASE_TRANSLATION_TABLE.update({k0: v1})"
        },
        {
            "comment": "This code updates dictionaries, defining unit translations and base class to unit mappings. It processes nested table headings and creates a function for adding range translations.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/parse_units_and_names.py\":299-333",
            "content": "        # BASE_CLASS_TO_UNIT_TABLE.update({k0: v[0]})\n        BASE_CLASS_TO_UNIT_TABLE[k0] = v[0]\n        for v2 in v1:\n            TRANSLATION_TABLE[v2] = TRANSLATION_TABLE.get(v2, []) + [k0]\n        # BASE_CLASS_TO_UNIT_TABLE[k] = BASE_CLASS_TO_UNIT_TABLE.get(k0, []) + [v[0]]\n# logger_print()\n# logger_print(BASE_CLASS_TO_UNIT_TABLE)\n# breakpoint()\n# logger_print()\n# logger_print(TRANSLATION_TABLE)\n# breakpoint()\n# BASE_CLASS_TO_UNIT_TABLE = {\n#     k: v[0] for k, v in BASE_TRANSLATION_TABLE_WITH_BASE_UNIT.items()\n# }\n# logger_print(BASE_TRANSLATION_TABLE)\n# logger_print(TRANSLATION_TABLE)\n# breakpoint()\n# TRANSLATION_TABLE = revert_dict(BASE_TRANSLATION_TABLE)\n# TRANSLATION_TABLE = revert_dict({k: v for k, v in BASE_TRANSLATION_TABLE.items()})\n# LIST_TYPE = [\n#     \"\u5d4c\u5957\u8868\u683c\"\n# ]  # check this in the 2nd index  # notice, list contains multiple headings, each heading may have its own unit.\ndef add_range_translation(mdict, source, target):\n    mdict.update(\n        {\n            f\"\u6700\u5927{source}\": f\"Max{target}\",\n            f\"\u6700\u5c0f{source}\": f\"Min{target}\","
        },
        {
            "comment": "This code defines a dictionary for translating Chinese names to English ones and adds ranges for \"\u5b89\u88c5\u9762\u79ef\" (Area) and \"\u5b89\u88c5\u53f0\u6570\" (DeviceCount). It initializes an empty dictionary for the output data, then populates it with device parameters, design, and simulation data based on the input values and their corresponding units. The code also checks if there is a unit exception and translates the unit accordingly using the getSingleUnitConverted function.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/parse_units_and_names.py\":334-376",
            "content": "        }\n    )\nMETA_TRANSLATION_TABLE = {\n    \"\u8bbe\u8ba1\u89c4\u5212\": \"DesignParams\",\n    \"\u4eff\u771f\u6a21\u62df\": \"SimulationParams\",\n    \"\u8bbe\u5907\u9009\u578b\": \"DeviceModel\",\n}\nadd_range_translation(META_TRANSLATION_TABLE, \"\u5b89\u88c5\u9762\u79ef\", \"Area\")\nadd_range_translation(META_TRANSLATION_TABLE, \"\u5b89\u88c5\u53f0\u6570\", \"DeviceCount\")\n# you may copy this from the table, not parsing it though.\n# you need to check for units.\n# output_data = {\"unit_conversion\", \"\"}\noutput_data = {}  # category -> device_name -> {\u8bbe\u5907\u53c2\u6570, \u8bbe\u8ba1\u89c4\u5212, \u4eff\u771f\u6a21\u62df}\ndef getUnitConverted(val_name, val_unit):\n    base_classes = TRANSLATION_TABLE[val_name]\n    has_exception = False\n    _val_unit = val_unit\n    if _val_unit:\n        _val_unit = translateUnit(_val_unit)\n    for base_class in base_classes:\n        default_unit = BASE_CLASS_TO_UNIT_TABLE[base_class]\n        # iterate through all base classes.\n        val_unit = _val_unit\n        has_exception, val_unit = getSingleUnitConverted(\n            default_unit=default_unit, val_unit=val_unit\n        )\n        if has_exception:\n            continue\n        elif val:\n            # get factor:"
        },
        {
            "comment": "This code defines a function to convert a value's unit and name into a standard format. It uses the function `unitFactorCalculator` to calculate the magnitude and standard unit of the value in question. If an exception occurs during unit conversion, it raises an Exception. The `getValueParam` function returns the base class, value name, original unit, standard unit, and magnitude as a list for serialization purposes. Finally, the `wrapper_uc_vp` function gets the unit-converted values and formats them into a list before returning it.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/parse_units_and_names.py\":377-404",
            "content": "            logger_print(\"TRANS {} -> {}\".format(val_name, base_class))  # [PS]\n            mag, standard = unitFactorCalculator(ureg, standard_units, val_unit)\n            # logger_print(\"STANDARD:\", standard)\n            # logger_print(\"MAGNITUDE TO STANDARD:\", mag)\n            has_exception = False\n            return has_exception, (base_class, val_unit, mag, standard)\n    return True, (None, None, None, None)  # has_exception, uc\ndef getValueParam(uc, val_name):\n    (base_class, val_unit, mag, standard) = uc\n    vparam = [\n        base_class,\n        val_name,\n        val_unit,\n        standard,\n        mag,\n    ]  # to list. instead of tuple, for serialization\n    # vparam = (base_class, val_name, val_unit, standard, mag)\n    return vparam\ndef wrapper_uc_vp(val_name, val_unit):\n    has_exception, uc = getUnitConverted(val_name, val_unit)\n    if has_exception:\n        raise Exception(f\"No compatibie unit found for {val_name} with unit {val_unit}\")\n    vparam = getValueParam(uc, val_name)\n    return vparam"
        },
        {
            "comment": "The code is iterating over keys in a data dictionary and then over subkeys within each key. It checks the value of '\u4f20\u8f93\u7ebf' and creates an output_data dictionary if it exists. The code then checks if the value is a character type, meta type or skip type before appending to appropriate lists in the output_data dictionary.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/parse_units_and_names.py\":407-433",
            "content": "for key in keys:\n    logger_print(data[key].keys())\n    # val_list = data[key]\n    output_data[key] = {}\n    # logger_print(key)\n    # breakpoint()\n    for subkey in data[key].keys():\n        # missing!\n        # if subkey == '\u4f20\u8f93\u7ebf':  breakpoint()\n        output_data[key][subkey] = {\"\u8bbe\u5907\u53c2\u6570\": [], \"\u8bbe\u8ba1\u89c4\u5212\": [], \"\u4eff\u771f\u6a21\u62df\": []}\n        val_list = data[key][subkey]\n        # logger_print(val_list)\n        logger_print(\"____\" * 10 + \"[{}-{}]\".format(key, subkey))\n        meta_type = None\n        for index, val in enumerate(val_list):\n            val_is_table = data_is_excel[key][subkey][\n                index\n            ]  # TODO: USE THIS VALUE TO CHECK IF IS TABLE! (also the data format)\n            logger_print(\"____\" * 10)\n            from unit_utils import unitCleaner\n            val = unitCleaner(val)\n            logger_print(val)\n            if val in CHAR_TYPE:\n                logger_print(\"CHAR_TYPE\")\n                output_data[key][subkey][\"\u8bbe\u5907\u53c2\u6570\"].append(val)\n            elif val in META_TYPE or val in SKIP_TYPE:"
        },
        {
            "comment": "This code is appending values based on the type of simulation and subkey. It adds specific parameters for certain subkeys, such as transformer power factor and transformer redundancy coefficient. For lithium batteries, it includes initial state of charge (SOC), loop boundary conditions, maximum battery capacity, and minimum battery capacity. For solar power, it adds the maximum installation area.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/parse_units_and_names.py\":434-454",
            "content": "                logger_print(\"META_TYPE\")\n                meta_type = val\n                # appending values, presumed.\n                if meta_type in SKIP_TYPE:\n                    params = {\"\u8bbe\u8ba1\u89c4\u5212\": [], \"\u4eff\u771f\u6a21\u62df\": []}\n                    ## \u8bbe\u8ba1\u89c4\u5212\n                    dkey = \"\u8bbe\u8ba1\u89c4\u5212\"\n                    # extra\n                    if subkey in [\"\u53d8\u538b\u5668\"]:\n                        params[dkey].append(wrapper_uc_vp(\"\u529f\u7387\u56e0\u6570\", \"one\"))\n                        params[dkey].append(wrapper_uc_vp(\"\u53d8\u538b\u5668\u5197\u4f59\u7cfb\u6570\", \"one\"))\n                    # override\n                    if subkey in [\"\u9502\u7535\u6c60\"]:\n                        params[dkey].append(wrapper_uc_vp(\"\u521d\u59cbSOC\", \"percent\"))\n                        params[dkey].append(\"\u5faa\u73af\u8fb9\u754c\u6761\u4ef6\")\n                        params[dkey].append(wrapper_uc_vp(\"\u6700\u5927\u8bbe\u5907\u5bb9\u91cf\", \"kWh\"))  # \u603b\u5bb9\u91cf\n                        params[dkey].append(\n                            wrapper_uc_vp(\"\u6700\u5c0f\u8bbe\u5907\u5bb9\u91cf\", \"kWh\")\n                        )  # from excel.\n                    elif subkey in [\"\u5149\u4f0f\u53d1\u7535\"]:  # solar power.\n                        params[dkey].append(wrapper_uc_vp(\"\u6700\u5927\u5b89\u88c5\u9762\u79ef\", \"m2\"))"
        },
        {
            "comment": "This code is part of a function that takes input parameters, interprets them based on the subkey, and appends unit conversions to a list for each key. It handles cases such as \"\u6700\u5c0f\u5b89\u88c5\u9762\u79ef\", \"\u4f20\u8f93\u7ebf\", and \"\u53d8\u538b\u5668\". For \"\u4eff\u771f\u6a21\u62df\", it appends \"\u529f\u7387\u56e0\u6570\" if the subkey is \"\u53d8\u6362\u5668\". It overrides previous appends for \"\u4f20\u8f93\u7ebf\" and appends \"\u957f\u5ea6\" with unit \"km\". For \"\u9502\u7535\u6c60\", it adds \"\u521d\u59cbSOC\" and \"\u8bbe\u5907\u5bb9\u91cf\" with units \"percent\" and \"kWh\" respectively. The code is likely written in Python, considering the usage of \"append\" and list handling.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/parse_units_and_names.py\":455-475",
            "content": "                        params[dkey].append(\n                            wrapper_uc_vp(\"\u6700\u5c0f\u5b89\u88c5\u9762\u79ef\", \"m2\")\n                        )  # from excel.\n                    elif subkey in [\"\u4f20\u8f93\u7ebf\"]:  # transfer lines, pipes\n                        params[dkey].append(wrapper_uc_vp(\"\u957f\u5ea6\", \"km\"))\n                    else:\n                        params[dkey].append(wrapper_uc_vp(\"\u6700\u5927\u5b89\u88c5\u53f0\u6570\", \"\u53f0\"))\n                        params[dkey].append(wrapper_uc_vp(\"\u6700\u5c0f\u5b89\u88c5\u53f0\u6570\", \"\u53f0\"))\n                    ## \u4eff\u771f\u6a21\u62df\n                    dkey = \"\u4eff\u771f\u6a21\u62df\"\n                    # extra\n                    if subkey in [\"\u53d8\u538b\u5668\"]:\n                        params[dkey].append(wrapper_uc_vp(\"\u529f\u7387\u56e0\u6570\", \"one\"))\n                    # override\n                    if subkey in [\"\u4f20\u8f93\u7ebf\"]:\n                        params[dkey].append(wrapper_uc_vp(\"\u957f\u5ea6\", \"km\"))\n                    elif subkey in [\"\u9502\u7535\u6c60\"]:\n                        params[dkey].append(wrapper_uc_vp(\"\u521d\u59cbSOC\", \"percent\"))\n                        params[dkey].append(wrapper_uc_vp(\"\u8bbe\u5907\u5bb9\u91cf\", \"kWh\"))\n                    else:"
        },
        {
            "comment": "This code is parsing input data, handling units and names. It updates a dictionary with parameters and logs the information. It skips certain types of metadata for further checking.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/parse_units_and_names.py\":476-506",
            "content": "                        params[dkey].append(wrapper_uc_vp(\"\u5b89\u88c5\u53f0\u6570\", \"\u53f0\"))\n                    params[\"\u8bbe\u8ba1\u89c4\u5212\"].append(\"\u8bbe\u5907\u9009\u578b\")  # you may set the calculation mode.\n                    params[\"\u4eff\u771f\u6a21\u62df\"].append(\"\u8bbe\u5907\u9009\u578b\")\n                    output_data[key][subkey].update(params)\n                    logger_print(params)\n                    # str? -> str\n                    # tuple -> number with unit\n                    # dict -> table\n                    # breakpoint()\n            else:\n                # begin to parse it.\n                if val in COMMENT_TYPE:\n                    continue\n                from unit_utils import unitParser\n                result = unitParser(val)\n                if result:\n                    val_name, val_unit = (\n                        result[\"val_name\"].strip(),\n                        result[\"val_unit\"].strip(),\n                    )\n                else:\n                    val_name = val\n                    val_unit = None\n                if meta_type in SKIP_TYPE:\n                    # TODO: checking metadata."
        },
        {
            "comment": "Continuing the loop if val_name is already in TRANSLATION_TABLE keys. If not, gets the converted unit (has_exception and uc) from getUnitConverted function. Iterates through all base classes for val_name and checks compatibility of default_unit with val_unit. Logs DEFAULT UNIT and TRANS messages.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/parse_units_and_names.py\":507-524",
            "content": "                    continue\n                elif val_name in TRANSLATION_TABLE.keys():\n                    has_exception, uc = getUnitConverted(val_name, val_unit)\n                    # base_classes = TRANSLATION_TABLE[val_name]\n                    # has_exception = False\n                    # for base_class in base_classes:\n                    #     default_unit = BASE_CLASS_TO_UNIT_TABLE[base_class]\n                    #     # iterate through all base classes.\n                    #     logger_print(\"DEFAULT UNIT:\", default_unit)\n                    #     default_unit_real = ureg.Unit(default_unit)\n                    #     default_unit_compatible = ureg.get_compatible_units(\n                    #         default_unit_real\n                    #     )\n                    #     logger_print(\"TRANS {} -> {}\".format(val_name, base_class))\n                    #     if val_unit:\n                    #         for (\n                    #             trans_source_unit,\n                    #             trans_target_unit,"
        },
        {
            "comment": "The code checks the value unit and replaces it with the target unit in UNIT_TRANSLATION_TABLE. If no translation is found, it uses the default_unit and logs a message. It then creates a ureg Unit object from val_unit, retrieves compatible units, and compares them to default_unit_compatible. If not equal, it sets has_exception to True and logs an incompatibility message.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/parse_units_and_names.py\":525-541",
            "content": "                    #         ) in UNIT_TRANSLATION_TABLE.items():\n                    #             val_unit = val_unit.replace(\n                    #                 trans_source_unit, trans_target_unit\n                    #             )\n                    #         # parse this unit!\n                    #     else:\n                    #         val_unit = default_unit\n                    #         logger_print(\"USING DEFAULT UNIT\")\n                    #     logger_print(\"UNIT\", val_unit)\n                    #     unit = ureg.Unit(val_unit)\n                    #     compatible_units = ureg.get_compatible_units(val_unit)\n                    #     # logger_print(\"COMPATIBLE UNITS\", compatible_units)\n                    #     if not default_unit_compatible == compatible_units:\n                    #         has_exception = True\n                    #         logger_print(\n                    #             \"Unit {} not compatible with default unit {}\".format(\n                    #                 val_unit, default_unit"
        },
        {
            "comment": "This code block checks for compatible units and handles exceptions if no unit is found. If a unit exception occurs, it raises an Exception with the relevant information. It also retrieves a value parameter and handles table values differently.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/parse_units_and_names.py\":542-562",
            "content": "                    #             )\n                    #         )\n                    #         continue\n                    #     else:\n                    #         # get factor:\n                    #         mag, standard = unitFactorCalculator(\n                    #             ureg, standard_units, val_unit\n                    #         )\n                    #         logger_print(\"STANDARD:\", standard)\n                    #         logger_print(\"MAGNITUDE TO STANDARD:\", mag)\n                    #         has_exception = False\n                    #         break\n                    if has_exception:\n                        raise Exception(\n                            f\"No compatibie unit found for {val_name} (unit: {val_unit}, {key}, {subkey})\"\n                        )\n                        # raise Exception(f\"No compatibie unit found for {val_unit}\")\n                    else:\n                        v_param = getValueParam(uc, val_name)\n                        if val_is_table:\n                            (_, _, _, standard) = uc"
        },
        {
            "comment": "This code snippet retrieves a table format for the given value name and standard unit, converts it if necessary, and adds it to the output data. If no table format is found, an exception is raised. If there is no need for table formatting, it simply appends the normal value to the output data.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/parse_units_and_names.py\":563-584",
            "content": "                            logger_print(\"TABLE VALUE:\", val_name, standard)\n                            table_format = get_table_format(  # \u57fa\u672c\u4e0a\u90fd\u662f\u8d1f\u8f7d\u7387\n                                val_name, standard\n                            )  # unit vs\n                            t_name, t_unit = table_format\n                            has_exception, t_uc = getUnitConverted(t_name, t_unit)\n                            if has_exception:\n                                raise Exception(\n                                    \"No table format found for:\", val_name, val_unit\n                                )\n                            t_param = getValueParam(t_uc, t_name)\n                            new_param = {\"MAIN\": v_param, \"SUB\": t_param}\n                            # new_param = {v_param: t_param}\n                            # (name, original_name, original_unit, standard_unit, magnitude)\n                        else:\n                            # normal values.\n                            new_param = v_param\n                        output_data[key][subkey][\"\u8bbe\u5907\u53c2\u6570\"].append(new_param)"
        },
        {
            "comment": "Code is handling unknown values by raising an exception and logging the information. It then writes JSON formatted data to a specified file path, while logging the file save location.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/microgrid_base/parse_units_and_names.py\":585-597",
            "content": "                else:\n                    raise Exception(\"Unknown Value:\", val, key, subkey)\nlogger_print()\nlogger_print(output_data)\n# write documents for api?\n# or just a whole bunch of generated documents inserted into places?\nwith open(output_path, \"w+\") as f:\n    f.write(json.dumps(output_data, indent=4, ensure_ascii=False))\nlogger_print(\"SAVED TO:\", output_path)"
        }
    ]
}