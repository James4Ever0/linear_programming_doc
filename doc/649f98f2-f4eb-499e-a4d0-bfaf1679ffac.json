{
    "summary": "This code imports libraries, defines a Celery application for task queuing, includes functions from the \"microgrid_base\" module, and performs energy flow graph calculations. It initializes worker configuration limits, creates `CalculationResult` objects, and starts the Celery worker.",
    "details": [
        {
            "comment": "This code imports the necessary libraries and defines a Celery application for task queuing. It also includes two functions from the \"microgrid_base\" module, which are used within the main function. The main function is decorated as a task to be executed by Celery. It accepts an energy flow graph as input and returns a calculation result. The code tries to perform calculations on the graph and stores the result in a list. If no errors occur during the process, it sets success to True.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/fastapi_celery_server.py\":0-39",
            "content": "from celery import Celery\nfrom passwords import redis_password\nfrom typing import Union\nMAIN_NAME = \"fastapi_celery\"\napp = Celery(\n    MAIN_NAME,\n    broker=\"amqp://guest@localhost:5672//\",\n    backend=f\"redis://:{redis_password}@localhost:6379\",\n)\n# you'd better import models from other datamodel only file\n# you had not to pass anything like pydantic data model as parameter.\nfrom microgrid_base.solve_model import (\n    solveModelFromCalcParamList,\n    mDictListToCalcParamList,\n)\nfrom fastapi_datamodel_template import CalculationResult\n# from microgrid_base.ies_optim import EnergyFlowGraph\n@app.task(bind=True)  # parse it elsewhere.\ndef calculate_energyflow_graph(self, energyflow_graph: dict) -> Union[None, dict]:\n    \"\"\"\n    \u80fd\u6e90\u7cfb\u7edf\u4eff\u771f\u4f18\u5316\u8ba1\u7b97\u65b9\u6cd5\n    Args:\n        energyflow_graph (dict): \u80fd\u6d41\u62d3\u6251\u56fe\u548c\u8ba1\u7b97\u6240\u9700\u4fe1\u606f\n    Returns:\n        calculation_result (dict): \u8ba1\u7b97\u7ed3\u679c\n    \"\"\"\n    mDictList = energyflow_graph[\"mDictList\"]\n    calcParamList = mDictListToCalcParamList(mDictList)\n    resultList = []\n    error_log = \"\"\n    success = False\n    try:"
        },
        {
            "comment": "This code initializes a Celery application, sets worker configuration limits for memory, concurrency, and execution time. If the `solveModelFromCalcParamList` function does not return an empty list, it creates a `CalculationResult` object with the result, success status, and error log. Otherwise, it updates the state to \"FAILURE\" before configuring the worker settings. The main part of the code starts the Celery worker.",
            "location": "\"/media/root/Prima/works/generated_docs/linear_programming_doc/src/fastapi_celery_server.py\":40-70",
            "content": "        resultList = solveModelFromCalcParamList(calcParamList)\n    except:\n        import traceback\n        error_log = traceback.format_exc()\n        print(\"************CELERY ERROR************\")\n        print(error_log)\n    if resultList != []:\n        success = True\n        calculation_result = CalculationResult(\n            resultList=resultList, success=success, error_log=error_log\n        ).dict()\n        return calculation_result\n    else:\n        self.update_state(state=\"FAILURE\")\napp.conf.update(task_track_started=True)\napp.conf.update(worker_send_task_events=True)\nconcurrent_tasks = 3\napp.conf.update(worker_concurrency=concurrent_tasks)\nmemory_limit = 20_000_000  # kB\napp.conf.update(worker_max_memory_per_child=memory_limit)\ntime_limit = 60 * 10  # sec\napp.conf.update(worker_time_limit=time_limit)\n# limits on ram usage, concurrency, execution time\nif __name__ == \"__main__\":\n    worker = app.Worker()\n    worker.start()"
        }
    ]
}